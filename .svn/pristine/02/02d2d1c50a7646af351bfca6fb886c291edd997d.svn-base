package nexos.dao.ed.common;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.URL;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Types;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.MimeHeaders;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPConnection;
import javax.xml.soap.SOAPConnectionFactory;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPFault;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang.RandomStringUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.net.ftp.FTP;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPReply;
import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFDataFormat;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFRichTextString;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.hssf.util.HSSFColor.HSSFColorPredefined;
import org.apache.poi.ss.usermodel.BorderStyle;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.FillPatternType;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.VerticalAlignment;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFDataFormat;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRichTextString;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.security.access.annotation.Secured;
import org.springframework.security.oauth2.core.AuthorizationGrantType;
import org.springframework.security.oauth2.core.OAuth2AccessToken.TokenType;
import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames;
import org.springframework.stereotype.Repository;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpStatusCodeException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.pjfanning.xlsx.StreamingReader;
import com.github.pjfanning.xlsx.exceptions.NotSupportedException;
import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.Session;

import nexos.framework.Consts;
import nexos.framework.Util;
import nexos.framework.db.dynamic.DynamicDataSource;
import nexos.framework.json.MapListTypeReference;
import nexos.framework.json.MapTypeReference;
import nexos.framework.message.NexosMessage;
import nexos.framework.security.AuthenticationUtil;
import nexos.framework.support.DaoSupport;
import nexos.framework.support.NexosSupport;
import nexos.framework.web.NexosURLStreamHandler;

/**
 * Class: EDCommonDAOImpl<br>
 * Description: EDI Common DAO (Data Access Object) - 데이터처리를 담당하는 Class<br>
 * Copyright: Copyright (c) 2013 ASETEC Corporation. All rights reserved.<br>
 * Company : ASETEC<br>
 *
 * @author ASETEC
 * @version 1.0
 *          <pre style="font-family: GulimChe; font-size: 12px;">
 * ---------------------------------------------------------------------------------------------------------------------
 *  Version    Date          Author           Description
 * ---------  ------------  ---------------  ---------------------------------------------------------------------------
 *  1.0        2013-01-01    ASETEC           신규작성
 * ---------------------------------------------------------------------------------------------------------------------
 *          </pre>
 */
@Repository("EDCOMMONDAO")
@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
// 주입되는 Bean id 역활을 합니다. 구현 클라스에 따라서 이 부분을 주석처리합니다.
public class EDCommonDAOImpl extends DaoSupport implements EDCommonDAO, Comparator<Vector<Object>> {

    private final Logger logger                        = LoggerFactory.getLogger(EDCommonDAOImpl.class);

    final String         PROGRAM_ID                    = "EDCOMMON";

    final String         SELECT_ID_RS_REMOTE_INFO      = PROGRAM_ID + ".RS_REMOTE_INFO";
    final String         SELECT_ID_RS_DEFINE_INFO      = PROGRAM_ID + ".RS_DEFINE_INFO";
    final String         SELECT_ID_RS_IDENTIFIER_INFO  = PROGRAM_ID + ".RS_IDENTIFIER_INFO";
    final String         SELECT_ID_RS_ERROR_INFO       = PROGRAM_ID + ".RS_ERROR_INFO";
    final String         SELECT_ID_RS_RECV_RESULT_INFO = PROGRAM_ID + ".RS_RECV_RESULT_INFO";
    final String         SELECT_ID_RS_SEND_INFO        = PROGRAM_ID + ".RS_SEND_INFO";
    final String         SELECT_ID_RS_SEND_DETAIL_INFO = PROGRAM_ID + ".RS_SEND_DETAIL_INFO";
    final String         INSERT_ID_EMIFRESULT          = PROGRAM_ID + ".INSERT_EMIFRESULT";

    final String         SELECT_ID_DYNAMIC             = "WT.CS_DYNAMIC_SELECT";
    final String         UPDATE_ID_DYNAMIC             = "WT.CS_DYNAMIC_UPDATE";

    final String         SP_ID_ER_PROCESSING           = "ER_PROCESSING";
    final String         SP_ID_ER_PROCESSING_RESULT    = "ER_PROCESSING_RESULT";
    final String         SP_ID_ER_PROCESSING_AFTER     = "ER_PROCESSING_AFTER";
    final String         SP_ID_ES_PROCESSING           = "ES_PROCESSING";
    final String         SP_ID_ES_PROCESSING_RESULT    = "ES_PROCESSING_RESULT";
    final String         SP_ID_GET_SYSDATE             = "WC.GET_SYSDATE";
    final String         SP_ID_GET_SQL_VAL             = "WF.GET_SQL_VAL";
    final String         SP_ID_ER_RECV_GETNO           = "WT.ER_RECV_GETNO";
    final String         SP_ID_GET_ERROR_MESSAGE       = "WI.GET_ERROR_MESSAGE";
    final String         SP_ID_GET_SEND_UPDATE_INFO    = "WI.GET_SEND_UPDATE_INFO";

    // 데이터 타입
    final String         DT_STRING                     = "1";                                           // 문자열
    final String         DT_DATE                       = "2";                                           // 날짜
    final String         DT_NUMBER                     = "3";                                           // 숫자

    // 데이터베이스 종류
    final String         DB_ORACLE                     = "oracle";
    final String         DB_MSSQL                      = "mssql";
    final String         DB_MYSQL                      = "mysql";

    // SQL 문장 생성 구분자 상수
    final String         SC_BIND                       = "?";
    final String         SC_SEP                        = " ,";
    final String         SC_AND                        = " AND ";
    final String         SC_AS                         = " AS ";
    final String         SC_EQUAL                      = " = ";
    final String         SC_O_BRACKET                  = "(";
    final String         SC_C_BRACKET                  = ")";

    private Charset detectCharset(File f, String[] charsets) {

        Charset charset = null;

        for (String charsetName : charsets) {
            charset = detectCharset(f, Charset.forName(charsetName));
            if (charset != null) {
                break;
            }
        }
        return charset;
    }

    private Charset detectCharset(File f, Charset charset) {

        BufferedInputStream bufferedInput = null;
        try {
            bufferedInput = new BufferedInputStream(new FileInputStream(f));
            CharsetDecoder decoder = charset.newDecoder();
            decoder.reset();

            byte[] tempBuffer = new byte[8192];
            byte[] buffer = null;

            // 파일에서 8192 byte만 읽음
            bufferedInput.read(tempBuffer);

            // 읽은 데이터에서 1 라인만 체크하기 위해 1라인만 추출
            int bufferLen = tempBuffer.length - 1;
            for (int i = 0; i < bufferLen; i++) {
                if (tempBuffer[i] == 13 || tempBuffer[i] == 10) {
                    buffer = new byte[i];
                    System.arraycopy(tempBuffer, 0, buffer, 0, i);
                    break;
                }
            }
            if (buffer == null) {
                // 1라인이 버퍼 사이즈보다 긴 경우 문자가 잘릴 수 있음, 문자 깨짐 조정
                for (int i = bufferLen; i >= 0; i--) {
                    if (tempBuffer[i] >= 0) {
                        bufferLen = i;
                        break;
                    }
                }
                buffer = new byte[bufferLen + 1];
                System.arraycopy(tempBuffer, 0, buffer, 0, buffer.length);
            }
            // 체크
            if (identifyCharset(buffer, decoder)) {
                return charset;
            } else {
                return null;
            }
        } catch (Exception e) {
            return null;
        } finally {
            Util.closeObject(bufferedInput);
        }
    }

    private boolean identifyCharset(byte[] bytes, CharsetDecoder decoder) {

        try {
            decoder.decode(ByteBuffer.wrap(bytes));
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    private int getXLSColumnIndex(String columnName) {

        columnName = columnName.toUpperCase();
        short value = 0;
        for (int i = 0, k = columnName.length() - 1; i < columnName.length(); i++, k--) {
            int alpabetIndex = (short)columnName.charAt(i) - 64;
            int delta = 0;
            if (k == 0) {
                delta = alpabetIndex - 1;
            } else {
                if (alpabetIndex == 0) {
                    delta = 26 * k;
                } else {
                    delta = alpabetIndex * 26 * k;
                }
            }
            value += delta;
        }
        return value;
    }

    /**
     * 처리할 Row의 Cell에 값이 하나라도 입력되어 있는지 체크<br>
     * <br>
     * ※ 제공 Method로 Row 수 체크시 사용자 입력 방법에 따라 빈 Row가 대상이 되는 현상 발생<br>
     * 해당 문제 해결을 위한 데이터 입력 Row 체크 Function<br>
     * Row의 Cell에 값이 하나라도 입력이 되어 있어야 처리 대상이 됨. 값이 없을 경우 다음 Row 처리
     *
     * @return
     */
    private boolean isXLSEmptyRow(Row xlsRow, ArrayList<Vector<Object>> columns, SimpleDateFormat stringDatetimeFormat,
        NumberFormat stringNumberFormat) {

        for (int cIndex = 0, cCount = columns.size(); cIndex < cCount; cIndex++) {
            // Vector 0: 파라메터명
            // Vector 1: 컬럼명
            // Vector 2: 엑셀 컬럼 인덱스
            // 빈 값이 아닐경우 리턴
            if (Util.isNotNull(getXLSColumnValue(xlsRow, (Integer)columns.get(cIndex).get(2), stringDatetimeFormat, stringNumberFormat))) {
                return false;
            }
        }

        // 체크 대상이 없거나 모두 빈값일 경우
        return true;
    }

    /**
     * 엑셀의 Row에서 Cell의 타입에 따라 값을 변환하여 리턴
     *
     * @param xlsRow
     * @param xlsCol
     * @param stringDatetimeFormat
     * @param stringNumberFormat
     * @return
     */
    private String getXLSColumnValue(Row xlsRow, int xlsCol, SimpleDateFormat stringDatetimeFormat, NumberFormat stringNumberFormat) {

        String result = "";

        Cell xlsCell = xlsRow.getCell(xlsCol);
        if (xlsCell != null) {
            CellType cellType = xlsCell.getCellType();
            // 수식 참조일 경우 참조 정보 CellType으로 처리
            if (CellType.FORMULA.equals(cellType)) {
                cellType = xlsCell.getCachedFormulaResultType();
                // HSSFCell, XSSFCell일 경우는 정상 Type 리턴
                // logger.info(xlsCol + ": " + cellType.name());
                // StreamingCell일 경우 일부 참조 Formula로 리턴되는 경우도 있음
                // "값" 형식, " 제거 후 리턴
                // com.monitorjbl.xlsxstreamer v1.2.1 기준
                if (CellType.FORMULA.equals(cellType)) {
                    XSSFRichTextString cellValue = new XSSFRichTextString(xlsCell.getStringCellValue());
                    result = cellValue.getString();
                    if (result.startsWith("\"") && result.endsWith("\"")) {
                        result = result.substring(1, result.length() - 1);
                    }
                    return result.trim();
                }
            }

            // 문자열
            if (CellType.STRING.equals(cellType)) {
                result = xlsCell.getRichStringCellValue().getString().trim();
            }
            // 숫자
            else if (CellType.NUMERIC.equals(cellType)) {
                if (DateUtil.isCellDateFormatted(xlsCell)) {
                    result = stringDatetimeFormat.format(xlsCell.getDateCellValue());
                } else {
                    result = stringNumberFormat.format(xlsCell.getNumericCellValue());
                }
            }
            // Boolean
            else if (CellType.BOOLEAN.equals(cellType)) {
                try {
                    result = String.valueOf(xlsCell.getBooleanCellValue());
                } catch (NotSupportedException e) {
                    // TODO: StreamingCell Formula 결과 값이 Boolean일 경우 미지원, False 값 리턴
                    // com.monitorjbl.xlsxstreamer v1.2.1 기준
                    result = "0";
                }
            }
            // Error Cell, Cell 값이 Error일 경우 처리 안함, since 7.0.0
            // else if (CellType.ERROR.equals(cellType)) {
            // result = String.valueOf(xlsCell.getErrorCellValue());
            // }
        }

        return result;
    }

    private String getXMLColumnValue(Vector<Object> vtColumn, Element xmlDataElement) throws Exception {

        String result = "";

        // String columnNm = (String)vtColumn.get(0);
        // String xmlTag = (String)vtColumn.get(1);
        String xmlTagAttr = (String)vtColumn.get(2);
        String[] xmlTags = (String[])vtColumn.get(3);

        NodeList xmlColumnNodeList = null;
        Element xmlColumnElement = xmlDataElement;
        Node xmlColumnNode = null;
        for (int i = 0, nodeLevel = xmlTags.length; i < nodeLevel; i++) {
            xmlColumnNodeList = xmlColumnElement.getElementsByTagName(xmlTags[i]);
            if (xmlColumnNodeList.getLength() == 0) {
                // throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.073","[컬럼명,태그명: " + columnNm + "," + xmlTag + "]XML 파일에 해당 태그가 정의되어
                // 있지 않습니다.",new String[] {columnNm, xmlTag}));
                return result;
            }
            xmlColumnNode = xmlColumnNodeList.item(0);
            if (xmlColumnNode.getNodeType() != Node.ELEMENT_NODE) {
                // throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.073","[컬럼명,태그명: " + columnNm + "," + xmlTag + "]XML 파일에 해당 태그가 정의되어
                // 있지 않습니다.",new String[] {columnNm, xmlTag}));
                return result;
            }
            xmlColumnElement = (Element)xmlColumnNode;
        }

        if (Util.isNotNull(xmlTagAttr)) {
            if (!xmlColumnElement.hasAttribute(xmlTagAttr)) {
                // throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.074","[컬럼명,태그명,속성명: " + columnNm + "," + xmlTag + "," + xmlTagAttr +
                // "]XML 파일에 해당 태그/속성이 정의되어 있지 않습니다.",new String[] {columnNm, xmlTag, xmlTagAttr}));
                return result;
            }
            // result = xmlColumnNode.getAttributes().getNamedItem(xmlTagAttr).getNodeValue();
            result = xmlColumnElement.getAttribute(xmlTagAttr);
            // logger.info("xmlTagAttr 1=" + result);
            // logger.info("xmlTagAttr 2=" + xmlColumnElement.getAttribute(xmlTagAttr));
        } else {
            // result = xmlColumnElement.getChildNodes().item(0).getNodeValue();
            result = xmlColumnElement.getTextContent();
            // logger.info("xmlTag 1=" + result);
            // logger.info("xmlTag 2=" + xmlColumnElement.getTextContent());
        }

        return result;
    }

    public Map<String, Object> getRemoteParamMaps(String defineDiv, String dbType, String remoteParamMap, List<String> lstBindingParams,
        String userId) {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        final String C_KEY_SEPARATOR = "=";
        final String C_MULTIPLE_SEPARATOR = ";";
        final String C_DATA_SEPARATOR = ",";

        // 수신 - 파라메터매핑 파싱
        // remoteParamMap Sample
        // ALL_PARAMS=P_BU_CD,P_DEFINE_NO,P_RECV_DATE,P_USER_ID
        // P_BU_CD=RD
        // P_DEFINE_NO=0001
        // P_RECV_DATE=SQL#[WF.D_TO_CHAR(SYSDATE)]
        // P_USER_ID=RND
        // 송신 - 파라메터매핑 파싱
        // remoteParamMap Sample
        // ALL_PARAMS=EDI_COD,ORD_NUM,WBL_NUM,DLV_DIV,CUS_NUM,PIC_YMD,SND_ZIP,SND_AD1,SND_AD2,SND_NAM,SND_TEL,SND_HPH,SND_CRG,RCV_ZIP,RCV_AD1,RCV_AD2,RCV_NAM,RCV_TEL,RCV_HPH,RCV_CRG,DLV_MSG,GOD_NAM,BOX_QTY,PAY_CON,BOX_TYP,MEM_NO1,MEM_NO2,MEM_NO3,MEM_NO4,O_YN,O_SQLCODE,O_SQLERRM
        // OUT_PARAMS=O_YN,O_SQLCODE,O_SQLERRM;1,1,1
        // ERROR_CD=O_YN;Y
        // ERROR_MSG=O_SQLCODE,O_SQLERRM;[%s]%s
        try {
            String[] allParams = null;
            String[] remoteParamMaps = Util.split(remoteParamMap, "\\r?\\n");
            // 수신
            if (Util.equals(Consts.DEFINE_DIV_RECV, defineDiv)) {
                allParams = new String[] {};
                Map<String, Object> linkBindingParams = new HashMap<String, Object>();
                for (String remoteParam : remoteParamMaps) {
                    String[] anyParams = remoteParam.split(C_KEY_SEPARATOR);
                    switch (anyParams[0]) {
                        case "ALL_PARAMS":
                            allParams = anyParams[1].split(C_DATA_SEPARATOR);
                            break;
                        default:
                            if (Util.isNull(anyParams[0])) {
                                continue;
                            }
                            linkBindingParams.put(anyParams[0], remoteParam);
                            break;
                    }
                }

                if (allParams.length == 0 && linkBindingParams.size() > 0) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.075", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\n" //
                        + "ALL_PARAMS 항목이 입력되어 있는지 확인하십시오."));
                }

                // 파라메터수에 맞게 바인딩 문자열 결합
                // JDBC 값 바인딩을 위해 인덱스 기록
                // 바인딩 인덱스 시작은 1부터, ORACLE일 경우 1은 RETURN CURSOR라 파라메터는 2부터
                int columnIndex = Util.iif(DB_ORACLE.equals(dbType), 2, 1);
                Map<String, Integer> linkParamOrders = new HashMap<String, Integer>();
                for (int rIndex = 0, rCount = allParams.length; rIndex < rCount; rIndex++) {
                    String linkParamKey = allParams[rIndex];
                    if (Util.isNull(linkParamKey)) {
                        continue;
                    }
                    String linkParamValue = ((String)linkBindingParams.get(linkParamKey)).replaceFirst(linkParamKey + C_KEY_SEPARATOR, "");
                    // [NULL], [USER_ID], [SYSDATE], [...] ... 필요시 추가 코딩
                    if (linkParamValue.startsWith("[") && linkParamValue.endsWith("]")) {
                        switch (linkParamValue) {
                            case "[NULL]":
                                lstBindingParams.add("NULL");
                                break;
                            case "[USER_ID]":
                                lstBindingParams.add(Util.toSingleQuoted(userId));
                                break;
                            case "[SYSDATE]":
                                lstBindingParams.add("SYSDATE");
                                break;
                            default:
                                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.076",
                                    "수신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\n" + linkParamValue + "는 처리할 수 없는 값입니다.", new String[] {linkParamValue}));
                        }
                        // 고정값, 바인딩에서 제거
                        linkBindingParams.remove(linkParamKey);
                    }
                    // SQL문 처리
                    // <SQL문>
                    else if (linkParamValue.startsWith("<") && linkParamValue.endsWith(">")) {
                        lstBindingParams.add(linkParamValue.substring(1, linkParamValue.length() - 1));
                        // 고정값, 바인딩에서 제거
                        linkBindingParams.remove(linkParamKey);
                    }
                    // SQL#[SQL_TEXT]# or 상수값은 바인딩으로 처리
                    else {
                        linkParamOrders.put(linkParamKey, Integer.valueOf(columnIndex));
                        lstBindingParams.add(SC_BIND);
                        // SQL#[SQL_TEXT]# 처리, SQL 형식이 아닐 경우는 원 값 그대로
                        linkBindingParams.put(linkParamKey, replaceSQLText(linkParamValue));
                        columnIndex++;
                    }
                }
                if (linkParamOrders.size() != linkBindingParams.size()) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.077", "수신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nALL_PARAMS에 정의된 파라메터와 입력된 파라메터의 건수가 다릅니다."));
                }

                resultMap.put("P_LINK_PARAM_ORDERS", linkParamOrders);
                resultMap.put("P_LINK_BINDING_PARAMS", linkBindingParams);
            }
            // 송신
            else {
                if (remoteParamMaps.length != 4) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.078", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\n" //
                        + "ALL_PARAMS, OUT_PARAMS, ERROR_CD, ERROR_MSG 항목이 입력되어 있는지 확인하십시오."));
                }

                String[] outParamMaps = null;
                String[] errorCdParamMaps = null;
                String[] errorMsgParamMaps = null;
                for (String remoteParam : remoteParamMaps) {
                    String[] anyParams = remoteParam.split(C_KEY_SEPARATOR);
                    switch (anyParams[0]) {
                        case "ALL_PARAMS":
                            allParams = anyParams[1].split(C_DATA_SEPARATOR);
                            break;
                        case "OUT_PARAMS":
                            outParamMaps = anyParams[1].split(C_MULTIPLE_SEPARATOR);
                            break;
                        case "ERROR_CD":
                            errorCdParamMaps = anyParams[1].split(C_MULTIPLE_SEPARATOR);
                            break;
                        case "ERROR_MSG":
                            errorMsgParamMaps = anyParams[1].split(C_MULTIPLE_SEPARATOR);
                            break;
                    }
                }
                if (allParams == null || outParamMaps == null || errorCdParamMaps == null) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.078", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\n" //
                        + "ALL_PARAMS, OUT_PARAMS, ERROR_CD, ERROR_MSG 항목이 입력되어 있는지 확인하십시오."));
                }
                if (outParamMaps.length != 2 || errorCdParamMaps.length != 2 || errorMsgParamMaps != null && errorMsgParamMaps.length != 2) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.079", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\n" //
                        + "OUT_PARAMS, ERROR_CD, ERROR_MSG 항목이 형식에 맞게 입력되어 있는지 확인하십시오."));
                }

                // 파라메터수에 맞게 바인딩 문자열 결합
                // JDBC 값 바인딩을 위해 인덱스 기록
                Map<String, Integer> linkParamOrders = new HashMap<String, Integer>();
                for (int rIndex = 0, rCount = allParams.length; rIndex < rCount; rIndex++) {
                    lstBindingParams.add(SC_BIND);
                    linkParamOrders.put(allParams[rIndex], Integer.valueOf(rIndex + 1));
                }
                if (allParams.length != linkParamOrders.size()) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.080", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nALL_PARAMS에 중복된 값이 존재합니다."));
                }

                // OUTPUT 파라메터 파싱
                // JDBC OUTPUT 파라메터 등록을 위한 정보 기록
                String[] outParamNames = outParamMaps[0].split(C_DATA_SEPARATOR);
                String[] outParamTypes = outParamMaps[1].split(C_DATA_SEPARATOR);
                if (outParamNames.length != outParamTypes.length) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.081", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nOUT_PARAMS의 파라메터, 데이터타입의 건수가 다릅니다."));
                }

                Map<String, Object> linkOutputParams = new HashMap<String, Object>();
                for (int rIndex = 0, rCount = outParamNames.length; rIndex < rCount; rIndex++) {
                    Integer linkColumnOrder = linkParamOrders.get(outParamNames[rIndex]);
                    if (linkColumnOrder == null) {
                        throw new RuntimeException(
                            NexosMessage.getDisplayMsg("JAVA.ED.082", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nOUT_PARAMS의 컬럼이 ALL_PARAMS에 존재하지 않습니다."));
                    }
                    linkOutputParams.put(outParamNames[rIndex], outParamTypes[rIndex]);
                }

                // Call 성공여부 판단을 위한 ERROR_CD 파싱, params에 기록
                String[] errorCdParamNames = errorCdParamMaps[0].split(C_DATA_SEPARATOR);
                String[] errorCdParamValues = errorCdParamMaps[1].split(C_DATA_SEPARATOR);
                if (errorCdParamNames.length != errorCdParamValues.length) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.083", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nERROR_CD의 컬럼, 값의 건수가 다릅니다."));
                }
                String[] errorMsgParams = null;
                StringBuffer sbErrorMsgFormat = new StringBuffer();
                boolean isNoErrorMsgParamMaps = errorMsgParamMaps == null;
                List<Vector<Object>> linkErrorCdParams = new ArrayList<Vector<Object>>();
                for (int rIndex = 0, rCount = errorCdParamNames.length; rIndex < rCount; rIndex++) {
                    Integer linkColumnOrder = linkParamOrders.get(errorCdParamNames[rIndex]);
                    if (linkColumnOrder == null) {
                        throw new RuntimeException(
                            NexosMessage.getDisplayMsg("JAVA.ED.084", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nnERROR_CD의 컬럼이 ALL_PARAMS에 존재하지 않습니다."));
                    }
                    Vector<Object> errorCdParam = new Vector<Object>();
                    errorCdParam.add(errorCdParamNames[rIndex]); // 0 - Column
                    errorCdParam.add(linkColumnOrder.intValue()); // 1 - Index
                    errorCdParam.add(errorCdParamValues[rIndex]); // 2 - Value

                    // ERROR_MSG 미입력일 경우 오류 메시지 생성
                    if (isNoErrorMsgParamMaps) {
                        sbErrorMsgFormat.append(SC_SEP).append("[").append(errorCdParam.get(0)).append("=").append(errorCdParam.get(2)).append("]");
                    }
                    linkErrorCdParams.add(errorCdParam);
                }
                if (isNoErrorMsgParamMaps && sbErrorMsgFormat.length() > 0) {
                    sbErrorMsgFormat.delete(0, SC_SEP.length()).append(NexosMessage.getDisplayMsg("JAVA.ED.156", "호출 결과 값이 정상 값이 아닙니다."));
                }

                List<Vector<Object>> linkErrorMsgParams = new ArrayList<Vector<Object>>();
                // ERROR_MSG 입력일 경우
                if (!isNoErrorMsgParamMaps) {
                    errorMsgParams = errorMsgParamMaps[0].split(",");
                    if (errorMsgParams.length != StringUtils.countMatches(errorMsgParamMaps[1], "%s")) {
                        throw new RuntimeException(
                            NexosMessage.getDisplayMsg("JAVA.ED.085", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nERROR_MSG의 컬럼, 포맷의 \"%s\" 건수가 다릅니다."));
                    }
                    for (int rIndex = 0, rCount = errorMsgParams.length; rIndex < rCount; rIndex++) {
                        Integer linkColumnOrder = linkParamOrders.get(errorMsgParams[rIndex]);
                        if (linkColumnOrder == null) {
                            throw new RuntimeException(
                                NexosMessage.getDisplayMsg("JAVA.ED.086", "송신정의 원격파라메터매핑 값이 잘못 지정되어 있습니다.\nnERROR_MSG의 컬럼이 ALL_PARAMS에 존재하지 않습니다."));
                        }
                        Vector<Object> errorMsgParam = new Vector<Object>();
                        errorMsgParam.add(errorMsgParams[rIndex]); // Column
                        errorMsgParam.add(linkColumnOrder.intValue()); // Index

                        linkErrorMsgParams.add(errorMsgParam);
                    }
                    sbErrorMsgFormat.append(errorMsgParamMaps[1]);
                }

                resultMap.put("P_LINK_PARAM_ORDERS", linkParamOrders);
                resultMap.put("P_LINK_OUTPUT_PARAMS", linkOutputParams);
                resultMap.put("P_LINK_ERROR_CD_PARAMS", linkErrorCdParams);
                resultMap.put("P_LINK_ERROR_MSG_PARAMS", linkErrorMsgParams);
                resultMap.put("P_LINK_ERROR_MSG_FORMAT", sbErrorMsgFormat.toString());
            }

            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            Util.setOutMessage(resultMap, Util.getErrorMessage(e));
        }

        return resultMap;
    }

    @Override
    public List<Map<String, Object>> getDefineInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_DEFINE_INFO, params);
    }

    @Override
    public List<Map<String, Object>> getIdentifierInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_IDENTIFIER_INFO, params);
    }

    @Override
    public List<Map<String, Object>> getDefineRemoteInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_REMOTE_INFO, params);
    }

    @Override
    public List<Map<String, Object>> getErrorInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_ERROR_INFO, params);
    }

    @Override
    public List<Map<String, Object>> getRecvResultInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_RECV_RESULT_INFO, params);
    }

    @Override
    public List<Map<String, Object>> getSendInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_SEND_INFO, params);
    }

    @Override
    public List<Map<String, Object>> getSendDetailInfo(Map<String, Object> params) {

        return getDataList(SELECT_ID_RS_SEND_DETAIL_INFO, params);
    }

    @Override
    public Map<String, Object> recvDataProcessing(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = null;

        String dataDiv = Util.nullToEmpty(params.get("P_DATA_DIV"));

        if (Util.isNull(params.get("P_RECV_DATE"))) {
            params.put("P_RECV_DATE", getEDIDate());
        }
        // DBLink
        if (Consts.DATA_DIV_DBLINK.equals(dataDiv)) {
            resultMap = recvDBLink(params);
        }
        // DBConnect
        else if (Consts.DATA_DIV_DBCONNECT.equals(dataDiv)) {
            resultMap = recvDBConnect(params);
        }
        // EXCEL
        else if (Consts.DATA_DIV_XLS.equals(dataDiv)) {
            resultMap = recvExcel(params);
        }
        // TEXT
        else if (Consts.DATA_DIV_TXT.equals(dataDiv)) {
            resultMap = recvText(params);
        }
        // XML
        else if (Consts.DATA_DIV_XML.equals(dataDiv)) {
            resultMap = recvXML(params);
        }
        // JSON
        else if (Consts.DATA_DIV_JSON.equals(dataDiv)) {
            resultMap = recvJson(params);
        }
        // SAP
        else if (Consts.DATA_DIV_SAP.equals(dataDiv)) {
            resultMap = recvSAPFunction(params);
        }
        // 기타 오류
        else {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.087", "[" + dataDiv + "]정의되지 않은 데이터 처리유형입니다.", new String[] {dataDiv}));
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> callGetErrorMessage(Map<String, Object> params) {

        return callProcedure(SP_ID_GET_ERROR_MESSAGE, params);
    }

    @Override
    public Map<String, Object> callERProcessing(Map<String, Object> params) throws Exception {

        return callERProcessingInternal(SP_ID_ER_PROCESSING, params);
    }

    @Override
    public Map<String, Object> callERProcessingResult(Map<String, Object> params) throws Exception {

        return callERProcessingInternal(SP_ID_ER_PROCESSING_RESULT, params);
    }

    private Map<String, Object> callERProcessingInternal(String queryId, Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = null;

        String dataDiv = Util.nullToEmpty(params.get("P_DATA_DIV"));
        if (Consts.DATA_DIV_DBLINK.equals(dataDiv) //
            || Consts.DATA_DIV_DBCONNECT.equals(dataDiv) //
            || Consts.DATA_DIV_XLS.equals(dataDiv) //
            || Consts.DATA_DIV_TXT.equals(dataDiv) //
            || Consts.DATA_DIV_XML.equals(dataDiv) //
            || Consts.DATA_DIV_JSON.equals(dataDiv) //
            || Consts.DATA_DIV_SAP.equals(dataDiv) //
        ) {
            // DBLink, DBConnect, EXCEL, TEXT, XML, JSON
            resultMap = callProcedure(queryId, params);
        } else {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.087", "[" + dataDiv + "]정의되지 않은 데이터 처리유형입니다.", new String[] {dataDiv}));
        }

        return resultMap;
    }

    @Override
    public Map<String, Object> callERProcessingAfter(Map<String, Object> params) throws Exception {

        return callProcedure(SP_ID_ER_PROCESSING_AFTER, params);
    }

    @Override
    public Map<String, Object> callESProcessing(Map<String, Object> params) throws Exception {

        return callESProcessingInternal(SP_ID_ES_PROCESSING, params);
    }

    @Override
    public Map<String, Object> callESProcessingResult(Map<String, Object> params) throws Exception {

        return callESProcessingInternal(SP_ID_ES_PROCESSING_RESULT, params);
    }

    private Map<String, Object> callESProcessingInternal(String queryId, Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = null;

        String dataDiv = Util.nullToEmpty(params.get("P_DATA_DIV"));
        if (Consts.DATA_DIV_DBLINK.equals(dataDiv) //
            || Consts.DATA_DIV_DBCONNECT.equals(dataDiv) //
            || Consts.DATA_DIV_XLS.equals(dataDiv) //
            || Consts.DATA_DIV_TXT.equals(dataDiv) //
            || Consts.DATA_DIV_XML.equals(dataDiv) //
            || Consts.DATA_DIV_JSON.equals(dataDiv) //
            || Consts.DATA_DIV_SAP.equals(dataDiv) //
        ) {
            // DBLink, DBConnect, EXCEL, TEXT, XML, JSON
            resultMap = callProcedure(queryId, params);
        } else {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.087", "[" + dataDiv + "]정의되지 않은 데이터 처리유형입니다.", new String[] {dataDiv}));
        }

        return resultMap;
    }

    @Override
    public Map<String, Object> sendFileDownload(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = null;

        String dataDiv = Util.nullToEmpty(params.get("P_DATA_DIV"));
        // 파일 처리
        if (dataDiv.startsWith("3")) {
            try {
                // EXCEL
                if (Consts.DATA_DIV_XLS.equals(dataDiv)) {
                    resultMap = sendExcel(params);
                }
                // TEXT
                else if (Consts.DATA_DIV_TXT.equals(dataDiv)) {
                    resultMap = sendText(params);
                }
                // XML
                else if (Consts.DATA_DIV_XML.equals(dataDiv)) {
                    resultMap = sendXML(params);
                }
                // JSON
                else if (Consts.DATA_DIV_JSON.equals(dataDiv)) {
                    resultMap = sendJson(params);
                }
                // 기타 오류
                else {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.088", "[" + dataDiv + "]파일 다운로드 가능한 데이터 처리유형이 아닙니다.", new String[] {dataDiv}));
                }

                String oMsg = Util.getOutMessage(resultMap);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(oMsg);
                }
            } catch (Exception e) {
                throw new RuntimeException(Util.getErrorMessage(e));
            }
        } else {
            throw new RuntimeException(
                NexosMessage.getDisplayMsg("JAVA.ED.088", "[" + dataDiv + "]파일 다운로드 가능한 데이터 처리유형이 아닙니다.", new String[] {dataDiv}));
        }
        return resultMap;
    }

    @Override
    public String getEDIDate() throws Exception {

        return getSysDatetime(true);
    }

    @Override
    public String getEDIDatetime() throws Exception {

        return getSysDatetime(false);
    }

    private String getSysDatetime(boolean returnOnlyDate) throws Exception {

        String result;
        List<Map<String, Object>> list = getDataList(SP_ID_GET_SYSDATE);
        if (list == null || list.size() == 0) {
            SimpleDateFormat sdf = new SimpleDateFormat(returnOnlyDate ? Consts.DATE_FORMAT : Consts.DATETIME_FORMAT);
            result = sdf.format(System.currentTimeMillis());
        } else {
            Map<String, Object> rowData = list.get(0);
            result = (String)rowData.get(returnOnlyDate ? "SYS_DATE" : "SYS_DATETIME");
        }

        return result;
    }

    @Override
    public DaoSupport getDaoSupport() {

        return this;
    }

    @Override
    public Map<String, Object> getJsonResultInfo(String jsonTagResult, String jsonTagResultMap) {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        resultMap.put("P_TAG_RESULT", jsonTagResult);
        // 매핑 키=값 파싱
        Map<String, Object> mappingKeyValues = Util.toKeyValues(jsonTagResultMap);
        // 결과 정보를 EDI Table Insert에 대해서만 처리할지 여부
        resultMap.put("P_RETURN_AFTER_DATA_INSERT", Util.nullToDefault(mappingKeyValues.get("RETURN_AFTER_DATA_INSERT"), //
            NexosSupport.getGlobalProperty("EDI.IFAPI.RETURN_AFTER_DATA_INSERT", Consts.YES)));
        // 정상코드 값, 0, S
        resultMap.put("P_RESULT_CD_SUCCESS", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_SUCCESS"), //
            NexosSupport.getGlobalProperty("EDI.WS.RESULT_CD.SUCCESS", Consts.EDI_RESULT_CD_SUCCESS)));
        // 오류코드 값, -1, F
        resultMap.put("P_RESULT_CD_ERROR", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_ERROR"), //
            NexosSupport.getGlobalProperty("EDI.WS.RESULT_CD.ERROR", Consts.EDI_RESULT_CD_ERROR)));
        // 코드 데이터 타입, STRING, NUMBER
        resultMap.put("P_RESULT_CD_DATA_TYPE", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_DATA_TYPE"), //
            NexosSupport.getGlobalProperty("EDI.WS.RESULT_CD.DATA_TYPE", "STRING")));
        // Response Message URLEncoder 처리 여부
        resultMap.put("P_MESSAGE_ENCODE_YN", Util.nullToDefault(mappingKeyValues.get("MESSAGE_ENCODE_YN"), //
            NexosSupport.getGlobalProperty("EDI.WS.JSON.MESSAGE_ENCODE_YN", Consts.NO)));
        // Response Message URLDecoder 처리 여부
        resultMap.put("P_MESSAGE_DECODE_YN", Util.nullToDefault(mappingKeyValues.get("MESSAGE_DECODE_YN"), //
            NexosSupport.getGlobalProperty("EDI.WS.JSON.MESSAGE_DECODE_YN", Consts.NO)));
        // Response Message
        resultMap.put("P_RESULT_MESSAGE", Util.nullToDefault(mappingKeyValues.get("RESULT_MESSAGE"), //
            NexosSupport.getGlobalProperty("EDI.WS.JSON.RESULT_MESSAGE", "{ \"result\": #RESULT_CD#, \"message\": #RESULT_MSG# }")));
        // Response 결과 데이터 TAG
        resultMap.put("P_RETURN_BUNCH", Util.nullToDefault(mappingKeyValues.get("RETURN_BUNCH"), //
            NexosSupport.getGlobalProperty("EDI.WS.JSON.RETURN_BUNCH", "")));
        // 처리 결과 코드 값 검색 Regex Pattern
        resultMap.put("P_PATTERN_RESULT_CD", Util.nullToDefault(mappingKeyValues.get("PATTERN_RESULT_CD"), //
            NexosSupport.getGlobalProperty("EDI.WS.JSON.PATTERN_RESULT_CD", "\\\"result\\\"\\s{0,}:\\s{0,}(.*?)\\s{0,},")));
        // 처리 결과 메시지 값 검색 Regex Pattern
        resultMap.put("P_PATTERN_RESULT_MSG", Util.nullToDefault(mappingKeyValues.get("PATTERN_RESULT_MSG"), //
            NexosSupport.getGlobalProperty("EDI.WS.JSON.PATTERN_RESULT_MSG", "\\\"message\\\"\\s{0,}:\\s{0,}\\\"{0,}(.*?)\\\"{0,}\\s{0,}}")));

        return resultMap;
    }

    @Override
    public Map<String, Object> getXMLResultInfo(String xmlTagResult, String xmlTagResultMap) {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        resultMap.put("P_TAG_RESULT", xmlTagResult);
        // 매핑 키=값 파싱
        Map<String, Object> mappingKeyValues = Util.toKeyValues(xmlTagResultMap);
        // 결과 정보를 EDI Table Insert에 대해서만 처리할지 여부
        resultMap.put("P_RETURN_AFTER_DATA_INSERT", Util.nullToDefault(mappingKeyValues.get("RETURN_AFTER_DATA_INSERT"), //
            NexosSupport.getGlobalProperty("EDI.IFAPI.RETURN_AFTER_DATA_INSERT", Consts.YES)));
        // 정상코드 값, 0, S
        resultMap.put("P_RESULT_CD_SUCCESS", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_SUCCESS"), //
            NexosSupport.getGlobalProperty("EDI.WS.RESULT_CD.SUCCESS", Consts.EDI_RESULT_CD_SUCCESS)));
        // 오류코드 값, -1, F
        resultMap.put("P_RESULT_CD_ERROR", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_ERROR"), //
            NexosSupport.getGlobalProperty("EDI.WS.RESULT_CD.ERROR", Consts.EDI_RESULT_CD_ERROR)));
        // 코드 데이터 타입, STRING, NUMBER
        resultMap.put("P_RESULT_CD_DATA_TYPE", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_DATA_TYPE"), //
            NexosSupport.getGlobalProperty("EDI.WS.RESULT_CD.DATA_TYPE", "STRING")));
        // Response Message
        resultMap.put("P_RESULT_MESSAGE", Util.nullToDefault(mappingKeyValues.get("RESULT_MESSAGE"), //
            NexosSupport.getGlobalProperty("EDI.WS.XML.RESULT_MESSAGE", "<result>#RESULT_CD#</result><message>#RESULT_MSG#</message>")));
        // Response 결과 데이터 TAG
        resultMap.put("P_RETURN_BUNCH", Util.nullToDefault(mappingKeyValues.get("RETURN_BUNCH"), //
            NexosSupport.getGlobalProperty("EDI.WS.XML.RETURN_BUNCH", "")));
        // 처리 결과 코드 값 검색 Regex Pattern
        resultMap.put("P_PATTERN_RESULT_CD", Util.nullToDefault(mappingKeyValues.get("PATTERN_RESULT_CD"), //
            NexosSupport.getGlobalProperty("EDI.WS.XML.PATTERN_RESULT_CD", "<result>(.*?)</result>")));
        // 처리 결과 메시지 값 검색 Regex Pattern
        resultMap.put("P_PATTERN_RESULT_MSG", Util.nullToDefault(mappingKeyValues.get("PATTERN_RESULT_MSG"), //
            NexosSupport.getGlobalProperty("EDI.WS.XML.PATTERN_RESULT_MSG", "<message>(.*?)</message>")));

        return resultMap;
    }

    @Override
    public Map<String, Object> getSAPResultInfo(String sapResultMap) {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        // 매핑 키=값 파싱
        Map<String, Object> mappingKeyValues = Util.toKeyValues(sapResultMap);
        // 결과 정보를 EDI Table Insert에 대해서만 처리할지 여부
        resultMap.put("P_RETURN_AFTER_DATA_INSERT", Util.nullToDefault(mappingKeyValues.get("RETURN_AFTER_DATA_INSERT"), //
            NexosSupport.getGlobalProperty("EDI.SAP.RETURN_AFTER_DATA_INSERT", Consts.YES)));
        // 정상코드 값, S
        resultMap.put("P_RESULT_CD_SUCCESS", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_SUCCESS"), //
            NexosSupport.getGlobalProperty("EDI.SAP.RESULT_CD.SUCCESS", Consts.EDI_RESULT_CD_SUCCESS)));
        // 오류코드 값, E
        resultMap.put("P_RESULT_CD_ERROR", Util.nullToDefault(mappingKeyValues.get("RESULT_CD_ERROR"), //
            NexosSupport.getGlobalProperty("EDI.SAP.RESULT_CD.ERROR", "E")));
        // 처리 결과 코드 컬럼
        resultMap.put("P_COLUMN_RESULT_CD", Util.nullToDefault(mappingKeyValues.get("COLUMN_RESULT_CD"), //
            NexosSupport.getGlobalProperty("EDI.SAP.COLUMN_RESULT_CD", "E_TYPE")));
        // 처리 결과 메시지 컬럼
        resultMap.put("P_COLUMN_RESULT_MSG", Util.nullToDefault(mappingKeyValues.get("COLUMN_RESULT_MSG"), //
            NexosSupport.getGlobalProperty("EDI.SAP.COLUMN_RESULT_MSG", "E_MESSAGE")));

        return resultMap;
    }

    @Override
    public DynamicDataSource getDynamicDataSource(Map<String, Object> params) throws Exception {

        String remoteDiv = (String)params.get("P_REMOTE_DIV");
        String remoteDbNm = (String)params.get("P_LINK_DB_NM");
        String remoteIp = (String)params.get("P_REMOTE_IP");
        String remotePort = (String)params.get("P_REMOTE_PORT");
        String remoteUserId = (String)params.get("P_REMOTE_USER_ID");
        String remoteUserPwd = (String)params.get("P_REMOTE_USER_PWD");

        // 원격DB 접속
        String remoteDBType = null;
        if (Consts.REMOTE_DIV_SQLSERVER.equals(remoteDiv)) {
            remoteDBType = "mssql";
        } else if (Consts.REMOTE_DIV_MYSQL.equals(remoteDiv)) {
            remoteDBType = "mysql";
        } else if (Consts.REMOTE_DIV_ORACLE.equals(remoteDiv)) {
            remoteDBType = "oracle";
        } else {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.089", "원격수신구분 정보가 잘못 지정되었습니다."));
        }

        DynamicDataSource dbcDataSource = new DynamicDataSource(remoteDBType, remoteIp, remotePort, remoteDbNm, remoteUserId, remoteUserPwd);
        params.put("P_EDI_DATASOURCE", dbcDataSource);
        return dbcDataSource;
    }

    private String callGetSQLVal(String sqlText) {

        String result = "";
        Map<String, Object> callParams = new HashMap<String, Object>();
        callParams.put("P_SQL_TEXT", sqlText);
        callParams.put("P_APOSTROPHE_REPLACE_YN", Consts.NO);
        Map<String, Object> resultMap = getData(SP_ID_GET_SQL_VAL, callParams);
        String oMsg = Util.getOutMessage(resultMap);
        if (Consts.OK.equals(oMsg)) {
            result = (String)resultMap.get("O_SQL_VAL");
        }

        return result;
    }

    /**
     * SQL#[SQL_TEXT] 형식으로 된 문자열에서 SQL_TEXT만 파싱하여 SELECT 후 결과를 SQL#[SQL_TEXT]와 치환 처리
     *
     * @param originalText
     * @return
     */
    @Override
    public String replaceSQLText(String originalText) {

        String result = originalText;
        if (Util.isNull(result)) {
            return result;
        }
        Pattern pattern = Pattern.compile("SQL#\\[(.*?)\\]#");
        Matcher matcher = pattern.matcher(result);
        while (matcher.find()) {
            String repText = matcher.group(0);
            String sqlText = matcher.group(1);
            result = result.replace(repText, callGetSQLVal(sqlText));
            matcher = pattern.matcher(result);
        }
        return result;
    }

    @Override
    public Map<String, Object> getRecvNo(Map<String, Object> params) {

        return callProcedure(SP_ID_ER_RECV_GETNO, params);
    }

    @Override
    public Map<String, Object> getSendUpdateInfo(Map<String, Object> params) {

        return callProcedure(SP_ID_GET_SEND_UPDATE_INFO, params);
    }

    /**
     * 데이터베이스에 종류에 따라 컬럼 값 처리를 위한 SQL 문장 리턴
     *
     * @param dbType
     * @param sbLinkSQLText
     * @param linkColumnNm
     * @param dataType
     * @param linkColumnVal
     * @param userId
     * @param isSet
     * @return
     * @throws Exception
     */
    private void setRecvColumnSQLText(String dbType, StringBuffer sbLinkSQLText, String linkColumnNm, String dataType, String linkColumnVal,
        String userId, boolean isSet) throws Exception {

        // 결과 -> ,linkColumnNm
        // 결과 -> AND linkColumnNm
        sbLinkSQLText.append(isSet ? SC_SEP : SC_AND) //
            .append(linkColumnNm);

        // 지정값 처리
        // [NULL], [USER_ID], [SYSDATE], [...] ... 필요시 추가 코딩
        if (linkColumnVal.startsWith("[") && linkColumnVal.endsWith("]")) {
            if ("[NULL]".equals(linkColumnVal)) {
                if (isSet) {
                    // 결과 -> =NULL
                    sbLinkSQLText.append(SC_EQUAL) //
                        .append("NULL");
                } else {
                    // 결과 -> IS NULL
                    sbLinkSQLText.append(" IS NULL");
                }
            } else if ("[USER_ID]".equals(linkColumnVal)) {
                // 결과 -> ='userId'
                sbLinkSQLText.append(SC_EQUAL) //
                    .append(Util.toSingleQuoted(userId));
            } else if ("[SYSDATE]".equals(linkColumnVal)) {
                // 결과 -> function return 값
                setRecvDateColumnSQLText(sbLinkSQLText, dbType, null, false);
            } else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.090", "\n식별자 지정값 정의가 잘못 지정되었습니다."));
            }

            return;
        }
        // SQL문 처리
        // <SQL문>
        else if (linkColumnVal.startsWith("<") && linkColumnVal.endsWith(">")) {
            // 결과 <TO_CHAR(SYSDATE, 'YYYYMMDD')> -> = TO_CHAR(SYSDATE, 'YYYYMMDD')
            sbLinkSQLText.append(SC_EQUAL) //
                .append(linkColumnVal.substring(1, linkColumnVal.length() - 1));
            return;
        }

        // 문자
        if (DT_STRING.equals(dataType)) {
            // 결과 -> = 'linkColumnVal
            sbLinkSQLText.append(SC_EQUAL) //
                .append(Util.toSingleQuoted(linkColumnVal));
        }
        // 숫자
        else if (DT_NUMBER.equals(dataType)) {
            // 결과 -> = linkColumnVal
            sbLinkSQLText.append(SC_EQUAL) //
                .append(linkColumnVal);
        }
        // 날짜
        else if (DT_DATE.equals(dataType)) {
            // 결과 -> function return 값
            setRecvDateColumnSQLText(sbLinkSQLText, dbType, linkColumnVal, true);
        }
        // 기타
        else {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.091", "\n컬럼 데이터 타입 정의가 잘못 지정되었습니다."));
        }
    }

    private void setRecvDateColumnSQLText(StringBuffer sbLinkSQLText, String dbType, String linkColumnVal, boolean isConvert) throws Exception {

        // 변환일 경우
        if (isConvert) {
            // Oracle
            if (DB_ORACLE.equals(dbType)) {
                // 결과 -> =TO_DATE('linkColumnVal' ,'Consts.DBDATETIME_FORMAT')
                sbLinkSQLText.append(SC_EQUAL) //
                    .append("TO_DATE") //
                    .append(SC_O_BRACKET) //
                    .append(Util.toSingleQuoted(linkColumnVal)) //
                    .append(SC_SEP) //
                    .append(Util.toSingleQuoted(Consts.DBDATETIME_FORMAT)) //
                    .append(SC_C_BRACKET);
            }
            // SQLServer
            else if (DB_MSSQL.equals(dbType)) {
                // 결과 -> =CONVERT(DATETIME ,'linkColumnVal')
                sbLinkSQLText.append(SC_EQUAL) //
                    .append("CONVERT") //
                    .append(SC_O_BRACKET) //
                    .append("DATETIME") //
                    .append(SC_SEP) //
                    .append(Util.toSingleQuoted(linkColumnVal)) //
                    .append(SC_C_BRACKET);
            }
            // MySQL
            else if (DB_MYSQL.equals(dbType)) {
                // 결과 -> =STR_TO_DATE('linkColumnVal' ,'%Y-%m-%d %H:%i:%s')
                sbLinkSQLText.append(SC_EQUAL) //
                    .append("STR_TO_DATE") //
                    .append(SC_O_BRACKET) //
                    .append(Util.toSingleQuoted(linkColumnVal)) //
                    .append(SC_SEP) //
                    .append(Util.toSingleQuoted("%Y-%m-%d %H:%i:%s")) //
                    .append(SC_C_BRACKET);
            }
            // 기타
            else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.092", "\n지원하지 않는 데이터베이스입니다."));
            }
        }
        // 값 입력일 경우
        else {
            // Oracle
            if (DB_ORACLE.equals(dbType)) {
                // 결과 -> =SYSDATE
                sbLinkSQLText.append(SC_EQUAL) //
                    .append("SYSDATE");
            }
            // SQLServer
            else if (DB_MSSQL.equals(dbType)) {
                // 결과 -> =GETDATE()
                sbLinkSQLText.append(SC_EQUAL) //
                    .append("GETDATE()");
            }
            // MySQL
            else if (DB_MYSQL.equals(dbType)) {
                // 결과 -> =NOW()
                sbLinkSQLText.append(SC_EQUAL) //
                    .append("NOW()");
            }
            // 기타
            else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.092", "\n지원하지 않는 데이터베이스입니다."));
            }
        }
    }

    private String getSendDateColumnSQLText(String dbType, boolean isBindingDate) throws Exception {

        String resultSQLText = "";
        switch (dbType) {
            // Oracle
            case DB_ORACLE:
                if (isBindingDate) {
                    resultSQLText = "TO_DATE(? ,'YYYY-MM-DD HH24:MI:SS')";
                } else {
                    resultSQLText = "SYSDATE";
                }
                break;
            // SQLServer
            case DB_MSSQL:
                if (isBindingDate) {
                    resultSQLText = "CONVERT(DATETIME ,?)";
                } else {
                    resultSQLText = "GETDATE()";
                }
                break;
            // MySQL
            case DB_MYSQL:
                if (isBindingDate) {
                    resultSQLText = "STR_TO_DATE(? ,'%Y-%m-%d %H:%i:%s')";
                } else {
                    resultSQLText = "NOW()";
                }
                break;
            // 기타
            default:
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.092", "\n지원하지 않는 데이터베이스입니다."));
        }
        return resultSQLText;
    }

    private boolean setSendColumnSQLText(boolean isProcedureCall, StringBuffer sbESSQLText, StringBuffer sbInsertSQLValues,
        List<String> lstBindingParams, Integer bindingIndex, String dbType, String esColumnNm, String dataDefault, String dataType, String userId)
        throws Exception {

        boolean result = true; // BIND로 추가되는지 여부
        // 컬럼명에 지정값 처리는 삭제 됨, 2018-03-18
        // 사용자정의 컬럼 처리, <컬럼명>
        if (esColumnNm.startsWith("<") && esColumnNm.endsWith(">")) {
            // 기본값의 지정값 처리, [NULL], [...], [...] ... 필요시 추가 코딩
            // [NULL], Default -> null 처리
            if (Util.isNull(dataDefault) || "[NULL]".equals(dataDefault)) {
                sbESSQLText.append(SC_SEP).append("NULL");
                // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                if (!isProcedureCall) {
                    sbInsertSQLValues.append(SC_SEP).append("NULL");
                    result = false;
                }
            }
            // [USER_ID] -> 사용자ID 입력
            else if ("[USER_ID]".equals(dataDefault)) {
                sbESSQLText.append(SC_SEP).append(Util.toSingleQuoted(userId));
                // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                if (!isProcedureCall) {
                    sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                }
            }
            // [SYSDATE] -> SYSDATE 입력
            else if ("[SYSDATE]".equals(dataDefault)) {
                // PROCEDURE<CALL> 방식, 등록된 값 변경
                if (isProcedureCall) {
                    sbESSQLText.append(SC_SEP).append("SYSDATE");
                    lstBindingParams.set(bindingIndex.intValue() - 1, getSendDateColumnSQLText(dbType, true));
                }
                // TABLE<INSERT> 방식
                else {
                    sbESSQLText.append(SC_SEP).append("NULL");
                    sbInsertSQLValues.append(SC_SEP).append(getSendDateColumnSQLText(dbType, false));
                    result = false;
                }
            }
            // 쿼리문 추가, <쿼리문>
            else if (dataDefault.startsWith("<") && dataDefault.endsWith(">")) {
                dataDefault = dataDefault.substring(1, dataDefault.length() - 1);
                sbESSQLText.append(SC_SEP).append(dataDefault);
                if (DT_DATE.equals(dataType)) {
                    // PROCEDURE<CALL> 방식, 등록된 값 변경
                    if (isProcedureCall) {
                        lstBindingParams.set(bindingIndex.intValue() - 1, getSendDateColumnSQLText(dbType, true));
                    }
                    // TABLE<INSERT> 방식
                    else {
                        sbInsertSQLValues.append(SC_SEP).append(getSendDateColumnSQLText(dbType, true));
                    }
                } else {
                    // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                    if (!isProcedureCall) {
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                }
            }
            // 상수값, 쿼리 실행 처리
            else {
                String sqlVal;
                // 쿼리 실행 처리, [쿼리문]
                if (dataDefault.startsWith("[") && dataDefault.endsWith("]")) {
                    // [] 제거
                    dataDefault = dataDefault.substring(1, dataDefault.length() - 1);
                    // 쿼리 실행해서 결과 가져오기
                    sqlVal = callGetSQLVal(dataDefault);
                } else {
                    // 기본값이 문자열로 입력되어 있으면 [''] 제거
                    if (dataDefault.startsWith("'") && dataDefault.endsWith("'")) {
                        dataDefault = dataDefault.substring(1, dataDefault.length() - 1);
                    }
                    sqlVal = dataDefault;
                }
                // 쿼리 실행 결과 NULL -> NULL 입력
                if (Util.isNull(sqlVal)) {
                    sbESSQLText.append(SC_SEP).append("NULL");
                    // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                    if (!isProcedureCall) {
                        sbInsertSQLValues.append(SC_SEP).append("NULL");
                        result = false;
                    }
                }
                // 값이 있을 경우
                else {
                    // 기타 지정값은 처리 후 데이터타입에 따라 재처리
                    switch (dataType) {
                        // 문자
                        case DT_STRING:
                            sbESSQLText.append(SC_SEP).append(Util.toSingleQuoted(sqlVal));
                            // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                            if (!isProcedureCall) {
                                sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                            }
                            break;
                        // 숫자
                        case DT_NUMBER:
                            sbESSQLText.append(SC_SEP).append(sqlVal);
                            // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                            if (!isProcedureCall) {
                                sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                            }
                            break;
                        // 날짜
                        case DT_DATE:
                            sbESSQLText.append(SC_SEP).append(Util.toSingleQuoted(sqlVal));
                            // PROCEDURE<CALL> 방식, 등록된 값 변경
                            if (isProcedureCall) {
                                lstBindingParams.set(bindingIndex.intValue() - 1, getSendDateColumnSQLText(dbType, true));
                            }
                            // TABLE<INSERT> 방식
                            else {
                                sbInsertSQLValues.append(SC_SEP).append(getSendDateColumnSQLText(dbType, true));
                            }
                            break;
                        default:
                            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.091", "\n컬럼 데이터 타입 정의가 잘못 지정되었습니다."));
                    }
                }
            }
        }
        // 일반 컬럼 처리
        else {
            switch (dataType) {
                // 문자
                case DT_STRING:
                    sbESSQLText.append(SC_SEP).append(esColumnNm);
                    // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                    if (!isProcedureCall) {
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                    break;
                // 숫자
                case DT_NUMBER:
                    sbESSQLText.append(SC_SEP).append(esColumnNm);
                    // TABLE<INSERT> 방식만, PROCEDURE<CALL>은 lstBindingParams이 등록 되어 있음
                    if (!isProcedureCall) {
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                    break;
                // 날짜
                case DT_DATE:
                    sbESSQLText.append(SC_SEP).append(esColumnNm);
                    // PROCEDURE<CALL> 방식, 등록된 값 변경
                    if (isProcedureCall) {
                        lstBindingParams.set(bindingIndex.intValue() - 1, getSendDateColumnSQLText(dbType, true));
                    }
                    // TABLE<INSERT> 방식
                    else {
                        sbInsertSQLValues.append(SC_SEP).append(getSendDateColumnSQLText(dbType, true));
                    }
                    break;
                default:
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.091", "\n컬럼 데이터 타입 정의가 잘못 지정되었습니다."));
            }
        }
        sbESSQLText.append(SC_AS).append(Util.toQuoted(esColumnNm));

        return result;
    }

    /**
     * 송신 파일명 리턴
     * <pre>
     * 기본 규칙     : (파일명접두사_)사용자ID_송신일시(yyyyMMddHHmmss)_사업부_송신구분_송신정의번호_송신일자_송신번호_DOC.자료구분(확장자)
     *                      RND_20230601120000_0010_SLO10_0010_20230601_000001_DOC.txt
     *                 SEND_RND_20230601120000_0010_SLO10_0010_20230601_000001_DOC.txt
     * 사용자 재정의 : 파일명접두사를 <> 묶어서 지정, 아래 값을 변경하여 지정, 확장자는 자료구분으로 자동지정(.자료구분에 따른 확장자)
     *                 [USER_ID]   사용자ID
     *                 [SYSDATE]   송신일시
     *                 [BU_CD]     사업부
     *                 [EDI_DIV]   송신구분
     *                 [DEFINE_NO] 송신정의번호
     *                 [SEND_DATE] 송신일자
     *                 [SEND_NO]   송신번호
     * </pre>
     *
     * @param prefixFileNm
     * @param userId
     * @param ediSendDatetime
     * @param buCd
     * @param ediDiv
     * @param defineNo
     * @param sendDate
     * @param sendNo
     * @param fileExt
     * @return
     */
    private String getSendFileName(String prefixFileNm, String userId, String ediSendDatetime, String buCd, String ediDiv, String defineNo,
        String sendDate, String sendNo, String fileExt) {

        String result = "";
        // 송신 파일명 사용자 재정의일 경우
        if (Util.isNotNull(prefixFileNm) && prefixFileNm.startsWith("<") && prefixFileNm.endsWith(">")) {
            result = prefixFileNm.substring(1, prefixFileNm.length() - 1);
            // 변경 처리
            result = Util.replaceRestrictChars(result //
                .replace("[USER_ID]", userId) //
                .replace("[SYSDATE]", ediSendDatetime) //
                .replace("[BU_CD]", buCd) //
                .replace("[EDI_DIV]", ediDiv) //
                .replace("[DEFINE_NO]", defineNo) //
                .replace("[SEND_DATE]", sendDate.replace("-", "")) //
                .replace("[SEND_NO]", sendNo) //
                + "." + fileExt);
        }
        // 송신 파일명, 기본 규칙
        else {
            result = Util.replaceRestrictChars(Util.toJoin("_", //
                new String[] { //
                    Util.isNull(prefixFileNm) ? userId : prefixFileNm + "_" + userId, //
                    ediSendDatetime, //
                    buCd, ediDiv, defineNo, //
                    sendDate.replace("-", ""), sendNo, //
                    "DOC." + fileExt //
                }));
        }

        return result;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Map<String, Object> recvDBConnect(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        PreparedStatement insertStatement = null;
        CallableStatement callStatement = null;
        ResultSet rsDbcRecvData = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            // 수신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 수신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.093", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 내역이 등록되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);

            // 나머지 파라메터 값 읽기
            String recvDate = (String)params.get("P_RECV_DATE");
            String userId = (String)params.get(Consts.PK_USER_ID);
            final String erTableNm = (String)defineInfo.get("TABLE_NM");
            // final String INSERT_ID = "EDCOMMON.INSERT_" + TABLE_NM;
            String dbcTableNm = (String)defineInfo.get("LINK_TABLE_NM");
            String dbcWhereText = (String)defineInfo.get("LINK_WHERE_TEXT");
            String dbcOrderByText = (String)defineInfo.get("LINK_ORDERBY_TEXT");
            String remoteActionType = Util.nullToEmpty(params.get("P_REMOTE_ACTION_TYPE"));
            String remoteParamMap = (String)params.get("P_REMOTE_PARAM_MAP");
            boolean isProcedureCall = "3".equals(remoteActionType);

            DynamicDataSource dbcDatasource = (DynamicDataSource)params.get("P_EDI_DATASOURCE");
            String dbcType = dbcDatasource.getDBType();

            String columnNm = null;
            String linkColumnNm = null;
            String dataType = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            // BATCH 처리를 위한 INSERT SQL 생성
            StringBuffer sbInsertSQLColumns = new StringBuffer();
            StringBuffer sbInsertSQLValues = new StringBuffer();
            sbInsertSQLColumns.append("BU_CD ,EDI_DIV ,DEFINE_NO ,RECV_DATE ,RECV_NO ,RECV_SEQ ,ERROR_DIV ,DATA_DIV ,RECV_USER_ID ,RECV_DATETIME");
            sbInsertSQLValues.append("? ,? ,? ,? ,? ,? ,? ,? ,? ,NVL(? ,SYSDATE)");

            // PROCEDURE<CALL> 방식
            Map<String, Object> remoteParamMaps = null;
            Map<String, Integer> linkParamOrders = null;
            Map<String, Object> linkBindingParams = null;
            if (isProcedureCall) {
                List<String> lstBindingParams = new ArrayList<String>();
                remoteParamMaps = getRemoteParamMaps("1", dbcType, remoteParamMap, lstBindingParams, userId);
                String oMsg = Util.getOutMessage(remoteParamMaps);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.094", "[사업부,수신구분,수신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n" + oMsg, new String[] {buCd, ediDiv, defineNo, oMsg}));
                }

                for (int i = 0; i < columnCnt; i++) {
                    defineInfo = lstDefineInfo.get(i);

                    try {
                        columnNm = (String)defineInfo.get("COLUMN_NM");
                        dataType = (String)defineInfo.get("DATA_TYPE");
                        linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");

                        if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm) && Util.isNotNull(dataType)) {
                            vtColumn = new Vector<Object>();
                            vtColumn.add("P_" + columnNm);
                            vtColumn.add(linkColumnNm);
                            columns.add(vtColumn);

                            // BATCH 처리를 위한 INSERT SQL 생성
                            sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                            sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                        }
                    } catch (Exception e) {
                    }
                }
                columnCnt = columns.size();
                if (columnCnt == 0) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
                }

                // PROCEDURE<CALL>을 위한 최종 SQL 생성
                sbBuffer.setLength(0);
                // ORACLE일 경우 FUNCTION RETURN CURSOR를 처리
                if (DB_ORACLE.equals(dbcType)) {
                    sbBuffer.append("{ ? = call ").append(dbcTableNm);
                }
                // 그외, SQLServer, MySQL은 PROCEDURE<CALL> 후 마지막 SELECT를 처리
                else {
                    sbBuffer.append("{ call ").append(dbcTableNm);
                }

                sbBuffer.append(" ( ") //
                    .append(StringUtils.join(lstBindingParams.toArray(), SC_SEP)) //
                    .append(" )") //
                    .append(" }");

                String callProcedureSql = sbBuffer.toString();

                // BATCH 처리를 위한 최종 INSERT SQL 생성
                sbBuffer.setLength(0);
                sbBuffer //
                    .append("INSERT INTO ").append(erTableNm) //
                    .append(" ( ") //
                    .append(sbInsertSQLColumns) //
                    .append(" ) ") //
                    .append("VALUES ( ") //
                    .append(sbInsertSQLValues) //
                    .append(" )");

                String insertSql = sbBuffer.toString();

                linkParamOrders = (Map<String, Integer>)remoteParamMaps.get("P_LINK_PARAM_ORDERS");
                linkBindingParams = (Map<String, Object>)remoteParamMaps.get("P_LINK_BINDING_PARAMS");

                // PROCEDURE<CALL>하여 데이터 조회
                callStatement = dbcDatasource.prepareCall(callProcedureSql);

                // ORACLE일 경우 FUNCTION RETURN CURSOR를 처리를 위해 첫번째 Index를 OUTPUT로 등록
                if (DB_ORACLE.equals(dbcType)) {
                    callStatement.registerOutParameter(1, oracle.jdbc.OracleTypes.CURSOR);
                }
                // 파라메터 세팅
                for (Map.Entry<String, Object> bindingParam : linkBindingParams.entrySet()) {
                    Integer pIndex = linkParamOrders.get(bindingParam.getKey());
                    if (pIndex != null) {
                        callStatement.setObject(pIndex.intValue(), bindingParam.getValue());
                    }
                }
                // 데이터 조회
                // ORACLE일 경우 FUNCTION RETURN CURSOR를 처리를 위해 첫번째 Index를 OUTPUT로 등록
                if (DB_ORACLE.equals(dbcType)) {
                    callStatement.execute();
                    rsDbcRecvData = (ResultSet)callStatement.getObject(1);
                } else {
                    rsDbcRecvData = callStatement.executeQuery();
                }

                // ResultSet MetaData에서 컬럼명 정보 읽기
                ResultSetMetaData rmDbcRecvData = rsDbcRecvData.getMetaData();
                Map<String, Integer> columnInfo = new HashMap<String, Integer>();
                for (int cIndex = 1, cCount = rmDbcRecvData.getColumnCount(); cIndex <= cCount; cIndex++) {
                    columnInfo.put(JdbcUtils.lookupColumnName(rmDbcRecvData, cIndex), Integer.valueOf(cIndex));
                }
                boolean hasNextRecvData = rsDbcRecvData.next();
                if (rsDbcRecvData == null || !hasNextRecvData) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.096", "[사업부,수신구분,수신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n수신처리할 대상 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
                }

                // 수신번호 채번
                Map<String, Object> recvNoMap = getRecvNo(params);

                oMsg = Util.getOutMessage(recvNoMap);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(oMsg);
                }
                String recvNo = (String)recvNoMap.get("O_RECV_NO");
                params.put("P_RECV_NO", recvNo);

                // resultMap 세팅
                resultMap.put("P_BU_CD", buCd);
                resultMap.put("P_EDI_DIV", ediDiv);
                resultMap.put("P_DEFINE_NO", defineNo);
                resultMap.put("P_RECV_DATE", recvDate);
                resultMap.put("P_RECV_NO", recvNo);

                // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
                insertStatement = getConnection().prepareStatement(insertSql);
                int recvSeq = 0;
                Integer linkColumnIndex;
                while (hasNextRecvData) {
                    for (int i = 0; i < columnCnt; i++) {
                        vtColumn = columns.get(i);

                        columnNm = (String)vtColumn.get(0);
                        linkColumnNm = (String)vtColumn.get(1);

                        // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        // insertStatement.setString(11 + i, (String)recvRow.get(linkColumnNm));
                        linkColumnIndex = columnInfo.get(linkColumnNm);
                        if (linkColumnIndex != null) {
                            insertStatement.setObject(11 + i, rsDbcRecvData.getObject(linkColumnIndex.intValue()));
                        } else {
                            insertStatement.setObject(11 + i, null);
                        }
                    }

                    recvSeq++;
                    insertStatement.setString(1, buCd);
                    insertStatement.setString(2, ediDiv);
                    insertStatement.setString(3, defineNo);
                    insertStatement.setString(4, recvDate);
                    insertStatement.setString(5, recvNo);
                    insertStatement.setInt(6, recvSeq);
                    insertStatement.setString(7, "0");
                    insertStatement.setString(8, Consts.DATA_DIV_DBCONNECT);
                    insertStatement.setString(9, userId);
                    insertStatement.setNull(10, Types.TIMESTAMP);
                    // BATCH에 추가
                    insertStatement.addBatch();
                    // 파라메터 초기화
                    insertStatement.clearParameters();
                    // 1000건씩 처리
                    if (recvSeq % Consts.BULK_CNT == 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    hasNextRecvData = rsDbcRecvData.next();
                }

                // 나머지 데이터가 있을 경우 처리
                if (recvSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", recvSeq);
            }
            // TABLE<SELECT> 방식
            else {
                // 수신조회조건정의내역 데이터 쿼리
                List<Map<String, Object>> lstIdentifierInfo = getIdentifierInfo(params);
                boolean identifierYn = true;
                if (lstIdentifierInfo == null || lstIdentifierInfo.size() == 0) {
                    // 조건이 없을 경우 전체 데이터 수신
                    identifierYn = false;
                }

                // 수신플래그가 있을 경우
                if (identifierYn) {
                    StringBuffer sbLink1stUpdateSetList = new StringBuffer();
                    StringBuffer sbLink1stWhereList = new StringBuffer();
                    String link1stUpdateText = null;

                    StringBuffer sbLink2ndSelectList = new StringBuffer();
                    String link2ndSelectText = null;

                    StringBuffer sbLink2nd3rdWhereList = new StringBuffer();
                    StringBuffer sbLink3rdUpdateSetList = new StringBuffer();
                    String link3rdUpdateText = null;

                    for (int i = 0; i < columnCnt; i++) {
                        defineInfo = lstDefineInfo.get(i);

                        try {
                            columnNm = (String)defineInfo.get("COLUMN_NM");
                            dataType = (String)defineInfo.get("DATA_TYPE");
                            linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");

                            if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm) && Util.isNotNull(dataType)) {
                                vtColumn = new Vector<Object>();
                                vtColumn.add("P_" + columnNm);
                                vtColumn.add(linkColumnNm);
                                columns.add(vtColumn);

                                // Oracle
                                if (DB_ORACLE.equals(dbcType)) {
                                    // 문자
                                    if (DT_STRING.equals(dataType)) {
                                        // 결과 -> ,linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append(linkColumnNm);
                                    }
                                    // 숫자
                                    else if (DT_NUMBER.equals(dataType)) {
                                        // 결과 -> ,TO_CHAR(linkColumnNm) AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append("TO_CHAR") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 날짜
                                    else if (DT_DATE.equals(dataType)) {
                                        // 결과 -> ,TO_CHAR(linkColumnNm ,'Consts.DBDATETIME_FORMAT') AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append("TO_CHAR") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_SEP) //
                                            .append(Util.toSingleQuoted(Consts.DBDATETIME_FORMAT)) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 기타
                                    else {
                                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097", "[사업부,수신구분,수신정의번호,컬럼명: " //
                                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                                            + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                                    }
                                }
                                // SQLServer
                                else if (DB_MSSQL.equals(dbcType)) {
                                    // 문자
                                    if (DT_STRING.equals(dataType)) {
                                        // 결과 -> ,RTRIM(linkColumnNm) AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append("RTRIM") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 숫자
                                    else if (DT_NUMBER.equals(dataType)) {
                                        // 결과 -> ,CONVERT(VARCHAR(255) ,linkColumnNm) AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append("CONVERT(VARCHAR(255)") //
                                            .append(SC_SEP) //
                                            .append(linkColumnNm) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 날짜
                                    else if (DT_DATE.equals(dataType)) {
                                        // 결과 -> ,CONVERT(VARCHAR(255) ,linkColumnNm ,120) AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append("CONVERT(VARCHAR(255)") //
                                            .append(SC_SEP) //
                                            .append(linkColumnNm) //
                                            .append(SC_SEP) //
                                            .append(120) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 기타
                                    else {
                                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097", "[사업부,수신구분,수신정의번호,컬럼명: " //
                                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                                            + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                                    }
                                }
                                // mysql
                                else if (DB_MYSQL.equals(dbcType)) {
                                    // 문자
                                    if (DT_STRING.equals(dataType)) {
                                        // 결과 -> ,linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append(linkColumnNm);
                                    }
                                    // 숫자
                                    else if (DT_NUMBER.equals(dataType)) {
                                        // 결과 -> ,CAST(linkColumnNm AS CHAR) AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP) //
                                            .append("CAST") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_AS) //
                                            .append("CHAR") //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 날짜
                                    else if (DT_DATE.equals(dataType)) {
                                        // 결과 -> ,DATE_FORMAT(linkColumnNm ,'%Y-%m-%d %H:%i:%s') AS linkColumnNm
                                        sbLink2ndSelectList.append(SC_SEP).append("DATE_FORMAT") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_SEP) //
                                            .append("'%Y-%m-%d %H:%i:%s'") //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 기타
                                    else {
                                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097", "[사업부,수신구분,수신정의번호,컬럼명: " //
                                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                                            + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                                    }
                                }
                                // 기타
                                else {
                                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.098", "[사업부,수신구분,수신정의번호: " //
                                        + buCd + "," + ediDiv + "," + defineNo //
                                        + "]\n지원하지 않는 데이터베이스입니다.", new String[] {buCd, ediDiv, defineNo}));
                                }

                                // BATCH 처리를 위한 INSERT SQL 생성
                                sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                                sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                            }
                        } catch (Exception e) {
                        }
                    }
                    columnCnt = columns.size();
                    if (columnCnt == 0) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                            + buCd + "," + ediDiv + "," + defineNo //
                            + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
                    }

                    // BATCH 처리를 위한 최종 INSERT SQL 생성
                    sbBuffer.setLength(0);
                    sbBuffer //
                        .append("INSERT INTO ").append(erTableNm) //
                        .append(" ( ") //
                        .append(sbInsertSQLColumns) //
                        .append(" ) ") //
                        .append("VALUES ( ") //
                        .append(sbInsertSQLValues) //
                        .append(" )");

                    String insertSql = sbBuffer.toString();

                    Map<String, Object> identifier = null;
                    int identifierCnt = lstIdentifierInfo.size();
                    for (int i = 0; i < identifierCnt; i++) {
                        identifier = lstIdentifierInfo.get(i);

                        try {
                            linkColumnNm = (String)identifier.get("LINK_COLUMN_NM");
                            dataType = (String)identifier.get("LINK_DATA_TYPE");

                            if (Util.isNotNull(linkColumnNm)) {
                                // 초기값 - 조회 조건
                                columnVal = (String)identifier.get("COLUMN_VAL1");
                                if (Util.isNotNull(columnVal)) {
                                    setRecvColumnSQLText(dbcType, sbLink1stWhereList, linkColumnNm, dataType, columnVal, userId, false);
                                }
                                // 수신 1차결과 값
                                columnVal = (String)identifier.get("COLUMN_VAL2");
                                if (Util.isNotNull(columnVal)) {
                                    setRecvColumnSQLText(dbcType, sbLink1stUpdateSetList, linkColumnNm, dataType, columnVal, userId, true);
                                    setRecvColumnSQLText(dbcType, sbLink2nd3rdWhereList, linkColumnNm, dataType, columnVal, userId, false);
                                }
                                // 수신 최종결과 결과 값
                                columnVal = (String)identifier.get("COLUMN_VAL3");
                                if (Util.isNotNull(columnVal)) {
                                    setRecvColumnSQLText(dbcType, sbLink3rdUpdateSetList, linkColumnNm, dataType, columnVal, userId, true);
                                }
                            }
                        } catch (Exception e) {
                            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.099", "[사업부,수신구분,수신정의번호: " //
                                + buCd + "," + ediDiv + "," + defineNo + "]" //
                                + Util.getErrorMessage(e), new String[] {buCd, ediDiv, defineNo, Util.getErrorMessage(e)}));
                        }
                    }
                    // 추가조건 처리
                    if (dbcWhereText != null && Util.isNotNull(dbcWhereText.trim())) {
                        sbLink1stWhereList.append(SC_AND).append(dbcWhereText);
                        sbLink2nd3rdWhereList.append(SC_AND).append(dbcWhereText);
                    }

                    // LIST절 구분자 잘라내기
                    sbLink2ndSelectList.delete(0, SC_SEP.length());
                    sbLink1stUpdateSetList.delete(0, SC_SEP.length());
                    sbLink1stWhereList.delete(0, SC_AND.length());
                    sbLink3rdUpdateSetList.delete(0, SC_SEP.length());
                    sbLink2nd3rdWhereList.delete(0, SC_AND.length());

                    // SQL문 적용
                    sbBuffer.setLength(0);
                    sbBuffer //
                        .append("UPDATE ").append(dbcTableNm) //
                        .append("   SET ").append(sbLink1stUpdateSetList) //
                        .append(" WHERE ").append(sbLink1stWhereList);

                    link1stUpdateText = sbBuffer.toString();

                    sbBuffer.setLength(0);
                    sbBuffer //
                        .append("SELECT ").append(sbLink2ndSelectList) //
                        .append("  FROM ").append(dbcTableNm) //
                        .append(" WHERE ").append(sbLink2nd3rdWhereList);

                    link2ndSelectText = sbBuffer.toString();

                    sbBuffer.setLength(0);
                    sbBuffer //
                        .append("UPDATE ").append(dbcTableNm) //
                        .append("   SET ").append(sbLink3rdUpdateSetList) //
                        .append(" WHERE ").append(sbLink2nd3rdWhereList);

                    link3rdUpdateText = sbBuffer.toString();

                    // 1차 수신 대상 UPDATE
                    dbcDatasource.update(link1stUpdateText);

                    // 2차 수신 대상 SELECT
                    List<Map<String, Object>> lstDbcRecvData = dbcDatasource.getDataList(link2ndSelectText);
                    if (lstDbcRecvData == null || lstDbcRecvData.size() == 0) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.096", "[사업부,수신구분,수신정의번호: " //
                            + buCd + "," + ediDiv + "," + defineNo //
                            + "]\n수신처리할 대상 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
                    }

                    // 수신번호 채번
                    Map<String, Object> recvNoMap = getRecvNo(params);

                    String oMsg = Util.getOutMessage(recvNoMap);
                    if (!Consts.OK.equals(oMsg)) {
                        throw new RuntimeException(oMsg);
                    }
                    String recvNo = (String)recvNoMap.get("O_RECV_NO");
                    params.put("P_RECV_NO", recvNo);

                    // resultMap 세팅
                    resultMap.put("P_BU_CD", buCd);
                    resultMap.put("P_EDI_DIV", ediDiv);
                    resultMap.put("P_DEFINE_NO", defineNo);
                    resultMap.put("P_RECV_DATE", recvDate);
                    resultMap.put("P_RECV_NO", recvNo);

                    // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
                    insertStatement = getConnection().prepareStatement(insertSql);
                    int recvSeq = 0;
                    int recvDataCnt = lstDbcRecvData.size();
                    Map<String, Object> recvRow = null;
                    for (int row = 0; row < recvDataCnt; row++) {
                        recvRow = lstDbcRecvData.get(row);

                        for (int i = 0; i < columnCnt; i++) {
                            vtColumn = columns.get(i);

                            columnNm = (String)vtColumn.get(0);
                            linkColumnNm = (String)vtColumn.get(1);

                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            // insertStatement.setString(11 + i, (String)recvRow.get(linkColumnNm));
                            insertStatement.setObject(11 + i, recvRow.get(linkColumnNm));
                        }

                        recvSeq = row + 1;
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_DBCONNECT);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }
                    }
                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);

                    // 3차 수신 대상 결과 UPDATE
                    dbcDatasource.update(link3rdUpdateText);
                }
                // 수신플래그가 없을 경우
                else {
                    StringBuffer sbLink1stSelectList = new StringBuffer();
                    String link1stSelectText = null;
                    for (int i = 0; i < columnCnt; i++) {
                        defineInfo = lstDefineInfo.get(i);

                        try {
                            columnNm = (String)defineInfo.get("COLUMN_NM");
                            dataType = (String)defineInfo.get("DATA_TYPE");
                            linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");

                            if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm) && Util.isNotNull(dataType)) {
                                vtColumn = new Vector<Object>();
                                vtColumn.add("P_" + columnNm);
                                vtColumn.add(linkColumnNm);
                                columns.add(vtColumn);

                                // Oracle
                                if (DB_ORACLE.equals(dbcType)) {
                                    // 문자
                                    if (DT_STRING.equals(dataType)) {
                                        // 결과 -> ,linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append(linkColumnNm);
                                    }
                                    // 숫자
                                    else if (DT_NUMBER.equals(dataType)) {
                                        // 결과 -> ,TO_CHAR(linkColumnNm) AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("TO_CHAR") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 날짜
                                    else if (DT_DATE.equals(dataType)) {
                                        // 결과 -> ,TO_CHAR(linkColumnNm, 'Consts.DBDATETIME_FORMAT') AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("TO_CHAR") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_SEP) //
                                            .append(Util.toSingleQuoted(Consts.DBDATETIME_FORMAT)) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 기타
                                    else {
                                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097", "[사업부,수신구분,수신정의번호,컬럼명: " //
                                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                                            + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                                    }
                                }
                                // SQLServer
                                else if (DB_MSSQL.equals(dbcType)) {
                                    // 문자
                                    if (DT_STRING.equals(dataType)) {
                                        // 결과 -> ,RTRIM(linkColumnNm) AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("RTRIM") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 숫자
                                    else if (DT_NUMBER.equals(dataType)) {
                                        // 결과 -> ,CONVERT(VARCHAR(255) ,linkColumnNm) AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("CONVERT(VARCHAR(255)") //
                                            .append(SC_SEP) //
                                            .append(linkColumnNm) //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 날짜
                                    else if (DT_DATE.equals(dataType)) {
                                        // 결과 -> ,CONVERT(VARCHAR(255) ,linkColumnNm ,120) AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("CONVERT(VARCHAR(255)") //
                                            .append(SC_SEP) //
                                            .append(linkColumnNm) //
                                            .append(SC_SEP) //
                                            .append(120) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 기타
                                    else {
                                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097", "[사업부,수신구분,수신정의번호,컬럼명: " //
                                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                                            + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                                    }
                                }
                                // mysql
                                else if (DB_MYSQL.equals(dbcType)) {
                                    // 문자
                                    if (DT_STRING.equals(dataType)) {
                                        // 결과 -> ,linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append(linkColumnNm);
                                    }
                                    // 숫자
                                    else if (DT_NUMBER.equals(dataType)) {
                                        // 결과 -> ,CAST(linkColumnNm AS CHAR) AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("CAST") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_AS) //
                                            .append("CHAR") //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 날짜
                                    else if (DT_DATE.equals(dataType)) {
                                        // 결과 -> ,DATE_FORMAT(linkColumnNm ,'%Y-%m-%d %H:%i:%s') AS linkColumnNm
                                        sbLink1stSelectList.append(SC_SEP) //
                                            .append("DATE_FORMAT") //
                                            .append(SC_O_BRACKET) //
                                            .append(linkColumnNm) //
                                            .append(SC_SEP) //
                                            .append("'%Y-%m-%d %H:%i:%s'") //
                                            .append(SC_C_BRACKET) //
                                            .append(SC_AS) //
                                            .append(linkColumnNm);
                                    }
                                    // 기타
                                    else {
                                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097", "[사업부,수신구분,수신정의번호,컬럼명: " //
                                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                                            + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                                    }
                                } else {
                                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.098", "[사업부,수신구분,수신정의번호: " //
                                        + buCd + "," + ediDiv + "," + defineNo //
                                        + "]\n지원하지 않는 데이터베이스입니다.", new String[] {buCd, ediDiv, defineNo}));
                                }

                                // BATCH 처리를 위한 INSERT SQL 생성
                                sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                                sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                            }
                        } catch (Exception e) {
                        }
                    }
                    columnCnt = columns.size();
                    if (columnCnt == 0) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                            + buCd + "," + ediDiv + "," + defineNo //
                            + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
                    }

                    // BATCH 처리를 위한 최종 INSERT SQL 생성
                    sbBuffer.setLength(0);
                    sbBuffer //
                        .append("INSERT INTO ").append(erTableNm) //
                        .append(" ( ") //
                        .append(sbInsertSQLColumns) //
                        .append(" ) ") //
                        .append("VALUES ( ") //
                        .append(sbInsertSQLValues) //
                        .append(" )");

                    String insertSql = sbBuffer.toString();

                    // LIST절 구분자 잘라내기
                    sbLink1stSelectList.delete(0, SC_SEP.length());

                    // SQL문 적용
                    sbBuffer.setLength(0);
                    sbBuffer //
                        .append("SELECT ").append(sbLink1stSelectList) //
                        .append("  FROM ").append(dbcTableNm);
                    // 추가조건 처리
                    if (dbcWhereText != null && Util.isNotNull(dbcWhereText.trim())) {
                        sbBuffer.append(" WHERE ").append(dbcWhereText);
                    }
                    // 정렬 처리
                    if (dbcOrderByText != null && Util.isNotNull(dbcOrderByText.trim())) {
                        sbBuffer.append(" ORDER BY ").append(dbcOrderByText);
                    }

                    link1stSelectText = sbBuffer.toString();

                    // 1차 수신 대상 SELECT
                    List<Map<String, Object>> lstDbcRecvData = dbcDatasource.getDataList(link1stSelectText);
                    if (lstDbcRecvData == null || lstDbcRecvData.size() == 0) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.096", "[사업부,수신구분,수신정의번호: " //
                            + buCd + "," + ediDiv + "," + defineNo //
                            + "]\n수신처리할 대상 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
                    }

                    // 수신번호 채번
                    Map<String, Object> recvNoMap = getRecvNo(params);

                    String oMsg = Util.getOutMessage(recvNoMap);
                    if (!Consts.OK.equals(oMsg)) {
                        throw new RuntimeException(oMsg);
                    }
                    String recvNo = (String)recvNoMap.get("O_RECV_NO");
                    params.put("P_RECV_NO", recvNo);

                    // resultMap 세팅
                    resultMap.put("P_BU_CD", buCd);
                    resultMap.put("P_EDI_DIV", ediDiv);
                    resultMap.put("P_DEFINE_NO", defineNo);
                    resultMap.put("P_RECV_DATE", recvDate);
                    resultMap.put("P_RECV_NO", recvNo);

                    // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
                    insertStatement = getConnection().prepareStatement(insertSql);
                    int recvSeq = 0;
                    int recvDataCnt = lstDbcRecvData.size();
                    Map<String, Object> recvRow = null;
                    for (int row = 0; row < recvDataCnt; row++) {
                        recvRow = lstDbcRecvData.get(row);

                        for (int i = 0; i < columnCnt; i++) {
                            vtColumn = columns.get(i);

                            columnNm = (String)vtColumn.get(0);
                            linkColumnNm = (String)vtColumn.get(1);

                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            // insertStatement.setString(11 + i, (String)recvRow.get(linkColumnNm));
                            insertStatement.setObject(11 + i, recvRow.get(linkColumnNm));
                        }

                        recvSeq = row + 1;
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_DBCONNECT);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }
                    }
                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
            }

            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
            if (rsDbcRecvData != null) {
                try {
                    rsDbcRecvData.close();
                } catch (Exception e) {
                }
            }
            if (callStatement != null) {
                try {
                    callStatement.close();
                } catch (Exception e) {
                }
            }
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> recvDBLink(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = callERProcessingResult(params);
        String oMsg = Util.getOutMessage(resultMap);
        if (Consts.OK.equals(oMsg)) {
            resultMap.put("P_RECV_DATE", resultMap.get("O_RECV_DATE"));
            resultMap.put("P_RECV_NO", resultMap.get("O_RECV_NO"));
            Util.setOutMessage(params, Consts.OK);
        } else {
            Util.setOutMessage(params, oMsg);
        }

        return resultMap;
    }

    @Override
    public Map<String, Object> recvExcel(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        // 수신정의 상세내역 쿼리 파라메터 값 읽기

        // upload dir로 edi 파일 수신
        String ediRecvFileBackupFullName = null;
        File ediRecvFile = null;
        FileInputStream xlsFileInput = null;

        Workbook xlsWorkbook = null;
        Sheet xlsSheet = null;
        Row xlsRow = null;

        PreparedStatement insertStatement = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 수신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.093", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 내역이 등록되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            final String TABLE_NM = (String)defineInfo.get("TABLE_NM");
            // final String INSERT_ID = "EDCOMMON.INSERT_" + TABLE_NM;
            Object objXlsFirstRow = defineInfo.get("XLS_FIRST_ROW");
            int xlsFirstRow = 0;
            if (objXlsFirstRow != null) {
                xlsFirstRow = ((Number)objXlsFirstRow).intValue() - 1;
            }

            // 나머지 파라메터 값 읽기
            String fileDiv = (String)params.get("P_FILE_DIV");
            String userId = (String)params.get(Consts.PK_USER_ID);
            String recvDate = (String)params.get("P_RECV_DATE");
            String ediFileRoot = getRecvFileRootPath();
            String ediRecvFullPath = Util.getPathName(ediFileRoot, ediDiv);

            MultipartFile ediUploadMultipartFile = null;
            String ediRecvFileName = null;
            String ediRecvFileFullName = null;
            String ediRecvFileBackupPath = null;
            String ediRecvDatetime = Util.getNowDate("yyyyMMddHHmmss");

            // Browser에서 파일 업로드
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                ediUploadMultipartFile = (MultipartFile)params.get("P_UPLOAD_FILE");
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        ediUploadMultipartFile.getOriginalFilename() //
                    }));
            }
            // 서버에 업로드된 파일
            else if (Consts.FILE_DIV_SERVER.equals(fileDiv)) {
                ediRecvFullPath = (String)params.get("P_FILE_DIR");
                ediRecvFileName = (String)params.get("P_FILE_NM");
            } else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.100", "[사업부,수신구분,수신정의번호,파일유형: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + fileDiv //
                    + "]\n처리할 수 없는 파일유형입니다.", new String[] {buCd, ediDiv, defineNo, fileDiv}));
            }

            ediRecvFileFullName = ediRecvFullPath + ediRecvFileName;
            ediRecvFileBackupPath = getBackupFilePath(ediRecvFullPath, ediRecvDatetime, ediDiv);
            ediRecvFileBackupFullName = ediRecvFileBackupPath + ediRecvFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediRecvFullPath, ediRecvFileBackupPath);

            String xlsColumnNm = null;
            String xlsColumnVal = null;
            String columnNm = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            // BATCH 처리를 위한 INSERT SQL 생성
            StringBuffer sbInsertSQLColumns = new StringBuffer();
            StringBuffer sbInsertSQLValues = new StringBuffer();
            sbInsertSQLColumns.append("BU_CD ,EDI_DIV ,DEFINE_NO ,RECV_DATE ,RECV_NO ,RECV_SEQ ,ERROR_DIV ,DATA_DIV ,RECV_USER_ID ,RECV_DATETIME");
            sbInsertSQLValues.append("? ,? ,? ,? ,? ,? ,? ,? ,? ,NVL(? ,SYSDATE)");
            for (int i = 0; i < columnCnt; i++) {
                defineInfo = lstDefineInfo.get(i);
                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    xlsColumnNm = (String)defineInfo.get("XLS_COLUMN_NM");

                    if (Util.isNotNull(xlsColumnNm) && Util.isNotNull(columnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add("P_" + columnNm);
                        vtColumn.add(xlsColumnNm);
                        vtColumn.add(getXLSColumnIndex(xlsColumnNm));
                        columns.add(vtColumn);

                        // BATCH 처리를 위한 INSERT SQL 생성
                        sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                } catch (Exception e) {
                }
            }
            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
            }
            // BATCH 처리를 위한 최종 INSERT SQL 생성
            sbBuffer.setLength(0);
            sbBuffer //
                .append("INSERT INTO ") //
                .append(TABLE_NM) //
                .append(" ( ") //
                .append(sbInsertSQLColumns) //
                .append(" ) ") //
                .append(" VALUES ( ") //
                .append(sbInsertSQLValues) //
                .append(" ) ");

            String insertSql = sbBuffer.toString();

            ediRecvFile = new File(ediRecvFileFullName);
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                try {
                    ediUploadMultipartFile.transferTo(ediRecvFile);
                    params.remove("P_UPLOAD_FILE");
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            }

            String xlsVersion = "xls";
            try {
                xlsFileInput = new FileInputStream(ediRecvFile);
                xlsWorkbook = WorkbookFactory.create(xlsFileInput);
                if (xlsWorkbook instanceof XSSFWorkbook) {
                    xlsVersion = "xlsx";
                    Util.closeObject(xlsWorkbook);
                    Util.closeObject(xlsFileInput);
                }
            } catch (Exception e) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 파일이 아닙니다. 엑셀 파일로 수신 처리하십시오.\n") + Util.getErrorMessage(e));
            }

            // Excel 2007
            if (xlsVersion.equals("xlsx")) {
                try {
                    xlsFileInput = new FileInputStream(ediRecvFile);
                    xlsWorkbook = StreamingReader.builder() //
                        .rowCacheSize(100) // number of rows to keep in memory (defaults to 10)
                        .bufferSize(4096) // buffer size to use when reading InputStream to file (defaults to 1024)
                        .open(xlsFileInput);
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 파일을 열 수 없습니다.\n") + Util.getErrorMessage(e));
                }
                try {
                    xlsSheet = xlsWorkbook.getSheetAt(0);
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 시트를 가져올 수 없습니다.") + Util.getErrorMessage(e));
                }

                // 엑셀의 날짜 타입 Cell 값 변환 Formatter
                SimpleDateFormat stringDatetimeFormat = new SimpleDateFormat(Consts.DATETIME_FORMAT);
                // 엑셀의 숫자 타입 Cell 값 변환 Formatter
                NumberFormat stringNumberFormat = NumberFormat.getNumberInstance();
                stringNumberFormat.setGroupingUsed(false);
                int xlsRowCount = xlsSheet.getLastRowNum() + 1;

                if (xlsFirstRow > xlsRowCount) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 파일에 처리할 데이터가 없습니다.[데이터건수:" + xlsRowCount + "][시작ROW:" + (xlsFirstRow + 1) + "]",
                            new String[] {String.valueOf(xlsRowCount), String.valueOf(xlsFirstRow + 1)}));
                }

                // 수신번호 채번
                Map<String, Object> recvNoMap = getRecvNo(params);

                String oMsg = Util.getOutMessage(recvNoMap);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(oMsg);
                }
                String recvNo = (String)recvNoMap.get("O_RECV_NO");
                params.put("P_RECV_NO", recvNo);

                // resultMap 세팅
                resultMap.put("P_BU_CD", buCd);
                resultMap.put("P_EDI_DIV", ediDiv);
                resultMap.put("P_DEFINE_NO", defineNo);
                resultMap.put("P_RECV_DATE", recvDate);
                resultMap.put("P_RECV_NO", recvNo);

                // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
                insertStatement = getConnection().prepareStatement(insertSql);
                int recvSeq = 0;
                Iterator<Row> rowIterator = xlsSheet.rowIterator();
                // 시작 Row까지 이동
                if (xlsFirstRow > 0) {
                    int skipRow = xlsFirstRow;
                    while (rowIterator.hasNext() && skipRow > 0) {
                        skipRow--;
                        rowIterator.next();
                    }
                }
                while (rowIterator.hasNext()) {

                    xlsRow = rowIterator.next();
                    if (xlsRow == null) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 행이 비어있습니다. 확인 후 작업하십시오."));
                    }
                    // Row의 Cell이 모두 빈값이면 Skip
                    if (isXLSEmptyRow(xlsRow, columns, stringDatetimeFormat, stringNumberFormat)) {
                        continue;
                    }

                    for (int i = 0; i < columnCnt; i++) {
                        // XLS 셀 값 읽기
                        xlsColumnVal = getXLSColumnValue(xlsRow, // XLS Row Data
                            (Integer)columns.get(i).get(2), // XLS Cell Index, 0 based column number
                            stringDatetimeFormat, // XLS Date Type Cell Formatter
                            stringNumberFormat // XLS Number Type Cell Formatter
                        );
                        // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(11 + i, xlsColumnVal);
                    }

                    // 기본 컬럼 값 세팅
                    // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                    recvSeq++;
                    insertStatement.setString(1, buCd);
                    insertStatement.setString(2, ediDiv);
                    insertStatement.setString(3, defineNo);
                    insertStatement.setString(4, recvDate);
                    insertStatement.setString(5, recvNo);
                    insertStatement.setInt(6, recvSeq);
                    insertStatement.setString(7, "0");
                    insertStatement.setString(8, Consts.DATA_DIV_XLS);
                    insertStatement.setString(9, userId);
                    insertStatement.setNull(10, Types.TIMESTAMP);
                    // BATCH에 추가
                    insertStatement.addBatch();
                    // 파라메터 초기화
                    insertStatement.clearParameters();
                    // 1000건씩 처리
                    if (recvSeq % Consts.BULK_CNT == 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                }

                // 나머지 데이터가 있을 경우 처리
                if (recvSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", recvSeq);
            } else {
                // Excel 2003 이하
                try {
                    xlsSheet = xlsWorkbook.getSheetAt(0);
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 시트를 가져올 수 없습니다.") + Util.getErrorMessage(e));
                }

                // 엑셀의 날짜 타입 Cell 값 변환 Formatter
                SimpleDateFormat stringDatetimeFormat = new SimpleDateFormat(Consts.DATETIME_FORMAT);
                // 엑셀의 숫자 타입 Cell 값 변환 Formatter
                NumberFormat stringNumberFormat = NumberFormat.getNumberInstance();
                stringNumberFormat.setGroupingUsed(false);
                int xlsRowCount = xlsSheet.getPhysicalNumberOfRows();

                if (xlsFirstRow > xlsRowCount) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 파일에 처리할 데이터가 없습니다.[데이터건수:" + xlsRowCount + "][시작ROW:" + (xlsFirstRow + 1) + "]",
                            new String[] {String.valueOf(xlsRowCount), String.valueOf(xlsFirstRow + 1)}));
                }

                // 수신번호 채번
                Map<String, Object> recvNoMap = getRecvNo(params);

                String oMsg = Util.getOutMessage(recvNoMap);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(oMsg);
                }
                String recvNo = (String)recvNoMap.get("O_RECV_NO");
                params.put("P_RECV_NO", recvNo);

                // resultMap 세팅
                resultMap.put("P_BU_CD", buCd);
                resultMap.put("P_EDI_DIV", ediDiv);
                resultMap.put("P_DEFINE_NO", defineNo);
                resultMap.put("P_RECV_DATE", recvDate);
                resultMap.put("P_RECV_NO", recvNo);

                // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
                insertStatement = getConnection().prepareStatement(insertSql);
                int recvSeq = 0;
                for (int row = xlsFirstRow; row < xlsRowCount; row++) {

                    xlsRow = xlsSheet.getRow(row);
                    if (xlsRow == null) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "엑셀 행이 비어있습니다. 확인 후 작업하십시오."));
                    }
                    // Row의 Cell이 모두 빈값이면 Skip
                    if (isXLSEmptyRow(xlsRow, columns, stringDatetimeFormat, stringNumberFormat)) {
                        continue;
                    }

                    for (int i = 0; i < columnCnt; i++) {
                        // XLS 셀 값 읽기
                        xlsColumnVal = getXLSColumnValue(xlsRow, // XLS Row Data
                            (Integer)columns.get(i).get(2), // XLS Cell Index, 0 based column number
                            stringDatetimeFormat, // XLS Date Type Cell Formatter
                            stringNumberFormat // XLS Number Type Cell Formatter
                        );
                        // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(11 + i, xlsColumnVal);
                    }

                    // 기본 컬럼 값 세팅
                    // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                    recvSeq = row - xlsFirstRow + 1;
                    insertStatement.setString(1, buCd);
                    insertStatement.setString(2, ediDiv);
                    insertStatement.setString(3, defineNo);
                    insertStatement.setString(4, recvDate);
                    insertStatement.setString(5, recvNo);
                    insertStatement.setInt(6, recvSeq);
                    insertStatement.setString(7, "0");
                    insertStatement.setString(8, Consts.DATA_DIV_XLS);
                    insertStatement.setString(9, userId);
                    insertStatement.setNull(10, Types.TIMESTAMP);
                    // BATCH에 추가
                    insertStatement.addBatch();
                    // 파라메터 초기화
                    insertStatement.clearParameters();
                    // 1000건씩 처리
                    if (recvSeq % Consts.BULK_CNT == 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                }

                // 나머지 데이터가 있을 경우 처리
                if (recvSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", recvSeq);
            }
            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            xlsSheet = null;
            // Util.closeObject(xlsWorkbook);
            if (xlsWorkbook != null) {
                try {
                    xlsWorkbook.close();
                } catch (Exception e) {
                }
            }
            Util.closeObject(xlsFileInput);
            if (ediRecvFile != null) {
                try {
                    if (ediRecvFileBackupFullName != null) {
                        Util.renameFile(ediRecvFile, new File(ediRecvFileBackupFullName));
                    }
                } catch (Exception e) {
                    Util.writeErrorMessage(e);
                }
            }
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> recvText(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        // upload dir로 edi 파일 수신
        File ediRecvFile = null;
        FileInputStream txtFileInput = null;
        InputStreamReader txtFileInputReader = null;
        BufferedReader txtFileReader = null;
        String ediRecvFileBackupFullName = null;

        PreparedStatement insertStatement = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            // 수신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 수신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.093", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 내역이 등록되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            final String TABLE_NM = (String)defineInfo.get("TABLE_NM");
            // final String INSERT_ID = "EDCOMMON.INSERT_" + TABLE_NM;
            String txtDelimeterYn = (String)defineInfo.get("TXT_DELIMETER_YN");
            String txtColDelimeter = (String)defineInfo.get("TXT_COL_DELIMETER");

            if (Consts.YES.equals(txtDelimeterYn) && Util.isNull(txtColDelimeter)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.103", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n텍스트 컬럼 구분자가 지정되지 않았습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 나머지 파라메터 값 읽기
            String fileDiv = (String)params.get("P_FILE_DIV");
            String userId = (String)params.get(Consts.PK_USER_ID);
            String recvDate = (String)params.get("P_RECV_DATE");
            String ediFileRoot = getRecvFileRootPath();
            String ediRecvFullPath = Util.getPathName(ediFileRoot, ediDiv);

            MultipartFile ediUploadMultipartFile = null;
            String ediRecvFileName = null;
            String ediRecvFileFullName = null;
            String ediRecvFileBackupPath = null;
            String ediRecvDatetime = Util.getNowDate("yyyyMMddHHmmss");

            // Browser에서 파일 업로드
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                ediUploadMultipartFile = (MultipartFile)params.get("P_UPLOAD_FILE");
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        ediUploadMultipartFile.getOriginalFilename()//
                    }));
            }
            // 서버에 업로드된 파일
            else if (Consts.FILE_DIV_SERVER.equals(fileDiv)) {
                ediRecvFullPath = (String)params.get("P_FILE_DIR");
                ediRecvFileName = (String)params.get("P_FILE_NM");
            }
            // 문자열
            else if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        "DOC.txt" //
                    }));
            }
            // 기타 오류
            else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.100", "[사업부,수신구분,수신정의번호,파일유형: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + fileDiv //
                    + "]\n처리할 수 없는 파일유형입니다.", new String[] {buCd, ediDiv, defineNo, fileDiv}));
            }

            ediRecvFileFullName = ediRecvFullPath + ediRecvFileName;
            ediRecvFileBackupPath = getBackupFilePath(ediRecvFullPath, ediRecvDatetime, ediDiv);
            ediRecvFileBackupFullName = ediRecvFileBackupPath + ediRecvFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediRecvFullPath, ediRecvFileBackupPath);

            int txtPosition = -1;
            int txtLength = -1;
            String columnNm = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            // BATCH 처리를 위한 INSERT SQL 생성
            StringBuffer sbInsertSQLColumns = new StringBuffer();
            StringBuffer sbInsertSQLValues = new StringBuffer();
            sbInsertSQLColumns.append("BU_CD ,EDI_DIV ,DEFINE_NO ,RECV_DATE ,RECV_NO ,RECV_SEQ ,ERROR_DIV ,DATA_DIV ,RECV_USER_ID ,RECV_DATETIME");
            sbInsertSQLValues.append("? ,? ,? ,? ,? ,? ,? ,? ,? ,NVL(? ,SYSDATE)");
            for (int i = 0; i < columnCnt; i++) {
                defineInfo = lstDefineInfo.get(i);

                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    txtPosition = ((Number)defineInfo.get("TXT_POSITION")).intValue();
                    txtLength = ((Number)defineInfo.get("TXT_LENGTH")).intValue();

                    if (txtPosition > -1 && txtLength > 0 && Util.isNotNull(columnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add("P_" + columnNm);
                        vtColumn.add(txtPosition);
                        vtColumn.add(txtLength);
                        columns.add(vtColumn);

                        // BATCH 처리를 위한 INSERT SQL에 수신 컬럼 추가
                        sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                } catch (Exception e) {
                }
            }
            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
            }
            // BATCH 처리를 위한 최종 INSERT SQL 생성
            sbBuffer.setLength(0);
            sbBuffer //
                .append("INSERT INTO ") //
                .append(TABLE_NM) //
                .append(" ( ") //
                .append(sbInsertSQLColumns) //
                .append(" ) ") //
                .append(" VALUES ( ") //
                .append(sbInsertSQLValues) //
                .append(" ) ");

            String insertSql = sbBuffer.toString();

            ediRecvFile = new File(ediRecvFileFullName);
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                try {
                    ediUploadMultipartFile.transferTo(ediRecvFile);
                    params.remove("P_UPLOAD_FILE");
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            } else if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                try {
                    String document = (String)params.get("P_DOCUMENT");
                    FileUtils.writeStringToFile(ediRecvFile, document, Consts.CHARSET);
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            }

            String[] availableCharsets = {"UTF-8", "MS949", "EUC-KR"};
            Charset txtCharset = detectCharset(ediRecvFile, availableCharsets);
            if (txtCharset == null) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.104", "텍스트 파일의 인코딩을 [UTF-8, EUC-KR, MS949] 형식으로 저장 후 처리하십시오."));
            }
            logger.info("EDCommonDAOImpl[recvText] File Encoding : " + ediRecvFile.getAbsolutePath() + "," + txtCharset.displayName());

            try {
                txtFileInput = new FileInputStream(ediRecvFileFullName);
                txtFileInputReader = new InputStreamReader(txtFileInput, txtCharset);
                txtFileReader = new BufferedReader(txtFileInputReader);
            } catch (Exception e) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.105", "수신 처리할 텍스트 파일이 존재하지 않습니다."));
            }

            // 수신번호 채번
            Map<String, Object> recvNoMap = getRecvNo(params);

            String oMsg = Util.getOutMessage(recvNoMap);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException(oMsg);
            }
            String recvNo = (String)recvNoMap.get("O_RECV_NO");
            params.put("P_RECV_NO", recvNo);

            // resultMap 세팅
            resultMap.put("P_BU_CD", buCd);
            resultMap.put("P_EDI_DIV", ediDiv);
            resultMap.put("P_DEFINE_NO", defineNo);
            resultMap.put("P_RECV_DATE", recvDate);
            resultMap.put("P_RECV_NO", recvNo);

            // BATCH 처리를 위한 Connection으로부터로부터 PreparedStatement 취득
            insertStatement = getConnection().prepareStatement(insertSql);
            int recvSeq = 0;
            String txtLine = null;
            byte[] txtLineBytes = null;
            String[] txtLineSplit = null;
            // 컬럼 구분자로 처리일 경우
            if (Consts.YES.equals(txtDelimeterYn)) {
                txtLine = txtFileReader.readLine();
                if (txtLine != null) {
                    // BOM 제거
                    if (txtCharset.name().equalsIgnoreCase(Consts.CHARSET)) {
                        txtLineBytes = txtLine.getBytes();
                        if (txtLineBytes.length > 3) {
                            if (txtLineBytes[0] == -17 && txtLineBytes[1] == -69 && txtLineBytes[2] == -65) {
                                txtLine = new String(txtLineBytes, 3, txtLineBytes.length - 3);
                            }
                        }
                    }
                    do {
                        // 공백 Line Skip
                        if (txtLine.trim().equals("")) {
                            txtLine = txtFileReader.readLine();
                            continue;
                        }

                        txtLineSplit = txtLine.split(txtColDelimeter);
                        for (int i = 0; i < columnCnt; i++) {
                            vtColumn = columns.get(i);

                            columnNm = (String)vtColumn.get(0);
                            txtPosition = (Integer)vtColumn.get(1);
                            txtLength = (Integer)vtColumn.get(2);

                            try {
                                txtLineBytes = txtLineSplit[txtPosition - 1].getBytes(Consts.KR_CHARSET);
                                columnVal = new String(txtLineBytes, 0, Math.min(txtLineBytes.length, txtLength), Consts.KR_CHARSET);
                            } catch (Exception e) {
                                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.106",
                                    "컬럼명: " + columnNm.replaceFirst("P_", "") + "\n\n텍스트 시작위치/컬럼길이가 잘못 지정되었습니다.",
                                    new String[] {columnNm.replaceFirst("P_", "")}));
                            }

                            // rowParams.put(columnNm, columnVal.trim());
                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(11 + i, columnVal.trim());
                        }

                        recvSeq += 1;
                        // 기본 컬럼 값 세팅
                        // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_TXT);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }

                        txtLine = txtFileReader.readLine();
                    } while (txtLine != null);

                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
            }
            // 위치/길이로 처리
            else {
                txtLine = txtFileReader.readLine();
                if (txtLine != null) {
                    // BOM 제거
                    if (txtCharset.name().equals(Consts.CHARSET)) {
                        txtLineBytes = txtLine.getBytes();
                        if (txtLineBytes.length > 3) {
                            if (txtLineBytes[0] == -17 && txtLineBytes[1] == -69 && txtLineBytes[2] == -65) {
                                txtLine = new String(txtLineBytes, 3, txtLineBytes.length - 3);
                            }
                        }
                    }

                    do {
                        // 공백 Line Skip
                        if (txtLine.trim().equals("")) {
                            txtLine = txtFileReader.readLine();
                            continue;
                        }

                        txtLineBytes = txtLine.getBytes(Consts.KR_CHARSET);
                        for (int i = 0; i < columnCnt; i++) {
                            vtColumn = columns.get(i);

                            columnNm = (String)vtColumn.get(0);
                            txtPosition = (Integer)vtColumn.get(1);
                            txtLength = (Integer)vtColumn.get(2);

                            try {
                                columnVal = new String(txtLineBytes, txtPosition - 1, txtLength, Consts.KR_CHARSET);
                            } catch (Exception e) {
                                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.106",
                                    "컬럼명: " + columnNm.replaceFirst("P_", "") + "\n\n텍스트 시작위치/컬럼길이가 잘못 지정되었습니다.",
                                    new String[] {columnNm.replaceFirst("P_", "")}));
                            }

                            // rowParams.put(columnNm, columnVal.trim());
                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(11 + i, columnVal.trim());
                        }

                        recvSeq += 1;
                        // 기본 컬럼 값 세팅
                        // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_TXT);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }

                        txtLine = txtFileReader.readLine();
                    } while (txtLine != null);

                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
            }
            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            // Util.closeObject(txtFileReader);
            if (txtFileReader != null) {
                try {
                    txtFileReader.close();
                } catch (Exception e) {
                }
            }
            // Util.closeObject(txtFileInputReader);
            if (txtFileInputReader != null) {
                try {
                    txtFileInputReader.close();
                } catch (Exception e) {
                }
            }
            // Util.closeObject(txtFileInput);
            if (txtFileInput != null) {
                try {
                    txtFileInput.close();
                } catch (Exception e) {
                }
            }
            if (ediRecvFile != null) {
                try {
                    if (ediRecvFileBackupFullName != null) {
                        Util.renameFile(ediRecvFile, new File(ediRecvFileBackupFullName));
                    }
                } catch (Exception e) {
                    Util.writeErrorMessage(e);
                }
            }
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> recvXML(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        // upload dir로 edi 파일 수신
        File ediRecvFile = null;
        DocumentBuilderFactory xmlDocFactory = null;
        DocumentBuilder xmlDocBuilder = null;
        Document xmlDoc = null;
        String ediRecvFileBackupFullName = null;

        PreparedStatement insertStatement = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            // 수신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 수신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.093", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 내역이 등록되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            final String TABLE_NM = (String)defineInfo.get("TABLE_NM");
            // final String INSERT_ID = "EDCOMMON.INSERT_" + TABLE_NM;
            String xmlTagRoot = (String)defineInfo.get("XML_TAG_ROOT");
            String xmlTagBunch = (String)defineInfo.get("XML_TAG_BUNCH");
            String xmlTagSubBunch = (String)defineInfo.get("XML_TAG_SUB_BUNCH");

            if (Util.isNull(xmlTagRoot)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.107", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\nXML 루트태그가 정의되지 않았습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 나머지 파라메터 값 읽기
            String fileDiv = (String)params.get("P_FILE_DIV");
            String userId = (String)params.get(Consts.PK_USER_ID);
            String recvDate = (String)params.get("P_RECV_DATE");
            String ediFileRoot = getRecvFileRootPath();
            String ediRecvFullPath = Util.getPathName(ediFileRoot, ediDiv);

            MultipartFile ediUploadMultipartFile = null;
            String ediRecvFileName = null;
            String ediRecvFileFullName = null;
            String ediRecvFileBackupPath = null;
            String ediRecvDatetime = Util.getNowDate("yyyyMMddHHmmss");

            // Browser에서 파일 업로드
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                ediUploadMultipartFile = (MultipartFile)params.get("P_UPLOAD_FILE");
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        ediUploadMultipartFile.getOriginalFilename() //
                    }));
                ediRecvFileFullName = ediRecvFullPath + ediRecvFileName;
            }
            // 서버에 업로드된 파일
            else if (Consts.FILE_DIV_SERVER.equals(fileDiv)) {
                ediRecvFullPath = (String)params.get("P_FILE_DIR");
                ediRecvFileName = (String)params.get("P_FILE_NM");
            }
            // 문자열
            else if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        "DOC.xml" //
                    }));
            }
            // 기타 오류
            else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.100", "[사업부,수신구분,수신정의번호,파일유형: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + fileDiv //
                    + "]\n처리할 수 없는 파일유형입니다.", new String[] {buCd, ediDiv, defineNo, fileDiv}));
            }

            ediRecvFileFullName = ediRecvFullPath + ediRecvFileName;
            ediRecvFileBackupPath = getBackupFilePath(ediRecvFullPath, ediRecvDatetime, ediDiv);
            ediRecvFileBackupFullName = ediRecvFileBackupPath + ediRecvFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediRecvFullPath, ediRecvFileBackupPath);

            String xmlTagName = null;
            String[] xmlTagNames = null;
            String xmlTagAttr = null;
            String columnNm = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            // BATCH 처리를 위한 INSERT SQL 생성
            StringBuffer sbInsertSQLColumns = new StringBuffer();
            StringBuffer sbInsertSQLValues = new StringBuffer();
            sbInsertSQLColumns.append("BU_CD ,EDI_DIV ,DEFINE_NO ,RECV_DATE ,RECV_NO ,RECV_SEQ ,ERROR_DIV ,DATA_DIV ,RECV_USER_ID ,RECV_DATETIME");
            sbInsertSQLValues.append("? ,? ,? ,? ,? ,? ,? ,? ,? ,NVL(? ,SYSDATE)");
            for (int i = 0; i < columnCnt; i++) {
                defineInfo = lstDefineInfo.get(i);

                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    xmlTagName = (String)defineInfo.get("XML_TAG_NM");
                    xmlTagAttr = (String)defineInfo.get("XML_TAG_ATTR");

                    if (Util.isNotNull(columnNm) && Util.isNotNull(xmlTagName)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add("P_" + columnNm);
                        vtColumn.add(xmlTagName);
                        vtColumn.add(xmlTagAttr);
                        xmlTagNames = xmlTagName.split("/");
                        if (xmlTagSubBunch != null && xmlTagSubBunch.equals(xmlTagNames[0])) {
                            String[] xmlNewTagNames = new String[xmlTagNames.length - 1];
                            System.arraycopy(xmlTagNames, 1, xmlNewTagNames, 0, xmlNewTagNames.length);
                            vtColumn.add(xmlNewTagNames);
                            vtColumn.add("S"); // SUB BUNCH
                        } else {
                            vtColumn.add(xmlTagNames);
                            vtColumn.add("M");
                        }

                        columns.add(vtColumn);

                        // BATCH 처리를 위한 INSERT SQL에 수신 컬럼 추가
                        sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                } catch (Exception e) {
                }
            }
            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
            }
            // BATCH 처리를 위한 최종 INSERT SQL 생성
            sbBuffer.setLength(0);
            sbBuffer //
                .append("INSERT INTO ").append(TABLE_NM) //
                .append(" ( ") //
                .append(sbInsertSQLColumns) //
                .append(" ) ") //
                .append("VALUES ( ") //
                .append(sbInsertSQLValues) //
                .append(" )");

            String insertSql = sbBuffer.toString();

            ediRecvFile = new File(ediRecvFileFullName);
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                try {
                    ediUploadMultipartFile.transferTo(ediRecvFile);
                    params.remove("P_UPLOAD_FILE");
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            } else if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                try {
                    String document = (String)params.get("P_DOCUMENT");
                    FileUtils.writeStringToFile(ediRecvFile, document, Consts.CHARSET);
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            }

            try {
                xmlDocFactory = DocumentBuilderFactory.newInstance();
                xmlDocBuilder = xmlDocFactory.newDocumentBuilder();
                xmlDoc = xmlDocBuilder.parse(ediRecvFile);
            } catch (Exception e) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.108", "수신 처리할 XML 파일을 파싱하지 못했습니다."));
            }

            Element xmlRootElement = xmlDoc.getDocumentElement();
            xmlRootElement.normalize();
            if (!xmlTagRoot.equals(xmlRootElement.getNodeName())) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.109",
                    "[정의루트태그, 파일루트태그: " + xmlTagRoot + "," + xmlRootElement.getNodeName() + "]다른 형식의 XML 파일입니다. 파일을 확인하십시오.",
                    new String[] {xmlTagRoot, Util.toString(xmlRootElement.getNodeName())}));
            }

            NodeList xmlDataNodeList = null;
            // 단위태그가 지정되어 있으면 단위태그로 리스트 가져옴
            if (Util.isNotNull(xmlTagBunch)) {
                xmlDataNodeList = xmlRootElement.getElementsByTagName(xmlTagBunch);
            } else {
                xmlDataNodeList = xmlRootElement.getChildNodes();
            }

            if (xmlDataNodeList == null || xmlDataNodeList.getLength() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.43", "XML 파일에 처리할 데이터가 없습니다."));
            }

            // 수신번호 채번
            Map<String, Object> recvNoMap = getRecvNo(params);

            String oMsg = Util.getOutMessage(recvNoMap);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException(oMsg);
            }
            String recvNo = (String)recvNoMap.get("O_RECV_NO");
            params.put("P_RECV_NO", recvNo);

            // resultMap 세팅
            resultMap.put("P_BU_CD", buCd);
            resultMap.put("P_EDI_DIV", ediDiv);
            resultMap.put("P_DEFINE_NO", defineNo);
            resultMap.put("P_RECV_DATE", recvDate);
            resultMap.put("P_RECV_NO", recvNo);

            int recvSeq = 0;
            Node xmlDataNode = null;

            // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
            insertStatement = getConnection().prepareStatement(insertSql);

            if (xmlTagSubBunch == null) {
                // 마스터 구조의 XML
                for (int row = 0, dataCount = xmlDataNodeList.getLength(); row < dataCount; row++) {
                    xmlDataNode = xmlDataNodeList.item(row);
                    if (xmlDataNode.getNodeType() == Node.ELEMENT_NODE) {

                        Element xmlDataElement = (Element)xmlDataNode;
                        for (int i = 0; i < columnCnt; i++) {
                            vtColumn = columns.get(i);
                            columnNm = (String)vtColumn.get(0);
                            columnVal = getXMLColumnValue(vtColumn, xmlDataElement);
                            // rowParams.put(columnNm, columnVal);
                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(11 + i, columnVal);
                        }

                        recvSeq += 1;
                        // 기본 컬럼 값 세팅
                        // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_XML);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }
                    }
                }

                // 나머지 데이터가 있을 경우 처리
                if (recvSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", recvSeq);
            } else {
                // 마스터/디테일 구조의 XML
                Node xmlDataSubNode = null;
                NodeList xmlDataSubNodeList = null;
                for (int row = 0, dataCount = xmlDataNodeList.getLength(); row < dataCount; row++) {
                    xmlDataNode = xmlDataNodeList.item(row);
                    if (xmlDataNode.getNodeType() == Node.ELEMENT_NODE) {

                        // 마스터 데이터 파싱
                        Element xmlDataElement = (Element)xmlDataNode;
                        for (int i = 0; i < columnCnt; i++) {
                            vtColumn = columns.get(i);
                            if ("S".equals(vtColumn.get(4))) {
                                continue;
                            }
                            columnNm = (String)vtColumn.get(0);
                            columnVal = getXMLColumnValue(vtColumn, xmlDataElement);
                            // rowParams.put(columnNm, columnVal);
                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(11 + i, columnVal);
                        }

                        // 디테일 데이터 파싱
                        xmlDataSubNodeList = xmlDataElement.getElementsByTagName(xmlTagSubBunch);
                        for (int subRow = 0, subDataCount = xmlDataSubNodeList.getLength(); subRow < subDataCount; subRow++) {
                            xmlDataSubNode = xmlDataSubNodeList.item(subRow);
                            if (xmlDataSubNode.getNodeType() == Node.ELEMENT_NODE) {

                                Element xmlSubDataElement = (Element)xmlDataSubNode;
                                for (int i = 0; i < columnCnt; i++) {
                                    vtColumn = columns.get(i);
                                    if ("M".equals(vtColumn.get(4))) {
                                        continue;
                                    }
                                    columnNm = (String)vtColumn.get(0);
                                    columnVal = getXMLColumnValue(vtColumn, xmlSubDataElement);
                                    // rowParams.put(columnNm, columnVal);
                                    // 기본 컬럼 다음 Index, 시작 1,
                                    // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                                    insertStatement.setString(11 + i, columnVal);
                                }

                                recvSeq += 1;
                                // rowParams.put("P_RECV_SEQ", recvSeq);
                                // insertSql(INSERT_ID, rowParams);
                                // 기본 컬럼 값 세팅
                                // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                                insertStatement.setString(1, buCd);
                                insertStatement.setString(2, ediDiv);
                                insertStatement.setString(3, defineNo);
                                insertStatement.setString(4, recvDate);
                                insertStatement.setString(5, recvNo);
                                insertStatement.setInt(6, recvSeq);
                                insertStatement.setString(7, "0");
                                insertStatement.setString(8, Consts.DATA_DIV_XML);
                                insertStatement.setString(9, userId);
                                insertStatement.setNull(10, Types.TIMESTAMP);
                                // BATCH에 추가
                                insertStatement.addBatch();
                                // 파라메터 초기화
                                insertStatement.clearParameters();
                                // 1000건씩 처리
                                if (recvSeq % Consts.BULK_CNT == 0) {
                                    // BATCH 실행
                                    insertStatement.executeBatch();
                                    // BATCH 초기화
                                    insertStatement.clearBatch();
                                }
                            }
                        }
                    }
                }

                // 나머지 데이터가 있을 경우 처리
                if (recvSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", recvSeq);
            }
            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            xmlDoc = null;
            xmlDocFactory = null;
            xmlDocBuilder = null;
            if (ediRecvFile != null) {
                try {
                    if (ediRecvFileBackupFullName != null) {
                        Util.renameFile(ediRecvFile, new File(ediRecvFileBackupFullName));
                    }
                } catch (Exception e) {
                    Util.writeErrorMessage(e);
                }
            }
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
        }
        return resultMap;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Map<String, Object> recvJson(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        // upload dir로 edi 파일 수신
        File ediRecvFile = null;
        FileInputStream jsonFileInput = null;
        InputStreamReader jsonFileInputReader = null;
        BufferedReader jsonFileReader = null;
        Map<String, Object> jsonMap = null;
        List<Map<String, Object>> jsonRows = null;
        List<Map<String, Object>> jsonSubRows = null;
        String ediRecvFileBackupFullName = null;

        PreparedStatement insertStatement = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            // 수신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 수신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.093", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 내역이 등록되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            final String TABLE_NM = (String)defineInfo.get("TABLE_NM");
            // final String INSERT_ID = "EDCOMMON.INSERT_" + TABLE_NM;
            String jsonTagRoot = (String)defineInfo.get("JSON_TAG_ROOT");
            String jsonTagBunch = (String)defineInfo.get("JSON_TAG_BUNCH");
            String jsonTagSubBunch = (String)defineInfo.get("JSON_TAG_SUB_BUNCH");
            String jsonTagStructDiv = (String)defineInfo.get("JSON_TAG_STRUCT_DIV");
            String jsonTagLinkMap = (String)defineInfo.get("JSON_TAG_LINK_MAP");
            String[] jsonTagLinkColumns = {};

            // 나머지 파라메터 값 읽기
            String fileDiv = (String)params.get("P_FILE_DIV");
            Map<String, Object> jsonResultInfo = (Map<String, Object>)params.get("P_JSON_RESULT_INFO");
            String userId = (String)params.get(Consts.PK_USER_ID);
            String recvDate = (String)params.get("P_RECV_DATE");
            String ediFileRoot = getRecvFileRootPath();
            String ediRecvFullPath = Util.getPathName(ediFileRoot, ediDiv);

            MultipartFile ediUploadMultipartFile = null;
            String ediRecvFileName = null;
            String ediRecvFileFullName = null;
            String ediRecvFileBackupPath = null;
            String ediRecvDatetime = Util.getNowDate("yyyyMMddHHmmss");

            // Browser에서 파일 업로드
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                ediUploadMultipartFile = (MultipartFile)params.get("P_UPLOAD_FILE");
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        ediUploadMultipartFile.getOriginalFilename() //
                    }));
            }
            // 서버에 업로드된 파일
            else if (Consts.FILE_DIV_SERVER.equals(fileDiv)) {
                ediRecvFullPath = (String)params.get("P_FILE_DIR");
                ediRecvFileName = (String)params.get("P_FILE_NM");
            }
            // 문자열
            else if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                ediRecvFileName = Util.replaceRestrictChars(Util.toJoin("_", //
                    new String[] { //
                        userId, // 사용자ID
                        ediRecvDatetime, // 수신일시
                        buCd, ediDiv, defineNo, // 사업부, 수신구분 정의번호
                        RandomStringUtils.randomNumeric(5), // 랜덤 5자리 숫자
                        "DOC.json" //
                    }));
            }
            // 기타 오류
            else {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.100", "[사업부,수신구분,수신정의번호,파일유형: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + fileDiv //
                    + "]\n처리할 수 없는 파일유형입니다.", new String[] {buCd, ediDiv, defineNo, fileDiv}));
            }

            ediRecvFileFullName = ediRecvFullPath + ediRecvFileName;
            ediRecvFileBackupPath = getBackupFilePath(ediRecvFullPath, ediRecvDatetime, ediDiv);
            ediRecvFileBackupFullName = ediRecvFileBackupPath + ediRecvFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediRecvFullPath, ediRecvFileBackupPath);

            String jsonColumnNm = null;
            String columnNm = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            // BATCH 처리를 위한 INSERT SQL 생성
            StringBuffer sbInsertSQLColumns = new StringBuffer();
            StringBuffer sbInsertSQLValues = new StringBuffer();
            sbInsertSQLColumns.append("BU_CD ,EDI_DIV ,DEFINE_NO ,RECV_DATE ,RECV_NO ,RECV_SEQ ,ERROR_DIV ,DATA_DIV ,RECV_USER_ID ,RECV_DATETIME");
            sbInsertSQLValues.append("? ,? ,? ,? ,? ,? ,? ,? ,? ,NVL(? ,SYSDATE)");
            for (int i = 0; i < columnCnt; i++) {
                defineInfo = lstDefineInfo.get(i);

                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    jsonColumnNm = (String)defineInfo.get("JSON_COLUMN_NM");

                    if (Util.isNotNull(columnNm) && Util.isNotNull(jsonColumnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add("P_" + columnNm);
                        vtColumn.add(jsonColumnNm);
                        columns.add(vtColumn);

                        // BATCH 처리를 위한 INSERT SQL에 수신 컬럼 추가
                        sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                        sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                    }
                } catch (Exception e) {
                }
            }
            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 마스터, 디테일 연결 매핑일 경우 체크
            if ("4".equals(jsonTagStructDiv)) {
                jsonTagLinkColumns = Util.split(jsonTagLinkMap, Consts.SEP_DATA);
                if (jsonTagLinkColumns.length == 0) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX",
                        "[" + jsonTagBunch + ", " + jsonTagSubBunch + "]간 연결 Key 매핑 정보가 존재하지 않습니다.", new String[] {jsonTagBunch, jsonTagSubBunch}));
                }
            }

            // BATCH 처리를 위한 최종 INSERT SQL 생성
            sbBuffer.setLength(0);
            sbBuffer //
                .append("INSERT INTO ") //
                .append(TABLE_NM) //
                .append(" ( ") //
                .append(sbInsertSQLColumns) //
                .append(" ) ") //
                .append(" VALUES ( ") //
                .append(sbInsertSQLValues) //
                .append(" ) ");

            String insertSql = sbBuffer.toString();

            ediRecvFile = new File(ediRecvFileFullName);
            if (Consts.FILE_DIV_ATTACHMENT.equals(fileDiv)) {
                try {
                    ediUploadMultipartFile.transferTo(ediRecvFile);
                    params.remove("P_UPLOAD_FILE");
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            } else if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                try {
                    String document = (String)params.get("P_DOCUMENT");
                    FileUtils.writeStringToFile(ediRecvFile, document, Consts.CHARSET);
                } catch (Exception e) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.101", "수신 처리할 파일을 전송하지 못했습니다."));
                }
            }

            String[] availableCharsets = {"UTF-8", "MS949", "EUC-KR"};
            Charset txtCharset = detectCharset(ediRecvFile, availableCharsets);
            if (txtCharset == null) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.110", "Json 파일의 인코딩을 [UTF-8, EUC-KR, MS949] 형식으로 저장 후 처리하십시오."));
            }
            logger.info("EDCommonDAOImpl[recvJson] File Encoding : " + ediRecvFile.getAbsolutePath() + "," + txtCharset.displayName());

            try {
                jsonFileInput = new FileInputStream(ediRecvFileFullName);
                jsonFileInputReader = new InputStreamReader(jsonFileInput, txtCharset);
                jsonFileReader = new BufferedReader(jsonFileInputReader);
            } catch (Exception e) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.111", "수신 처리할 Json 파일이 존재하지 않습니다."));
            }

            Map<String, Object> jsonRootMap = null;
            Object jsonRootObject = null;
            Object jsonBunchObject = null;
            Object jsonObject = null;
            String jsonDetailKey = null;
            try {
                // 구조구분
                // 1: 마스터
                // 2: 마스터/디테일, 마스터내 디테일 태그 존재
                // 3: 마스터/디테일, 마스터/디테일 태그 분리
                // 3: 마스터/디테일, 마스터/디테일 분리, 연결키로 디테일 검색
                if (Util.isIncluded(jsonTagStructDiv, new String[] {"1", "2"})) {
                    // 루트 태그 미지정
                    // Json A타입: { 마스터 or 마스터/디테일 데이터, ... }
                    // Json B타입: [ { 마스터 or 마스터/디테일 데이터, ... } ]
                    if (Util.isNull(jsonTagRoot)) {
                        boolean objError = false;
                        // Object로 변환 처리
                        try {
                            jsonMap = new ObjectMapper().readValue(jsonFileReader, new MapTypeReference<String, Object>());
                            jsonRows = new ArrayList<Map<String, Object>>();
                            jsonRows.add(jsonMap);
                            jsonDetailKey = jsonTagBunch;
                        } catch (Exception e) {
                            objError = true;
                        }
                        // Object로 변환 오류시 List로 재변환 처리
                        // Object 오류시 Stream이 close 되므로 다시 오픈
                        if (objError) {
                            try {
                                jsonFileInput = new FileInputStream(ediRecvFileFullName);
                                jsonFileInputReader = new InputStreamReader(jsonFileInput, txtCharset);
                                jsonFileReader = new BufferedReader(jsonFileInputReader);
                            } catch (Exception e) {
                                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.111", "수신 처리할 Json 파일이 존재하지 않습니다."));
                            }
                            jsonRows = new ObjectMapper().readValue(jsonFileReader, new MapListTypeReference<String, Object>());
                        }
                    }
                    // 루트 태그 지정
                    else {
                        // Object, Object에서 Root를 읽음
                        jsonMap = new ObjectMapper().readValue(jsonFileReader, new MapTypeReference<String, Object>());
                        // 단위 태그 미지정
                        // Json A타입: { 루트태그: { 마스터 or 마스터/디테일 데이터, ... } }
                        // Json B타입: { 루트태그: [ { 마스터 or 마스터/디테일 데이터, ... } ] }
                        if (Util.isNull(jsonTagBunch)) {
                            jsonRootObject = jsonMap.get(jsonTagRoot);
                            if (jsonRootObject instanceof List) {
                                jsonRows = (List<Map<String, Object>>)jsonRootObject;
                            } else {
                                jsonRows = new ArrayList<Map<String, Object>>();
                                jsonRows.add((Map<String, Object>)jsonRootObject);
                            }
                        }
                        // 단위 태그 지정
                        else {
                            // 하위 단위 태그 미지정
                            // Json A타입: { 루트태그: [ { 마스터 데이터, ... , 단위태그: { 디테일 데이터, ... } } ] }
                            // Json B타입: { 루트태그: { 단위태그: [ { 마스터 or 마스터/디테일 데이터, } ] } }
                            // Json C타입: { 루트태그: { 단위태그: { 마스터 or 마스터/디테일 데이터, ... } } }
                            if (Util.isNull(jsonTagSubBunch)) {
                                jsonRootObject = jsonMap.get(jsonTagRoot);
                                if (jsonRootObject instanceof List) {
                                    jsonRows = (List<Map<String, Object>>)jsonRootObject;
                                    jsonDetailKey = jsonTagBunch;
                                } else {
                                    jsonObject = ((Map<String, Object>)jsonRootObject).get(jsonTagBunch);
                                    if (jsonObject instanceof List) {
                                        jsonRows = new ArrayList<Map<String, Object>>();
                                        jsonRows.add((Map<String, Object>)jsonRootObject);
                                        jsonDetailKey = jsonTagBunch;
                                    } else {
                                        jsonRows = new ArrayList<Map<String, Object>>();
                                        jsonRows.add((Map<String, Object>)jsonObject);
                                    }
                                }
                            }
                            // 하위 단위 태그 지정
                            // Json A타입: { 루트태그: { 단위태그: [ { 마스터 데이터, ... , 하위단위태그: [ { 디테일 데이터, ... } ] } ] } }
                            // Json B타입: { 루트태그: { 단위태그: { 마스터 데이터, ... 하위단위태그: [ { 디테일 데이터, ... } ] } } }
                            // Json C타입: { 루트태그: { 단위태그: { 마스터 데이터, ... , 하위단위태그: { 디테일 데이터, ... } } } }
                            else {
                                Map<String, Object> jsonTagRootMap = (Map<String, Object>)jsonMap.get(jsonTagRoot);
                                jsonBunchObject = jsonTagRootMap.get(jsonTagBunch);
                                if (jsonBunchObject instanceof List) {
                                    jsonRows = (List<Map<String, Object>>)jsonBunchObject;
                                    jsonDetailKey = jsonTagSubBunch;
                                } else {
                                    jsonObject = ((Map<String, Object>)jsonBunchObject).get(jsonTagSubBunch);
                                    if (jsonObject instanceof List) {
                                        jsonRows = new ArrayList<Map<String, Object>>();
                                        jsonRows.add((Map<String, Object>)jsonBunchObject);
                                        jsonDetailKey = jsonTagSubBunch;
                                    } else {
                                        jsonRows = new ArrayList<Map<String, Object>>();
                                        jsonRows.add((Map<String, Object>)jsonObject);
                                    }
                                }
                            }
                        }
                    }
                }
                // 마스터/디테일 분리
                else {
                    // 루트 태그 미지정
                    // Json A타입: { { 마스터 }, {디테일} }
                    // Json B타입: { [ 마스터 ], [디테일] }
                    jsonMap = new ObjectMapper().readValue(jsonFileReader, new MapTypeReference<String, Object>());
                    if (Util.isNull(jsonTagRoot)) {
                        if (Util.isNull(jsonTagBunch) || Util.isNull(jsonTagSubBunch)) {
                            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "단위태그 정보가 입력되지 않아 수신처리할 수 없습니다."));
                        }
                        // Json A타입
                        jsonBunchObject = jsonMap.get(jsonTagBunch);
                        if (jsonBunchObject instanceof Map) {
                            jsonRows = new ArrayList<Map<String, Object>>();
                            jsonRows.add((Map<String, Object>)jsonBunchObject);
                            jsonBunchObject = jsonMap.get(jsonTagSubBunch);
                            if (jsonBunchObject instanceof Map) {
                                jsonSubRows = new ArrayList<Map<String, Object>>();
                                jsonSubRows.add((Map<String, Object>)jsonBunchObject);
                            } else {
                                jsonSubRows = (List<Map<String, Object>>)jsonBunchObject;
                            }
                        }
                        // Json B타입
                        else {
                            jsonRows = (List<Map<String, Object>>)jsonMap.get(jsonTagBunch);
                            jsonSubRows = (List<Map<String, Object>>)jsonMap.get(jsonTagSubBunch);
                        }
                    }
                    // 루트 태그 지정
                    // Json A타입: { { 마스터 }, {디테일} }
                    // Json B타입: { [ 마스터 ], [디테일] }
                    // Json C타입: { 루트: { { 마스터 }, {디테일} } }
                    // Json D타입: { 루트: { [ 마스터 ], [디테일] } }
                    else {
                        jsonMap = new ObjectMapper().readValue(jsonFileReader, new MapTypeReference<String, Object>());
                        if (Util.isNull(jsonTagBunch) || Util.isNull(jsonTagSubBunch)) {
                            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "단위태그 정보가 입력되지 않아 수신처리할 수 없습니다."));
                        }
                        // 루트, 단위 태그 사용
                        if (Util.isNull(jsonTagSubBunch)) {
                            // Json A타입
                            jsonBunchObject = jsonMap.get(jsonTagRoot);
                            if (jsonBunchObject instanceof Map) {
                                jsonRows = new ArrayList<Map<String, Object>>();
                                jsonRows.add((Map<String, Object>)jsonBunchObject);
                                jsonBunchObject = jsonMap.get(jsonTagBunch);
                                if (jsonBunchObject instanceof Map) {
                                    jsonSubRows = new ArrayList<Map<String, Object>>();
                                    jsonSubRows.add((Map<String, Object>)jsonBunchObject);
                                } else {
                                    jsonSubRows = (List<Map<String, Object>>)jsonBunchObject;
                                }
                            }
                            // Json B타입
                            else {
                                jsonRows = (List<Map<String, Object>>)jsonMap.get(jsonTagRoot);
                                jsonSubRows = (List<Map<String, Object>>)jsonMap.get(jsonTagBunch);
                            }
                        }
                        // 단위태그, 하위단위태그 사용
                        else {
                            jsonRootMap = (Map<String, Object>)jsonMap.get(jsonTagRoot);
                            // Json C타입
                            jsonBunchObject = jsonRootMap.get(jsonTagBunch);
                            if (jsonBunchObject instanceof Map) {
                                jsonRows = new ArrayList<Map<String, Object>>();
                                jsonRows.add((Map<String, Object>)jsonBunchObject);
                                jsonBunchObject = jsonRootMap.get(jsonTagSubBunch);
                                if (jsonBunchObject instanceof Map) {
                                    jsonSubRows = new ArrayList<Map<String, Object>>();
                                    jsonSubRows.add((Map<String, Object>)jsonBunchObject);
                                } else {
                                    jsonSubRows = (List<Map<String, Object>>)jsonBunchObject;
                                }
                            }
                            // Json D타입
                            else {
                                jsonRows = (List<Map<String, Object>>)jsonMap.get(jsonTagBunch);
                                jsonSubRows = (List<Map<String, Object>>)jsonMap.get(jsonTagSubBunch);
                            }
                        }
                    }
                }
            } catch (Exception e) {
                throw new RuntimeException(
                    Util.getErrorMessage(NexosMessage.getDisplayMsg("JAVA.ED.112", "수신 처리할 Json 파일(문자) 파싱 중 오류가 발생했습니다.\n"), e));
            }

            // 수신번호 채번
            Map<String, Object> recvNoMap = getRecvNo(params);

            String oMsg = Util.getOutMessage(recvNoMap);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException(oMsg);
            }
            String recvNo = (String)recvNoMap.get("O_RECV_NO");
            params.put("P_RECV_NO", recvNo);

            // resultMap 세팅
            resultMap.put("P_BU_CD", buCd);
            resultMap.put("P_EDI_DIV", ediDiv);
            resultMap.put("P_DEFINE_NO", defineNo);
            resultMap.put("P_RECV_DATE", recvDate);
            resultMap.put("P_RECV_NO", recvNo);

            // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
            insertStatement = getConnection().prepareStatement(insertSql);
            int recvSeq = 0;
            int jsonRowCount = jsonRows.size();
            Object jsonColumnVal;
            boolean decode = Consts.YES.equals(jsonResultInfo.get("P_MESSAGE_DECODE_YN"));
            // 구조구분
            // 1: 마스터
            // 2: 마스터/디테일, 마스터내 디테일 태그 존재
            // 3: 마스터/디테일, 마스터/디테일 태그 분리
            // 3: 마스터/디테일, 마스터/디테일 분리, 연결키로 디테일 검색
            if (Util.isIncluded(jsonTagStructDiv, new String[] {"1", "2"})) {
                if (jsonDetailKey == null) {
                    Map<String, Object> jsonRowData;
                    for (int rIndex = 0; rIndex < jsonRowCount; rIndex++) {
                        jsonRowData = jsonRows.get(rIndex);

                        for (int cIndex = 0; cIndex < columnCnt; cIndex++) {
                            vtColumn = columns.get(cIndex);

                            columnNm = (String)vtColumn.get(0);
                            jsonColumnNm = (String)vtColumn.get(1);
                            jsonColumnVal = jsonRowData.get(jsonColumnNm);
                            if (jsonColumnVal == null) {
                                columnVal = "";
                            } else if (jsonColumnVal instanceof String) {
                                columnVal = urlDecodeMessage(decode, (String)jsonColumnVal);
                            } else if (jsonColumnVal instanceof Number) {
                                columnVal = String.valueOf(jsonColumnVal);
                            } else {
                                columnVal = jsonColumnVal.toString();
                            }

                            // rowParams.put(columnNm, columnVal.trim());
                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(11 + cIndex, columnVal.trim());
                        }

                        recvSeq += 1;
                        // 기본 컬럼 값 세팅
                        // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_JSON);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }
                    }

                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
                // 마스터/디테일 구조
                else {

                    Map<String, Object> jsonMasterRowData;
                    List<Map<String, Object>> jsonDetailRows;
                    Map<String, Object> jsonDetailRowData;

                    for (int mIndex = 0; mIndex < jsonRowCount; mIndex++) {
                        jsonMasterRowData = jsonRows.get(mIndex);

                        jsonDetailRows = (List<Map<String, Object>>)jsonMasterRowData.get(jsonDetailKey);
                        int jsonDetailRowCount = jsonDetailRows.size();

                        for (int dIndex = 0; dIndex < jsonDetailRowCount; dIndex++) {
                            jsonDetailRowData = jsonDetailRows.get(dIndex);

                            for (int cIndex = 0; cIndex < columnCnt; cIndex++) {
                                vtColumn = columns.get(cIndex);

                                columnNm = (String)vtColumn.get(0);
                                jsonColumnNm = (String)vtColumn.get(1);

                                if (jsonMasterRowData.containsKey(jsonColumnNm)) {
                                    jsonColumnVal = jsonMasterRowData.get(jsonColumnNm);
                                    if (jsonColumnVal == null) {
                                        columnVal = "";
                                    } else if (jsonColumnVal instanceof String) {
                                        columnVal = urlDecodeMessage(decode, (String)jsonColumnVal);
                                    } else if (jsonColumnVal instanceof Number) {
                                        columnVal = String.valueOf(jsonColumnVal);
                                    } else {
                                        columnVal = jsonColumnVal.toString();
                                    }

                                    // rowParams.put(columnNm, columnVal.trim());
                                    // 기본 컬럼 다음 Index, 시작 1,
                                    // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                                    insertStatement.setString(11 + cIndex, columnVal.trim());
                                } else {
                                    jsonColumnVal = jsonDetailRowData.get(jsonColumnNm);
                                    if (jsonColumnVal == null) {
                                        columnVal = "";
                                    } else if (jsonColumnVal instanceof String) {
                                        columnVal = urlDecodeMessage(decode, (String)jsonColumnVal);
                                    } else if (jsonColumnVal instanceof Number) {
                                        columnVal = String.valueOf(jsonColumnVal);
                                    } else {
                                        columnVal = jsonColumnVal.toString();
                                    }

                                    // rowParams.put(columnNm, columnVal.trim());
                                    // 기본 컬럼 다음 Index, 시작 1,
                                    // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                                    insertStatement.setString(11 + cIndex, columnVal.trim());
                                }
                            }

                            recvSeq += 1;
                            // 기본 컬럼 값 세팅
                            // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(1, buCd);
                            insertStatement.setString(2, ediDiv);
                            insertStatement.setString(3, defineNo);
                            insertStatement.setString(4, recvDate);
                            insertStatement.setString(5, recvNo);
                            insertStatement.setInt(6, recvSeq);
                            insertStatement.setString(7, "0");
                            insertStatement.setString(8, Consts.DATA_DIV_JSON);
                            insertStatement.setString(9, userId);
                            insertStatement.setNull(10, Types.TIMESTAMP);
                            // BATCH에 추가
                            insertStatement.addBatch();
                            // 파라메터 초기화
                            insertStatement.clearParameters();
                            // 1000건씩 처리
                            if (recvSeq % Consts.BULK_CNT == 0) {
                                // BATCH 실행
                                insertStatement.executeBatch();
                                // BATCH 초기화
                                insertStatement.clearBatch();
                            }
                        }
                    }

                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
            }
            // 마스터, 디테일 분리
            else {
                Map<String, Object> jsonMasterRowData;
                List<Map<String, Object>> jsonDetailRows;
                Map<String, Object> jsonDetailRowData;

                // 마스터, 디테일 연결키가 없을 경우, 마스터 1건, 디테일 N건
                if (Util.isNull(jsonTagLinkMap)) {
                    jsonMasterRowData = jsonRows.get(0);
                    jsonDetailRows = jsonSubRows;
                    int jsonDetailRowCount = jsonDetailRows.size();

                    // 단위태그의 데이터가 있으면서 하위단위태그의 데이터가 없을 경우, 단위태그 기준으로 처리
                    if (!jsonMasterRowData.isEmpty() && jsonDetailRowCount == 0) {
                        // 하위단위태그에 빈 데이터 입력
                        jsonDetailRows.add(Util.newMap());
                        jsonDetailRowCount++;
                    }

                    for (int rIndex = 0; rIndex < jsonDetailRowCount; rIndex++) {
                        jsonDetailRowData = jsonDetailRows.get(rIndex);

                        for (int cIndex = 0; cIndex < columnCnt; cIndex++) {
                            vtColumn = columns.get(cIndex);

                            columnNm = (String)vtColumn.get(0);
                            jsonColumnNm = (String)vtColumn.get(1);

                            // 마스터에 데이터 존재할 경우 마스터 기준으로 처리
                            if (jsonMasterRowData.containsKey(jsonColumnNm)) {
                                jsonColumnVal = jsonMasterRowData.get(jsonColumnNm);
                            }
                            // 디테일에서 읽기
                            else {
                                jsonColumnVal = jsonDetailRowData.get(jsonColumnNm);
                            }
                            if (jsonColumnVal == null) {
                                columnVal = "";
                            } else if (jsonColumnVal instanceof String) {
                                columnVal = urlDecodeMessage(decode, (String)jsonColumnVal);
                            } else if (jsonColumnVal instanceof Number) {
                                columnVal = String.valueOf(jsonColumnVal);
                            } else {
                                columnVal = jsonColumnVal.toString();
                            }

                            // rowParams.put(columnNm, columnVal.trim());
                            // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(11 + cIndex, columnVal.trim());
                        }

                        recvSeq += 1;
                        // 기본 컬럼 값 세팅
                        // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(1, buCd);
                        insertStatement.setString(2, ediDiv);
                        insertStatement.setString(3, defineNo);
                        insertStatement.setString(4, recvDate);
                        insertStatement.setString(5, recvNo);
                        insertStatement.setInt(6, recvSeq);
                        insertStatement.setString(7, "0");
                        insertStatement.setString(8, Consts.DATA_DIV_JSON);
                        insertStatement.setString(9, userId);
                        insertStatement.setNull(10, Types.TIMESTAMP);
                        // BATCH에 추가
                        insertStatement.addBatch();
                        // 파라메터 초기화
                        insertStatement.clearParameters();
                        // 1000건씩 처리
                        if (recvSeq % Consts.BULK_CNT == 0) {
                            // BATCH 실행
                            insertStatement.executeBatch();
                            // BATCH 초기화
                            insertStatement.clearBatch();
                        }
                    }

                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
                // 마스터/디테일 연결키, N:N 구조
                else {
                    jsonDetailRows = jsonSubRows;
                    for (int mIndex = 0; mIndex < jsonRowCount; mIndex++) {
                        jsonMasterRowData = jsonRows.get(mIndex);

                        int jsonDetailRowCount = jsonDetailRows.size();
                        int processDetail = 0;

                        for (int dIndex = 0; dIndex < jsonDetailRowCount; dIndex++) {
                            jsonDetailRowData = jsonDetailRows.get(dIndex);

                            // 연결키 체크
                            if (Consts.YES.equals(jsonDetailRowData.get("_PROCESS_YN")) //
                                || !isJsonLinkData(jsonMasterRowData, jsonDetailRowData, jsonTagLinkColumns)) {
                                continue;
                            }

                            // 중복 처리되지 않도록 처리여부 기록
                            jsonDetailRowData.put("_PROCESS_YN", Consts.YES);

                            for (int cIndex = 0; cIndex < columnCnt; cIndex++) {
                                vtColumn = columns.get(cIndex);

                                columnNm = (String)vtColumn.get(0);
                                jsonColumnNm = (String)vtColumn.get(1);

                                // 마스터에 데이터 존재할 경우 마스터 기준으로 처리
                                if (jsonMasterRowData.containsKey(jsonColumnNm)) {
                                    jsonColumnVal = jsonMasterRowData.get(jsonColumnNm);
                                }
                                // 디테일에서 읽기
                                else {
                                    jsonColumnVal = jsonDetailRowData.get(jsonColumnNm);
                                }

                                if (jsonColumnVal == null) {
                                    columnVal = "";
                                } else if (jsonColumnVal instanceof String) {
                                    columnVal = urlDecodeMessage(decode, (String)jsonColumnVal);
                                } else if (jsonColumnVal instanceof Number) {
                                    columnVal = String.valueOf(jsonColumnVal);
                                } else {
                                    columnVal = jsonColumnVal.toString();
                                }

                                // rowParams.put(columnNm, columnVal.trim());
                                // 기본 컬럼 다음 Index, 시작 1,
                                // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                                insertStatement.setString(11 + cIndex, columnVal.trim());
                            }

                            processDetail += 1;
                            recvSeq += 1;
                            // 기본 컬럼 값 세팅
                            // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(1, buCd);
                            insertStatement.setString(2, ediDiv);
                            insertStatement.setString(3, defineNo);
                            insertStatement.setString(4, recvDate);
                            insertStatement.setString(5, recvNo);
                            insertStatement.setInt(6, recvSeq);
                            insertStatement.setString(7, "0");
                            insertStatement.setString(8, Consts.DATA_DIV_JSON);
                            insertStatement.setString(9, userId);
                            insertStatement.setNull(10, Types.TIMESTAMP);
                            // BATCH에 추가
                            insertStatement.addBatch();
                            // 파라메터 초기화
                            insertStatement.clearParameters();
                            // 1000건씩 처리
                            if (recvSeq % Consts.BULK_CNT == 0) {
                                // BATCH 실행
                                insertStatement.executeBatch();
                                // BATCH 초기화
                                insertStatement.clearBatch();
                            }
                        }

                        if (processDetail == 0) {
                            // throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX",
                            // "[" + jsonTagBunch + ", " + jsonTagSubBunch + "]연결 Key에 해당하는 데이터가 존재하지 않습니다.",
                            // new String[] {jsonTagBunch, jsonTagSubBunch}));

                            // 연결 Key로 데이터가 없을 경우 단위태그 정보로만 기록
                            for (int cIndex = 0; cIndex < columnCnt; cIndex++) {
                                vtColumn = columns.get(cIndex);

                                columnNm = (String)vtColumn.get(0);
                                jsonColumnNm = (String)vtColumn.get(1);

                                jsonColumnVal = jsonMasterRowData.get(jsonColumnNm);
                                if (jsonColumnVal == null) {
                                    columnVal = "";
                                } else if (jsonColumnVal instanceof String) {
                                    columnVal = urlDecodeMessage(decode, (String)jsonColumnVal);
                                } else if (jsonColumnVal instanceof Number) {
                                    columnVal = String.valueOf(jsonColumnVal);
                                } else {
                                    columnVal = jsonColumnVal.toString();
                                }

                                // rowParams.put(columnNm, columnVal.trim());
                                // 기본 컬럼 다음 Index, 시작 1,
                                // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                                insertStatement.setString(11 + cIndex, columnVal.trim());
                            }

                            recvSeq += 1;
                            // 기본 컬럼 값 세팅
                            // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                            insertStatement.setString(1, buCd);
                            insertStatement.setString(2, ediDiv);
                            insertStatement.setString(3, defineNo);
                            insertStatement.setString(4, recvDate);
                            insertStatement.setString(5, recvNo);
                            insertStatement.setInt(6, recvSeq);
                            insertStatement.setString(7, "0");
                            insertStatement.setString(8, Consts.DATA_DIV_JSON);
                            insertStatement.setString(9, userId);
                            insertStatement.setNull(10, Types.TIMESTAMP);
                            // BATCH에 추가
                            insertStatement.addBatch();
                            // 파라메터 초기화
                            insertStatement.clearParameters();
                            // 1000건씩 처리
                            if (recvSeq % Consts.BULK_CNT == 0) {
                                // BATCH 실행
                                insertStatement.executeBatch();
                                // BATCH 초기화
                                insertStatement.clearBatch();
                            }
                        }
                    }

                    // 나머지 데이터가 있을 경우 처리
                    if (recvSeq % Consts.BULK_CNT != 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                    params.put("O_PROCESS_CNT", recvSeq);
                }
            }
            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            Util.closeObject(jsonFileReader);
            Util.closeObject(jsonFileInputReader);
            Util.closeObject(jsonFileInput);
            if (ediRecvFile != null) {
                try {
                    if (ediRecvFileBackupFullName != null) {
                        Util.renameFile(ediRecvFile, new File(ediRecvFileBackupFullName));
                    }
                } catch (Exception e) {
                    Util.writeErrorMessage(e);
                }
            }
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
        }

        return resultMap;
    }

    @Override
    public Map<String, Object> recvSAPFunction(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        PreparedStatement insertStatement = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            // 수신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // com.sap.conn.jco.JCoFunction sapFunction = (com.sap.conn.jco.JCoFunction)params.get("P_SAP_FUNCTION");
            com.sap.conn.jco.JCoTable sapTable = (com.sap.conn.jco.JCoTable)params.get("P_SAP_TABLE");

            if (sapTable == null || sapTable.getNumRows() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.096", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신처리할 대상 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.093", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 내역이 등록되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            // 수신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            final String TABLE_NM = (String)defineInfo.get("TABLE_NM");
            // final String INSERT_ID = "EDCOMMON.INSERT_" + TABLE_NM;

            // 나머지 파라메터 값 읽기
            String userId = (String)params.get(Consts.PK_USER_ID);
            String recvDate = (String)params.get("P_RECV_DATE");

            String columnNm = null;
            String linkColumnNm = null;
            String dataType = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            // BATCH 처리를 위한 INSERT SQL 생성
            StringBuffer sbInsertSQLColumns = new StringBuffer();
            StringBuffer sbInsertSQLValues = new StringBuffer();
            sbInsertSQLColumns.append("BU_CD ,EDI_DIV ,DEFINE_NO ,RECV_DATE ,RECV_NO ,RECV_SEQ ,ERROR_DIV ,DATA_DIV ,RECV_USER_ID ,RECV_DATETIME");
            sbInsertSQLValues.append("? ,? ,? ,? ,? ,? ,? ,? ,? ,NVL(? ,SYSDATE)");
            for (int i = 0; i < columnCnt; i++) {
                defineInfo = lstDefineInfo.get(i);

                columnNm = (String)defineInfo.get("COLUMN_NM");
                linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");
                dataType = (String)defineInfo.get("DATA_TYPE");

                if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm)) {
                    vtColumn = new Vector<Object>();
                    vtColumn.add("P_" + columnNm);
                    vtColumn.add(linkColumnNm);
                    if (Util.isNull(dataType)) {
                        dataType = DT_STRING;
                    }
                    vtColumn.add(dataType);
                    columns.add(vtColumn);

                    // BATCH 처리를 위한 INSERT SQL에 수신 컬럼 추가
                    sbInsertSQLColumns.append(SC_SEP).append(columnNm);
                    sbInsertSQLValues.append(SC_SEP).append(SC_BIND);
                }
            }
            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.095", "[사업부,수신구분,수신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n수신정의 컬럼 중 처리 가능한 컬럼이 없습니다.", new String[] {buCd, ediDiv, defineNo}));
            }
            // BATCH 처리를 위한 최종 INSERT SQL 생성
            sbBuffer.setLength(0);
            sbBuffer //
                .append("INSERT INTO ") //
                .append(TABLE_NM) //
                .append(" ( ") //
                .append(sbInsertSQLColumns) //
                .append(" ) ") //
                .append(" VALUES ( ") //
                .append(sbInsertSQLValues) //
                .append(" ) ");

            String insertSql = sbBuffer.toString();

            // 수신번호 채번
            Map<String, Object> recvNoMap = getRecvNo(params);
            String oMsg = Util.getOutMessage(recvNoMap);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException(oMsg);
            }
            String recvNo = (String)recvNoMap.get("O_RECV_NO");
            params.put("P_RECV_NO", recvNo);

            // resultMap 세팅
            resultMap.put("P_BU_CD", buCd);
            resultMap.put("P_EDI_DIV", ediDiv);
            resultMap.put("P_DEFINE_NO", defineNo);
            resultMap.put("P_RECV_DATE", recvDate);
            resultMap.put("P_RECV_NO", recvNo);

            // try {
            // logger.info(sapTable.toXML());
            // } catch (Exception e) {
            // }

            // BATCH 처리를 위한 Connection으로부터 PreparedStatement 취득
            insertStatement = getConnection().prepareStatement(insertSql);
            int recvSeq = 0;
            int recvDataCnt = sapTable.getNumRows();
            for (int row = 0; row < recvDataCnt; row++) {
                sapTable.setRow(row);

                for (int i = 0; i < columnCnt; i++) {
                    vtColumn = columns.get(i);

                    columnNm = (String)vtColumn.get(0);
                    linkColumnNm = (String)vtColumn.get(1);
                    dataType = (String)vtColumn.get(2);

                    try {
                        // 현재 문자열로 데이터를 읽음, 필요시 데이터 타입별로 처리
                        if (sapTable.getValue(linkColumnNm) == null) {
                            columnVal = null;
                        } else {
                            columnVal = sapTable.getString(linkColumnNm);
                        }
                        // 문자열
                        // if (DT_STRING.equals(dataType)) {
                        // columnVal = sapTable.getString(linkColumnNm);
                        // }
                        // // 숫자
                        // else if (DT_NUMBER.equals(dataType)) {
                        // columnVal = sapTable.getString(linkColumnNm);
                        // }
                        // // 날짜
                        // else if (DT_DATE.equals(dataType)) {
                        // columnVal = sapTable.getString(linkColumnNm);
                        // }
                        // // 기타
                        // else {
                        // throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.097","[사업부,수신구분,수신정의번호,컬럼명: " //
                        // + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                        // + "]\n컬럼 데이터 타입 정의가 불분명합니다.", new String[] {buCd, ediDiv, defineNo, columnNm}));
                        // }
                        // rowParams.put(columnNm, columnVal);
                        // 기본 컬럼 다음 Index, 시작 1, BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                        insertStatement.setString(11 + i, columnVal);
                    } catch (Exception e) {
                        throw new RuntimeException(Util.getErrorMessage(NexosMessage.getDisplayMsg("JAVA.ED.113", "[사업부,수신구분,수신정의번호,컬럼명: " //
                            + buCd + "," + ediDiv + "," + defineNo + "," + columnNm //
                            + "]\n컬럼 값 읽기 오류: ", new String[] {buCd, ediDiv, defineNo, columnNm}), e));
                    }
                }

                // 기본 컬럼 값 세팅
                // BU_CD,EDI_DIV,DEFINE_NO,RECV_DATE,RECV_NO,RECV_SEQ,ERROR_DIV,DATA_DIV,RECV_USER_ID,RECV_DATETIME
                recvSeq = row + 1;
                insertStatement.setString(1, buCd);
                insertStatement.setString(2, ediDiv);
                insertStatement.setString(3, defineNo);
                insertStatement.setString(4, recvDate);
                insertStatement.setString(5, recvNo);
                insertStatement.setInt(6, recvSeq);
                insertStatement.setString(7, "0");
                insertStatement.setString(8, Consts.DATA_DIV_SAP);
                insertStatement.setString(9, userId);
                insertStatement.setNull(10, Types.TIMESTAMP);
                // BATCH에 추가
                insertStatement.addBatch();
                // 파라메터 초기화
                insertStatement.clearParameters();
                // 1000건씩 처리
                if (recvSeq % Consts.BULK_CNT == 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
            }

            // 나머지 데이터가 있을 경우 처리
            if (recvSeq % Consts.BULK_CNT != 0) {
                // BATCH 실행
                insertStatement.executeBatch();
                // BATCH 초기화
                insertStatement.clearBatch();
            }
            params.put("O_PROCESS_CNT", recvSeq);

            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
        }
        return resultMap;
    }

    @Override
    public int compare(Vector<Object> o1, Vector<Object> o2) {

        return (Integer)o1.get(1) > (Integer)o2.get(1) ? 1 : 0;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Map<String, Object> sendDBConnect(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        final String TABLE_INSERT = "2";
        final String PROCEDURE_CALL = "3";
        @SuppressWarnings("unused")
        final String SCRIPT_CALL = "4";

        PreparedStatement insertStatement = null;
        CallableStatement callStatement = null;
        StringBuffer sbBuffer = new StringBuffer();
        try {
            // 송신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.035", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 내역이 등록되어 있지 않습니다."));
            }

            // 송신시 SELECT/UPDATE 대상에 대한 정보 리턴
            Map<String, Object> sendUpdateInfo = getSendUpdateInfo(params);
            String oMsg = Util.getOutMessage(sendUpdateInfo);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException("[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n" + oMsg);
            }

            // 송신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);

            // 나머지 파라메터 값 읽기
            String sendDate = (String)params.get("P_SEND_DATE");
            String sendNo = (String)params.get("P_SEND_NO");
            String userId = (String)params.get(Consts.PK_USER_ID);
            String esTableNm = (String)defineInfo.get("TABLE_NM");
            String dbcTableNm = (String)defineInfo.get("LINK_TABLE_NM");
            String remoteActionType = Util.nullToEmpty(params.get("P_REMOTE_ACTION_TYPE"));
            String remoteParamMap = (String)params.get("P_REMOTE_PARAM_MAP");

            DynamicDataSource dbcDatasource = (DynamicDataSource)params.get("P_EDI_DATASOURCE");
            String dbcType = dbcDatasource.getDBType();

            String es1stUpdateText = null;

            StringBuffer sbES2ndSelectList = new StringBuffer();
            String es2ndSelectText = null;
            String es3rdUpdateText = null;
            String tx3rdUpdateTable = null;
            String tx3rdUpdateText = null;
            String tx3rdUpdateSendState = null;
            String tx3rdUpdateSendUserId = null;
            String tx3rdUpdateSendDatetime = null;

            String columnNm = null;
            String linkColumnNm = null;
            String dataDefault = null;
            String dataType = null;
            // String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();
            String insertSql = null;

            // PROCEDURE<CALL> 방식
            Map<String, Object> remoteParamMaps = null;
            Map<String, Integer> linkParamOrders = null;
            Map<String, Object> linkOutputParams = null;
            if (PROCEDURE_CALL.equals(remoteActionType)) {
                List<String> lstBindingParams = new ArrayList<String>();
                remoteParamMaps = getRemoteParamMaps("2", dbcType, remoteParamMap, lstBindingParams, userId);
                oMsg = Util.getOutMessage(remoteParamMaps);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.114", "[사업부,송신구분,송신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n" + oMsg, new String[] {buCd, ediDiv, defineNo, oMsg}));
                }

                // 컬럼 정보 생성
                linkParamOrders = (Map<String, Integer>)remoteParamMaps.get("P_LINK_PARAM_ORDERS");
                for (int i = 0; i < columnCnt; i++) {
                    defineInfo = lstDefineInfo.get(i);

                    try {
                        columnNm = (String)defineInfo.get("COLUMN_NM");
                        dataType = (String)defineInfo.get("DATA_TYPE");
                        linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");
                        dataDefault = (String)defineInfo.get("DATA_DEFAULT");

                        if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm) && Util.isNotNull(dataType)) {
                            Integer linkColumnOrder = linkParamOrders.get(linkColumnNm);
                            if (linkColumnOrder == null) {
                                continue;
                            }
                            vtColumn = new Vector<Object>();
                            vtColumn.add(columnNm);
                            vtColumn.add(linkColumnNm);
                            vtColumn.add(linkColumnOrder.intValue());

                            if (setSendColumnSQLText(true, sbES2ndSelectList, null, lstBindingParams, linkColumnOrder, dbcType, columnNm, dataDefault,
                                dataType, userId)) {
                                // NULL이 아닐 경우 컬럼 정보에 추가
                                columns.add(vtColumn);
                            }
                        }
                    } catch (Exception e) {
                    }
                }

                // 구분자 잘라내기
                sbES2ndSelectList.delete(0, SC_SEP.length());

                sbBuffer.setLength(0);
                sbBuffer //
                    .append("{ call ").append(dbcTableNm) //
                    .append(" ( ") //
                    .append(StringUtils.join(lstBindingParams.toArray(), SC_SEP)) //
                    .append(" )") //
                    .append(" }");

                insertSql = sbBuffer.toString();
            }
            // TABLE<INSERT> 방식
            // BATCH 처리를 위한 INSERT SQL 생성
            else if (TABLE_INSERT.equals(remoteActionType)) {
                StringBuffer sbInsertSQLColumns = new StringBuffer();
                StringBuffer sbInsertSQLValues = new StringBuffer();
                for (int i = 0; i < columnCnt; i++) {
                    defineInfo = lstDefineInfo.get(i);

                    try {
                        columnNm = (String)defineInfo.get("COLUMN_NM");
                        dataType = (String)defineInfo.get("DATA_TYPE");
                        linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");
                        dataDefault = (String)defineInfo.get("DATA_DEFAULT");

                        if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm) && Util.isNotNull(dataType)) {
                            vtColumn = new Vector<Object>();
                            vtColumn.add(columnNm);
                            vtColumn.add(linkColumnNm);

                            sbInsertSQLColumns.append(SC_SEP).append(linkColumnNm);
                            if (setSendColumnSQLText(false, sbES2ndSelectList, sbInsertSQLValues, null, null, dbcType, columnNm, dataDefault,
                                dataType, userId)) {
                                // BIND로 추가될 경우 컬럼 정보에 추가
                                columns.add(vtColumn);
                            }
                        }
                    } catch (Exception e) {
                    }
                }
                // 구분자 잘라내기
                sbES2ndSelectList.delete(0, SC_SEP.length());
                sbInsertSQLColumns.delete(0, SC_SEP.length());
                sbInsertSQLValues.delete(0, SC_SEP.length());

                // BATCH 처리를 위한 최종 INSERT SQL 생성
                sbBuffer.setLength(0);
                sbBuffer //
                    .append("INSERT INTO ").append(dbcTableNm) //
                    .append(" ( ") //
                    .append(sbInsertSQLColumns) //
                    .append(" ) ") //
                    .append("VALUES ( ") //
                    .append(sbInsertSQLValues) //
                    .append(" )");

                insertSql = sbBuffer.toString();
            }
            // SCRIPT<CALL> 방식
            // BATCH 처리를 위한 SQL 생성
            else {
                if (Util.isNull(remoteParamMap)) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.115", "[사업부,송신구분,송신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n송신처리할 SCRIPT가 입력되지 않았습니다.", new String[] {buCd, ediDiv, defineNo}));
                }

                for (int i = 0; i < columnCnt; i++) {
                    defineInfo = lstDefineInfo.get(i);

                    try {
                        columnNm = (String)defineInfo.get("COLUMN_NM");
                        // dataType = (String)defineInfo.get("DATA_TYPE");
                        linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");
                        // dataDefault = (String)defineInfo.get("DATA_DEFAULT");

                        if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm)) {
                            vtColumn = new Vector<Object>();
                            vtColumn.add(columnNm);
                            vtColumn.add(linkColumnNm);

                            sbES2ndSelectList.append(SC_SEP).append(columnNm);
                            // BIND로 추가될 경우 컬럼 정보에 추가
                            columns.add(vtColumn);
                        }
                    } catch (Exception e) {
                    }
                }

                // 구분자 잘라내기
                sbES2ndSelectList.delete(0, SC_SEP.length());

                // BATCH 처리를 위한 최종 INSERT SQL 생성
                insertSql = remoteParamMap;
            }

            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.040", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 컬럼 중 처리 가능한 컬럼이 없습니다."));
            }

            // 1차 송신대상 UPDATE SQL문 적용
            sbBuffer.setLength(0);
            sbBuffer //
                .append("UPDATE ").append(esTableNm) //
                .append("   SET ERROR_DIV     = DECODE(ERROR_DIV ,WD.C_ERROR_DIV_93 ,TO_CHAR(1/0) ,WD.C_ERROR_DIV_93)") //
                .append(" WHERE BU_CD         = ").append(Util.toSingleQuoted(buCd)) //
                .append("   AND EDI_DIV       = ").append(Util.toSingleQuoted(ediDiv)) //
                .append("   AND DEFINE_NO     = ").append(Util.toSingleQuoted(defineNo)) //
                .append("   AND SEND_DATE     = WF.C_TO_DATE(").append(Util.toSingleQuoted(sendDate)).append(")") //
                .append("   AND SEND_NO       = ").append(Util.toSingleQuoted(sendNo)) //
                .append("   AND ERROR_DIV    IN (WD.C_ERROR_DIV_2, WD.C_ERROR_DIV_3)"); // 2:미처리, 3:처리오류

            es1stUpdateText = sbBuffer.toString();

            // 2차 송신대상 SELECT SQL문 적용
            sbBuffer.setLength(0);
            sbBuffer //
                .append("SELECT ").append(sbES2ndSelectList) //
                .append("  FROM ").append(esTableNm) //
                .append(" WHERE BU_CD         = ").append(Util.toSingleQuoted(buCd)) //
                .append("   AND EDI_DIV       = ").append(Util.toSingleQuoted(ediDiv)) //
                .append("   AND DEFINE_NO     = ").append(Util.toSingleQuoted(defineNo)) //
                .append("   AND SEND_DATE     = WF.C_TO_DATE(").append(Util.toSingleQuoted(sendDate)).append(")") //
                .append("   AND SEND_NO       = ").append(Util.toSingleQuoted(sendNo)) //
                .append("   AND ERROR_DIV     = WD.C_ERROR_DIV_93"); // 93:처리대상

            es2ndSelectText = sbBuffer.toString();

            // 3차 송신결과 UPDATE SQL문 적용
            sbBuffer.setLength(0);
            sbBuffer //
                .append("UPDATE ").append(esTableNm) //
                .append("   SET ERROR_DIV     = WD.C_ERROR_DIV_4") //
                .append("      ,SEND_USER_ID  = ").append(Util.toSingleQuoted(userId)) //
                .append("      ,SEND_DATETIME = SYSDATE") //
                .append(" WHERE BU_CD         = ").append(Util.toSingleQuoted(buCd)) //
                .append("   AND EDI_DIV       = ").append(Util.toSingleQuoted(ediDiv)) //
                .append("   AND DEFINE_NO     = ").append(Util.toSingleQuoted(defineNo)) //
                .append("   AND SEND_DATE     = WF.C_TO_DATE(").append(Util.toSingleQuoted(sendDate)).append(")") //
                .append("   AND SEND_NO       = ").append(Util.toSingleQuoted(sendNo)) //
                .append("   AND ERROR_DIV     = WD.C_ERROR_DIV_93"); // 93:처리대상

            es3rdUpdateText = sbBuffer.toString();

            // 4차 송신진행상태 UPDATE SQL문 적용
            // WI.GET_SEND_UPDATE_INFO
            // O_T_TABLE_NM 송신대상 SELECT/UPDATE 테이블명
            // O_T_PROC_UNIT_COLS 송신대상 SELECT LIST/WHERE/GROUP BY 컬럼(처리단위)
            // O_T_UPDATE_COLS 송신대상 송신상태 업데이트 컬럼
            // O_ES_PROC_UNIT_COLS 송신테이블 SELECT LIST/GROUP BY 컬럼(처리단위)
            tx3rdUpdateTable = (String)sendUpdateInfo.get("O_T_TABLE_NM");
            String tx3rdUpdateProcUnitCols = (String)sendUpdateInfo.get("O_T_PROC_UNIT_COLS");
            String tx3rdUpdateCols = (String)sendUpdateInfo.get("O_T_UPDATE_COLS");
            String tx3rdUpdateESProcUnitCols = (String)sendUpdateInfo.get("O_ES_PROC_UNIT_COLS");

            if (Util.isNotNull(tx3rdUpdateCols)) {
                String[] arrUpdateCols = tx3rdUpdateCols.split(Consts.SEP_DATA);
                tx3rdUpdateSendState = arrUpdateCols[0];
                tx3rdUpdateSendUserId = arrUpdateCols[1];
                tx3rdUpdateSendDatetime = arrUpdateCols[2];
            }

            if (Util.isNotNull(tx3rdUpdateTable)) {
                sbBuffer.setLength(0);
                sbBuffer //
                    .append("UPDATE ").append(tx3rdUpdateTable) //
                    .append("   SET ").append(tx3rdUpdateSendState).append(" = DECODE(").append(tx3rdUpdateSendState) //
                    .append(" ,WD.C_SEND_STATE_30 ,WD.C_SEND_STATE_50 ,WD.C_SEND_STATE_51)") //
                    .append(SC_SEP).append(tx3rdUpdateSendUserId).append(" = ").append(Util.toSingleQuoted(userId)) //
                    .append(SC_SEP).append(tx3rdUpdateSendDatetime).append(" = SYSDATE") //
                    .append(" WHERE (").append(tx3rdUpdateProcUnitCols).append(")") //
                    .append("    IN (") //
                    .append("        SELECT ").append(tx3rdUpdateESProcUnitCols) //
                    .append("          FROM ").append(esTableNm) //
                    .append("         WHERE BU_CD         = ").append(Util.toSingleQuoted(buCd)) //
                    .append("           AND EDI_DIV       = ").append(Util.toSingleQuoted(ediDiv)) //
                    .append("           AND DEFINE_NO     = ").append(Util.toSingleQuoted(defineNo)) //
                    .append("           AND SEND_DATE     = WF.C_TO_DATE(").append(Util.toSingleQuoted(sendDate)).append(")") //
                    .append("           AND SEND_NO       = ").append(Util.toSingleQuoted(sendNo)) //
                    .append("           AND ERROR_DIV     = WD.C_ERROR_DIV_93") // 93:처리대상
                    .append("         GROUP BY ").append(tx3rdUpdateESProcUnitCols) //
                    .append("       )");

                tx3rdUpdateText = sbBuffer.toString();
            }

            // 1차 송신 대상 UPDATE
            // logger.debug("FIRST UPDATE SQL: " + es1stUpdateText);
            Map<String, Object> callParams = new HashMap<String, Object>();
            callParams.put("P_QUERY_TEXT", es1stUpdateText);
            callParams.put(Consts.PK_USER_ID, userId);
            resultMap = callProcedure(UPDATE_ID_DYNAMIC, callParams);
            oMsg = Util.getOutMessage(resultMap);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신 대상 업데이트 중 오류가 발생했습니다.\n" + oMsg, new String[] {buCd, ediDiv, defineNo}));
            }

            // 2차 송신 대상 SELECT
            // logger.debug("SECOND SELECT SQL: " + es2ndSelectText);
            callParams.clear();
            callParams.put("P_QUERY_TEXT", es2ndSelectText);
            callParams.put(Consts.PK_USER_ID, userId);
            List<Map<String, Object>> lstSendData = getDataList(SELECT_ID_DYNAMIC, callParams);
            if (lstSendData == null || lstSendData.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.117", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신처리할 대상 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            Map<String, Object> sendRow = null;
            int sendDataCnt = lstSendData.size();

            // PROCEDURE<CALL> 방식
            if (PROCEDURE_CALL.equals(remoteActionType)) {
                callStatement = dbcDatasource.prepareCall(insertSql);

                // OUTPUT 파라메터 등록
                linkOutputParams = (Map<String, Object>)remoteParamMaps.get("P_LINK_OUTPUT_PARAMS");
                for (Map.Entry<String, Object> outputParam : linkOutputParams.entrySet()) {
                    String outputDataType = (String)outputParam.getValue();
                    // TODO: Oracle만 테스트, SQLServer, MySQL은 테스트 필요, 공통 타입으로 처리 불가시 dbcType에 따라 처리로 변경
                    switch (outputDataType) {
                        // 날짜 타입
                        case DT_DATE:
                            callStatement.registerOutParameter(linkParamOrders.get(outputParam.getKey()), Types.TIMESTAMP);
                            break;
                        // 숫자 타입
                        case DT_NUMBER:
                            callStatement.registerOutParameter(linkParamOrders.get(outputParam.getKey()), Types.DECIMAL);
                            break;
                        // 문자, 그외
                        default:
                            callStatement.registerOutParameter(linkParamOrders.get(outputParam.getKey()), Types.VARCHAR);
                            break;
                    }
                }

                List<Vector<Object>> linkErrorCdParams = (List<Vector<Object>>)remoteParamMaps.get("P_LINK_ERROR_CD_PARAMS");
                int linkErrorCdParamCount = linkErrorCdParams.size();
                List<Vector<Object>> linkErrorMsgParams = (List<Vector<Object>>)remoteParamMaps.get("P_LINK_ERROR_MSG_PARAMS");
                int linkErrorMsgParamCount = linkErrorMsgParams.size();
                String linkErrorMsgFormat = (String)remoteParamMaps.get("P_LINK_ERROR_MSG_FORMAT");
                for (int row = 0; row < sendDataCnt; row++) {
                    sendRow = lstSendData.get(row);

                    callStatement.clearParameters();
                    for (int i = 0; i < columnCnt; i++) {
                        vtColumn = columns.get(i);

                        columnNm = (String)vtColumn.get(0);
                        callStatement.setObject((int)vtColumn.get(2), sendRow.get(columnNm));
                    }
                    callStatement.executeUpdate();

                    // 정상 호출 여부 체크용 Output 파라메터 값 읽기
                    for (int cIndex = 0; cIndex < linkErrorCdParamCount; cIndex++) {
                        Vector<Object> errorCdColumn = linkErrorCdParams.get(cIndex);
                        // ERROR_CD 체크
                        if (!((String)errorCdColumn.get(2)).equals(callStatement.getString((int)errorCdColumn.get(1)))) {
                            oMsg = linkErrorMsgFormat;
                            // ERROR_MSG가 있을 경우 변환
                            if (linkErrorMsgParamCount > 0) {
                                for (int mIndex = 0; mIndex < linkErrorMsgParamCount; mIndex++) {
                                    Vector<Object> errorMsgColumn = linkErrorMsgParams.get(mIndex);
                                    oMsg = oMsg.replaceFirst("%s", Util.nullToDefault(callStatement.getString((int)errorMsgColumn.get(1)), "NULL"));
                                }
                            }
                            throw new RuntimeException(oMsg);
                        }
                    }
                }
                params.put("O_PROCESS_CNT", sendDataCnt);
            }
            // TABLE<INSERT> 방식
            else if (TABLE_INSERT.equals(remoteActionType)) {
                // BATCH 처리를 위한 Connection으로부터로부터 PreparedStatement 취득
                insertStatement = dbcDatasource.prepareStatement(insertSql);
                int sendSeq = 0;

                for (int row = 0; row < sendDataCnt; row++) {
                    sendRow = lstSendData.get(row);

                    for (int i = 0; i < columnCnt; i++) {
                        vtColumn = columns.get(i);

                        columnNm = (String)vtColumn.get(0);
                        insertStatement.setObject(1 + i, sendRow.get(columnNm));
                    }

                    sendSeq = row + 1;
                    // BATCH에 추가
                    insertStatement.addBatch();
                    // 파라메터 초기화
                    insertStatement.clearParameters();
                    // 1000건씩 처리
                    if (sendSeq % Consts.BULK_CNT == 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                }
                // 나머지 데이터가 있을 경우 처리
                if (sendSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", sendDataCnt);
            }
            // SCRIPT<CALL> 방식
            else {
                // BATCH 처리를 위한 Connection으로부터로부터 PreparedStatement 취득
                insertStatement = dbcDatasource.prepareStatement(insertSql);
                if (insertStatement.getParameterMetaData().getParameterCount() != columnCnt) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.118", "[사업부,송신구분,송신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n송신대상 컬럼수와 SCRIPT의 바인딩 변수(?)의 수가 다릅니다." //
                        + "\n컬럼 값이 입력될 변수를 정확히 지정하십시오.", new String[] {buCd, ediDiv, defineNo}));
                }
                int sendSeq = 0;

                for (int row = 0; row < sendDataCnt; row++) {
                    sendRow = lstSendData.get(row);

                    for (int i = 0; i < columnCnt; i++) {
                        vtColumn = columns.get(i);

                        columnNm = (String)vtColumn.get(0);
                        insertStatement.setObject(1 + i, sendRow.get(columnNm));
                    }

                    sendSeq = row + 1;
                    // BATCH에 추가
                    insertStatement.addBatch();
                    // 파라메터 초기화
                    insertStatement.clearParameters();
                    // 1000건씩 처리
                    if (sendSeq % Consts.BULK_CNT == 0) {
                        // BATCH 실행
                        insertStatement.executeBatch();
                        // BATCH 초기화
                        insertStatement.clearBatch();
                    }
                }
                // 나머지 데이터가 있을 경우 처리
                if (sendSeq % Consts.BULK_CNT != 0) {
                    // BATCH 실행
                    insertStatement.executeBatch();
                    // BATCH 초기화
                    insertStatement.clearBatch();
                }
                params.put("O_PROCESS_CNT", sendDataCnt);
            }

            // 3-1차 진행상태 UPDATE
            if (Util.isNotNull(tx3rdUpdateTable)) {
                // logger.debug("THIRD-1 UPDATE SQL: " + tx3rdUpdateText);
                callParams.clear();
                callParams.put("P_QUERY_TEXT", tx3rdUpdateText);
                callParams.put(Consts.PK_USER_ID, userId);
                resultMap = callProcedure(UPDATE_ID_DYNAMIC, callParams);
                oMsg = Util.getOutMessage(resultMap);
                if (!Consts.OK.equals(oMsg)) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "[사업부,송신구분,송신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\n송신 진행상태 업데이트 중 오류가 발생했습니다.\n" + oMsg, new String[] {buCd, ediDiv, defineNo}));
                }
            }

            // 3-2차 송신 대상 결과 UPDATE
            // logger.debug("THIRD-2 UPDATE SQL: " + es3rdUpdateText);
            callParams.clear();
            callParams.put("P_QUERY_TEXT", es3rdUpdateText);
            callParams.put(Consts.PK_USER_ID, userId);
            resultMap = callProcedure(UPDATE_ID_DYNAMIC, callParams);
            oMsg = Util.getOutMessage(resultMap);
            if (!Consts.OK.equals(oMsg)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신 대상 결과 업데이트 중 오류가 발생했습니다.\n" + oMsg, new String[] {buCd, ediDiv, defineNo}));
            }

            Util.setOutMessage(params, Consts.OK);
            resultMap.clear();
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            resultMap.clear();
            Util.setOutMessage(resultMap, errMessage);
        } finally {
            if (insertStatement != null) {
                try {
                    insertStatement.close();
                } catch (Exception e) {
                }
            }
            if (callStatement != null) {
                try {
                    callStatement.close();
                } catch (Exception e) {
                }
            }
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> sendDBLink(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = callESProcessingResult(params);
        String oMsg = Util.getOutMessage(resultMap);
        if (Consts.OK.equals(oMsg)) {
            resultMap.put("P_SEND_DATE", resultMap.get("O_SEND_DATE"));
            resultMap.put("P_SEND_NO", resultMap.get("O_SEND_NO"));
            Util.setOutMessage(params, Consts.OK);
        } else {
            Util.setOutMessage(params, oMsg);
        }

        return resultMap;
    }

    @Override
    public Map<String, Object> sendExcel(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        final String PK_SEND_FILE_FULL_NM = "O_SEND_FILE_FULL_NM";
        final String PK_BACKUP_FILE_FULL_NM = "O_BACKUP_FILE_FULL_NM";

        // 파일 생성 쿼리 파라메터 값 읽기
        String queryId = (String)params.get(Consts.PK_QUERY_ID);

        // 송신정의 상세내역 쿼리 파라메터 값 읽기
        String buCd = (String)params.get("P_BU_CD");
        String ediDiv = (String)params.get("P_EDI_DIV");
        String defineNo = (String)params.get("P_DEFINE_NO");

        // 송신정의 상세내역 데이터 쿼리
        List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
        if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.035", "[사업부,송신구분,송신정의번호: " //
                + buCd + "," + ediDiv + "," + defineNo //
                + "]\n송신정의 내역이 등록되어 있지 않습니다."));
        }

        // 나머지 파라메터 값 읽기
        String sendDate = (String)params.get("P_SEND_DATE");
        String sendNo = (String)params.get("P_SEND_NO");
        String prefixFileNm = (String)params.get("P_PREFIX_FILE_NM");
        // String fileDiv = (String)params.get("P_FILE_DIV");
        String userId = (String)params.get(Consts.PK_USER_ID);
        String ediFileRoot = getSendFileRootPath();
        String ediSendFullPath = Util.getPathName(ediFileRoot, ediDiv);

        String xlsVersion = NexosSupport.getGlobalProperty("XLS.VERSION", "xls"); // xls - 70 ~ 2003, xlsx - 2003 이후
        // 서버 파일명 지정
        String ediSendDatetime = Util.getNowDate("yyyyMMddHHmmss");
        String ediSendFileName = getSendFileName(prefixFileNm, userId, ediSendDatetime, buCd, ediDiv, defineNo, sendDate, sendNo, xlsVersion);
        String ediSendFileFullName = ediSendFullPath + ediSendFileName;
        String ediSendFileBackupPath = getBackupFilePath(ediSendFullPath, ediSendDatetime, ediDiv);
        String ediSendFileBackupFullName = ediSendFileBackupPath + ediSendFileName;

        // upload dir이 존재하지 않으면 생성
        Util.createDir(ediSendFullPath, ediSendFileBackupPath);

        int xlsCol;
        String xlsColumnNm = null;
        String xlsColumnTitleNm = null;
        String columnNm = null;
        String dataType = null;

        // 실제 정의한 컬럼만 추출
        Vector<Object> vtColumn;
        Map<String, Object> defineInfo = null;
        int columnCount = lstDefineInfo.size();
        ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();
        for (int i = 0; i < columnCount; i++) {
            defineInfo = lstDefineInfo.get(i);
            try {
                columnNm = (String)defineInfo.get("COLUMN_NM");
                dataType = (String)defineInfo.get("DATA_TYPE");
                xlsColumnNm = (String)defineInfo.get("XLS_COLUMN_NM");
                xlsColumnTitleNm = Util.nullToDefault(defineInfo.get("XLS_COLUMN_TITLE_NM"), columnNm);

                if (Util.isNotNull(xlsColumnNm) && Util.isNotNull(columnNm)) {
                    vtColumn = new Vector<Object>();
                    vtColumn.add(columnNm);
                    if (dataType == null) {
                        dataType = "1"; // Null이면 문자
                    }
                    vtColumn.add(dataType);
                    vtColumn.add(xlsColumnNm);
                    vtColumn.add(getXLSColumnIndex(xlsColumnNm));
                    vtColumn.add(xlsColumnTitleNm);
                    columns.add(vtColumn);
                }
            } catch (Exception e) {
            }
        }
        columnCount = columns.size();
        if (columnCount == 0) {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.040", "[사업부,송신구분,송신정의번호: " //
                + buCd + "," + ediDiv + "," + defineNo //
                + "]\n송신정의 컬럼 중 처리 가능한 컬럼이 없습니다."));
        }

        // 송신정의 상세내역 데이터 쿼리
        List<Map<String, Object>> list = getDataList(queryId, params);
        if (list == null || list.size() == 0) {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.119", "[사업부,송신구분,송신정의번호,송신일자,송신번호: " //
                + buCd + "," + ediDiv + "," + defineNo + "," + sendDate + "," + sendNo //
                + "]\n송신할 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo, sendDate, sendNo}));
        }

        // 엑셀 관련 상수
        final String XLS_FONT_NM = "굴림체";
        final short XLS_FONT_SIZE = 9 * 20;
        final short XLS_ROW_HEIGHT = 18 * 20;

        SimpleDateFormat stringDateFormat = new SimpleDateFormat(Consts.DATE_FORMAT);
        SimpleDateFormat stringDatetimeFormat = new SimpleDateFormat(Consts.DATETIME_FORMAT);

        // 엑셀 관련 Object 생성
        FileOutputStream xlsFile = null;

        if ("xlsx".equals(xlsVersion)) {
            XSSFWorkbook xlsxWorkbook = new XSSFWorkbook();
            XSSFSheet xlsxSheet = null;

            XSSFDataFormat xlsDataFormat = xlsxWorkbook.createDataFormat();
            // Header Font
            XSSFFont xlsHeaderFont = xlsxWorkbook.createFont();
            xlsHeaderFont.setFontName(XLS_FONT_NM);
            xlsHeaderFont.setBold(true);
            xlsHeaderFont.setFontHeight(XLS_FONT_SIZE);
            xlsHeaderFont.setColor(HSSFColorPredefined.DARK_BLUE.getIndex());

            // Header Cell
            XSSFCellStyle xlsHeaderCell = xlsxWorkbook.createCellStyle();
            xlsHeaderCell.setBorderLeft(BorderStyle.THIN);
            xlsHeaderCell.setBorderRight(BorderStyle.THIN);
            xlsHeaderCell.setBorderTop(BorderStyle.THIN);
            xlsHeaderCell.setBorderBottom(BorderStyle.THIN);
            xlsHeaderCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setFillForegroundColor(HSSFColorPredefined.PALE_BLUE.getIndex());
            xlsHeaderCell.setFillPattern(FillPatternType.SOLID_FOREGROUND);
            xlsHeaderCell.setFont(xlsHeaderFont);
            xlsHeaderCell.setAlignment(HorizontalAlignment.CENTER);
            xlsHeaderCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsHeaderCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("text"));

            // Data Cell Font
            XSSFFont xlsCellFont = xlsxWorkbook.createFont();
            xlsCellFont.setFontName(XLS_FONT_NM);
            xlsCellFont.setFontHeight(XLS_FONT_SIZE);

            // Default Cell Style
            XSSFCellStyle xlsDefaultCell = xlsxWorkbook.createCellStyle();
            xlsDefaultCell.setFont(xlsCellFont);
            xlsDefaultCell.setAlignment(HorizontalAlignment.LEFT);
            xlsDefaultCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsDefaultCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("General"));

            // String Cell
            XSSFCellStyle xlsStringCell = xlsxWorkbook.createCellStyle();
            xlsStringCell.setBorderLeft(BorderStyle.THIN);
            xlsStringCell.setBorderRight(BorderStyle.THIN);
            xlsStringCell.setBorderTop(BorderStyle.THIN);
            xlsStringCell.setBorderBottom(BorderStyle.THIN);
            xlsStringCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setFont(xlsCellFont);
            xlsStringCell.setAlignment(HorizontalAlignment.LEFT);
            xlsStringCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsStringCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("text"));

            // Number Cell
            XSSFCellStyle xlsNumberCell = xlsxWorkbook.createCellStyle();
            xlsNumberCell.setBorderLeft(BorderStyle.THIN);
            xlsNumberCell.setBorderRight(BorderStyle.THIN);
            xlsNumberCell.setBorderTop(BorderStyle.THIN);
            xlsNumberCell.setBorderBottom(BorderStyle.THIN);
            xlsNumberCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setFont(xlsCellFont);
            xlsNumberCell.setAlignment(HorizontalAlignment.RIGHT);
            xlsNumberCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsNumberCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("#,##0"));

            // Date Cell
            XSSFCellStyle xlsDateCell = xlsxWorkbook.createCellStyle();
            xlsDateCell.setBorderLeft(BorderStyle.THIN);
            xlsDateCell.setBorderRight(BorderStyle.THIN);
            xlsDateCell.setBorderTop(BorderStyle.THIN);
            xlsDateCell.setBorderBottom(BorderStyle.THIN);
            xlsDateCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setFont(xlsCellFont);
            xlsDateCell.setAlignment(HorizontalAlignment.RIGHT);
            xlsDateCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsDateCell.setDataFormat(xlsDataFormat.getFormat("yyyy-mm-dd hh:mm:ss"));

            // 현재 Row
            int currentRow = 0;
            // 현재 Sheet
            // int currentSheet = 1;

            params.put("O_PROCESS_CNT", list.size());
            Iterator<Map<String, Object>> iterator = list.iterator();
            Map<String, Object> rowData = null;
            XSSFRow xlsRow = null;
            XSSFCell xlsCell = null;
            try {
                xlsFile = new FileOutputStream(ediSendFileFullName);
                xlsxSheet = xlsxWorkbook.createSheet("SEND_" + ediDiv);

                while (iterator.hasNext()) {
                    rowData = iterator.next();

                    // Row가 0이면 컬럼헤더 정보 생성
                    if (currentRow == 0) {
                        // 첫번째 Sheet에서만 컬럼 헤더 정보 생성
                        xlsRow = xlsxSheet.createRow(currentRow);
                        xlsRow.setHeight(XLS_ROW_HEIGHT);
                        for (int col = 0; col < columnCount; col++) {
                            vtColumn = columns.get(col);

                            columnNm = (String)vtColumn.get(0);
                            xlsColumnNm = (String)vtColumn.get(2);
                            xlsCol = (Integer)vtColumn.get(3);
                            xlsColumnTitleNm = (String)vtColumn.get(4);

                            xlsxSheet.setDefaultColumnStyle(col, xlsDefaultCell);

                            xlsCell = xlsRow.createCell(xlsCol);
                            xlsCell.setCellStyle(xlsHeaderCell);
                            xlsCell.setCellValue(new HSSFRichTextString(xlsColumnTitleNm));

                            xlsxSheet.setColumnWidth(col, Util.getXLSColumnWidth(xlsColumnTitleNm));
                        }
                        currentRow = 1;
                    }

                    // Row 기록
                    xlsRow = xlsxSheet.createRow(currentRow);
                    xlsRow.setHeight(XLS_ROW_HEIGHT);
                    for (int col = 0; col < columnCount; col++) {
                        vtColumn = columns.get(col);

                        columnNm = (String)vtColumn.get(0);
                        dataType = (String)vtColumn.get(1);
                        xlsCol = (Integer)vtColumn.get(3);
                        Object columnValue = rowData.get(columnNm);

                        xlsCell = xlsRow.createCell(xlsCol);
                        try {
                            if (DT_DATE.equals(dataType)) {
                                xlsCell.setCellStyle(xlsDateCell);
                                if (columnValue == null) {
                                    continue;
                                }

                                String value = (String)columnValue;
                                if (value.length() == 10) {
                                    xlsCell.setCellValue(stringDateFormat.parse(value));
                                } else {
                                    xlsCell.setCellValue(stringDatetimeFormat.parse(value));
                                }

                            } else if (DT_NUMBER.equals(dataType)) {
                                xlsCell.setCellStyle(xlsNumberCell);
                                if (columnValue == null) {
                                    continue;
                                }

                                xlsCell.setCellValue(Double.valueOf((String)columnValue));

                            } else {
                                xlsCell.setCellStyle(xlsStringCell);
                                if (columnValue == null) {
                                    continue;
                                }

                                xlsCell.setCellValue(new HSSFRichTextString((String)columnValue));
                            }
                        } catch (Exception e) {
                            Util.writeErrorMessage(e);
                            xlsCell.setCellStyle(xlsStringCell);
                            xlsCell.setCellValue(new HSSFRichTextString(""));
                        }
                    }

                    // RowCount 증가
                    currentRow++;

                    // Sheet분할
                    // if (currentRow == XLS_MAX_ROW) {
                    // // Row 수 초기화
                    // currentRow = 0;
                    // // 새로운 Sheet만들기
                    // currentSheet++;
                    // xlsSheet = xlsWorkbook.createSheet("SEND_" + ediDiv + " (" + currentSheet + ")");
                    // }
                }

                // Excel 쓰기
                xlsxWorkbook.write(xlsFile);
                resultMap.put(PK_SEND_FILE_FULL_NM, ediSendFileFullName);
                resultMap.put(PK_BACKUP_FILE_FULL_NM, ediSendFileBackupFullName);
                Util.setOutMessage(resultMap, Consts.OK);
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                xlsxSheet = null;
                Util.closeObject(xlsxWorkbook);
                Util.closeObject(xlsFile);
            }
        } else {
            // 엑셀 관련 상수
            final int XLS_MAX_ROW = 65001;

            // 엑셀 관련 Object 생성
            HSSFWorkbook xlsWorkbook = new HSSFWorkbook();
            HSSFSheet xlsSheet = null;

            HSSFDataFormat xlsDataFormat = xlsWorkbook.createDataFormat();
            // Header Font
            HSSFFont xlsHeaderFont = xlsWorkbook.createFont();
            xlsHeaderFont.setFontName(XLS_FONT_NM);
            xlsHeaderFont.setBold(true);
            xlsHeaderFont.setFontHeight(XLS_FONT_SIZE);
            xlsHeaderFont.setColor(HSSFColorPredefined.DARK_BLUE.getIndex());

            // Header Cell
            HSSFCellStyle xlsHeaderCell = xlsWorkbook.createCellStyle();
            xlsHeaderCell.setBorderLeft(BorderStyle.THIN);
            xlsHeaderCell.setBorderRight(BorderStyle.THIN);
            xlsHeaderCell.setBorderTop(BorderStyle.THIN);
            xlsHeaderCell.setBorderBottom(BorderStyle.THIN);
            xlsHeaderCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsHeaderCell.setFillForegroundColor(HSSFColorPredefined.PALE_BLUE.getIndex());
            xlsHeaderCell.setFillPattern(FillPatternType.SOLID_FOREGROUND);
            xlsHeaderCell.setFont(xlsHeaderFont);
            xlsHeaderCell.setAlignment(HorizontalAlignment.CENTER);
            xlsHeaderCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsHeaderCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("text"));

            // Data Cell Font
            HSSFFont xlsCellFont = xlsWorkbook.createFont();
            xlsCellFont.setFontName(XLS_FONT_NM);
            xlsCellFont.setFontHeight(XLS_FONT_SIZE);

            // Default Cell Style
            HSSFCellStyle xlsDefaultCell = xlsWorkbook.createCellStyle();
            xlsDefaultCell.setFont(xlsCellFont);
            xlsDefaultCell.setAlignment(HorizontalAlignment.LEFT);
            xlsDefaultCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsDefaultCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("General"));

            // String Cell
            HSSFCellStyle xlsStringCell = xlsWorkbook.createCellStyle();
            xlsStringCell.setBorderLeft(BorderStyle.THIN);
            xlsStringCell.setBorderRight(BorderStyle.THIN);
            xlsStringCell.setBorderTop(BorderStyle.THIN);
            xlsStringCell.setBorderBottom(BorderStyle.THIN);
            xlsStringCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsStringCell.setFont(xlsCellFont);
            xlsStringCell.setAlignment(HorizontalAlignment.LEFT);
            xlsStringCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsStringCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("text"));

            // Number Cell
            HSSFCellStyle xlsNumberCell = xlsWorkbook.createCellStyle();
            xlsNumberCell.setBorderLeft(BorderStyle.THIN);
            xlsNumberCell.setBorderRight(BorderStyle.THIN);
            xlsNumberCell.setBorderTop(BorderStyle.THIN);
            xlsNumberCell.setBorderBottom(BorderStyle.THIN);
            xlsNumberCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsNumberCell.setFont(xlsCellFont);
            xlsNumberCell.setAlignment(HorizontalAlignment.RIGHT);
            xlsNumberCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsNumberCell.setDataFormat(HSSFDataFormat.getBuiltinFormat("#,##0"));

            // Date Cell
            HSSFCellStyle xlsDateCell = xlsWorkbook.createCellStyle();
            xlsDateCell.setBorderLeft(BorderStyle.THIN);
            xlsDateCell.setBorderRight(BorderStyle.THIN);
            xlsDateCell.setBorderTop(BorderStyle.THIN);
            xlsDateCell.setBorderBottom(BorderStyle.THIN);
            xlsDateCell.setLeftBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setRightBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setTopBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setBottomBorderColor(HSSFColorPredefined.BLACK.getIndex());
            xlsDateCell.setFont(xlsCellFont);
            xlsDateCell.setAlignment(HorizontalAlignment.RIGHT);
            xlsDateCell.setVerticalAlignment(VerticalAlignment.CENTER);
            xlsDateCell.setDataFormat(xlsDataFormat.getFormat("yyyy-mm-dd hh:mm:ss"));

            // 현재 Row
            int currentRow = 0;
            // 현재 Sheet
            int currentSheet = 1;

            params.put("O_PROCESS_CNT", list.size());
            Iterator<Map<String, Object>> iterator = list.iterator();
            Map<String, Object> rowData = null;
            HSSFRow xlsRow = null;
            HSSFCell xlsCell = null;
            try {
                xlsFile = new FileOutputStream(ediSendFileFullName);
                xlsSheet = xlsWorkbook.createSheet("SEND_" + ediDiv + " (1)");

                while (iterator.hasNext()) {
                    rowData = iterator.next();

                    // Row가 0이면 컬럼헤더 정보 생성
                    if (currentRow == 0) {
                        // 첫번째 Sheet에서만 컬럼 헤더 정보 생성
                        xlsRow = xlsSheet.createRow(currentRow);
                        xlsRow.setHeight(XLS_ROW_HEIGHT);
                        for (int col = 0; col < columnCount; col++) {
                            vtColumn = columns.get(col);

                            columnNm = (String)vtColumn.get(0);
                            xlsColumnNm = (String)vtColumn.get(2);
                            xlsCol = (Integer)vtColumn.get(3);
                            xlsColumnTitleNm = (String)vtColumn.get(4);

                            xlsSheet.setDefaultColumnStyle(col, xlsDefaultCell);

                            xlsCell = xlsRow.createCell(xlsCol);
                            xlsCell.setCellStyle(xlsHeaderCell);
                            xlsCell.setCellValue(new HSSFRichTextString(xlsColumnTitleNm));

                            xlsSheet.setColumnWidth(col, Util.getXLSColumnWidth(xlsColumnTitleNm));
                        }
                        currentRow = 1;
                    }

                    // Row 기록
                    xlsRow = xlsSheet.createRow(currentRow);
                    xlsRow.setHeight(XLS_ROW_HEIGHT);
                    for (int col = 0; col < columnCount; col++) {
                        vtColumn = columns.get(col);

                        columnNm = (String)vtColumn.get(0);
                        dataType = (String)vtColumn.get(1);
                        xlsCol = (Integer)vtColumn.get(3);
                        Object columnValue = rowData.get(columnNm);

                        xlsCell = xlsRow.createCell(xlsCol);
                        try {
                            if (DT_DATE.equals(dataType)) {
                                xlsCell.setCellStyle(xlsDateCell);
                                if (columnValue == null) {
                                    continue;
                                }

                                String value = (String)columnValue;
                                if (value.length() == 10) {
                                    xlsCell.setCellValue(stringDateFormat.parse(value));
                                } else {
                                    xlsCell.setCellValue(stringDatetimeFormat.parse(value));
                                }

                            } else if (DT_NUMBER.equals(dataType)) {
                                xlsCell.setCellStyle(xlsNumberCell);
                                if (columnValue == null) {
                                    continue;
                                }

                                xlsCell.setCellValue(Double.valueOf((String)columnValue));

                            } else {
                                xlsCell.setCellStyle(xlsStringCell);
                                if (columnValue == null) {
                                    continue;
                                }

                                xlsCell.setCellValue(new HSSFRichTextString((String)columnValue));
                            }
                        } catch (Exception e) {
                            Util.writeErrorMessage(e);
                            xlsCell.setCellStyle(xlsStringCell);
                            xlsCell.setCellValue(new HSSFRichTextString(""));
                        }
                    }

                    // RowCount 증가
                    currentRow++;

                    // Sheet분할
                    if (currentRow == XLS_MAX_ROW) {
                        // Row 수 초기화
                        currentRow = 0;
                        // 새로운 Sheet만들기
                        currentSheet++;
                        xlsSheet = xlsWorkbook.createSheet("SEND_" + ediDiv + " (" + currentSheet + ")");
                    }
                }

                // Excel 쓰기
                xlsWorkbook.write(xlsFile);
                resultMap.put(PK_SEND_FILE_FULL_NM, ediSendFileFullName);
                resultMap.put(PK_BACKUP_FILE_FULL_NM, ediSendFileBackupFullName);
                Util.setOutMessage(resultMap, Consts.OK);
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                xlsSheet = null;
                Util.closeObject(xlsWorkbook);
                Util.closeObject(xlsFile);
            }
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> sendText(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        final String PK_SEND_FILE_FULL_NM = "O_SEND_FILE_FULL_NM";
        final String PK_BACKUP_FILE_FULL_NM = "O_BACKUP_FILE_FULL_NM";

        // edi dir로 파일 생성
        FileOutputStream txtFileOutput = null;
        OutputStreamWriter txtFileOutputWriter = null;
        BufferedWriter txtFileWriter = null;
        try {
            // 파일 생성 쿼리 파라메터 값 읽기
            String queryId = (String)params.get(Consts.PK_QUERY_ID);

            // 송신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");
            String sendDate = (String)params.get("P_SEND_DATE");
            String sendNo = (String)params.get("P_SEND_NO");
            String prefixFileNm = (String)params.get("P_PREFIX_FILE_NM");
            String fileDiv = (String)params.get("P_FILE_DIV");

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.035", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 내역이 등록되어 있지 않습니다."));
            }

            // 나머지 파라메터 값 읽기
            String userId = (String)params.get(Consts.PK_USER_ID);
            String ediFileRoot = getSendFileRootPath();
            String ediSendFullPath = Util.getPathName(ediFileRoot, ediDiv);

            // 서버 파일명 지정
            String ediSendDatetime = Util.getNowDate("yyyyMMddHHmmss");
            String ediSendFileName = getSendFileName(prefixFileNm, userId, ediSendDatetime, buCd, ediDiv, defineNo, sendDate, sendNo, "txt");
            String ediSendFileFullName = ediSendFullPath + ediSendFileName;
            String ediSendFileBackupPath = getBackupFilePath(ediSendFullPath, ediSendDatetime, ediDiv);
            String ediSendFileBackupFullName = ediSendFileBackupPath + ediSendFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediSendFullPath, ediSendFileBackupPath);

            // 송신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            String txtDelimeterYn = (String)defineInfo.get("TXT_DELIMETER_YN");
            String txtColDelimeter = (String)defineInfo.get("TXT_COL_DELIMETER");
            String txtCharset = Util.nullToDefault(defineInfo.get("REMOTE_CHARSET"), Consts.CHARSET);

            if (Consts.YES.equals(txtDelimeterYn) && Util.isNull(txtColDelimeter)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.120", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n텍스트 컬럼 구분자가 지정되지 않았습니다.", new String[] {buCd, ediDiv, defineNo}));
            }

            int txtPosition = -1;
            int txtLength = -1;
            String columnNm = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCount = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            for (int i = 0; i < columnCount; i++) {
                defineInfo = lstDefineInfo.get(i);

                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    txtPosition = ((Number)defineInfo.get("TXT_POSITION")).intValue();
                    txtLength = ((Number)defineInfo.get("TXT_LENGTH")).intValue();

                    if (txtPosition > -1 && txtLength > 0 && Util.isNotNull(columnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add(columnNm);
                        vtColumn.add(txtPosition);
                        vtColumn.add(txtLength);
                        columns.add(vtColumn);
                    }
                } catch (Exception e) {
                }
            }
            columnCount = columns.size();
            if (columnCount == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.040", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 컬럼 중 처리 가능한 컬럼이 없습니다."));
            }
            // 컬럼정보를 Position으로 재정렬
            Collections.sort(columns, this);

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> list = getDataList(queryId, params);
            if (list == null || list.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.121", "[사업부,송신구분,송신정의번호,송신일자,송신번호: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + sendDate + "," + sendNo //
                    + "]\n송신할 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo, sendDate, sendNo}));
            }

            txtFileOutput = new FileOutputStream(ediSendFileFullName);
            txtFileOutputWriter = new OutputStreamWriter(txtFileOutput, txtCharset);
            txtFileWriter = new BufferedWriter(txtFileOutputWriter);

            int listCnt = list.size();
            params.put("O_PROCESS_CNT", listCnt);
            Map<String, Object> rowData;
            StringBuffer sbWriteBuffer = new StringBuffer();
            byte[] txtLineBytes = null;

            // 컬럼 구분자로 처리일 경우
            if (Consts.YES.equals(txtDelimeterYn)) {
                for (int row = 0; row < listCnt; row++) {
                    rowData = list.get(row);
                    sbWriteBuffer.setLength(0);
                    for (int col = 0; col < columnCount; col++) {
                        vtColumn = columns.get(col);

                        columnNm = (String)vtColumn.get(0);
                        txtPosition = (Integer)vtColumn.get(1);
                        txtLength = (Integer)vtColumn.get(2);

                        columnVal = (String)rowData.get(columnNm);

                        if (columnVal != null) {
                            txtLineBytes = columnVal.getBytes(Consts.KR_CHARSET);
                            sbWriteBuffer.append(new String(txtLineBytes, 0, Math.min(txtLineBytes.length, txtLength), Consts.KR_CHARSET));
                        }
                        sbWriteBuffer.append(txtColDelimeter);
                    }
                    if (sbWriteBuffer.length() > 0) {
                        sbWriteBuffer.delete(sbWriteBuffer.length() - txtColDelimeter.length(), sbWriteBuffer.length());
                    }
                    txtFileWriter.write(sbWriteBuffer.toString());
                    txtFileWriter.write(Consts.CRLF);
                }
            }
            // 위치/길이로 처리
            else {
                for (int row = 0; row < listCnt; row++) {
                    rowData = list.get(row);
                    sbWriteBuffer.setLength(0);
                    for (int col = 0; col < columnCount; col++) {
                        vtColumn = columns.get(col);

                        columnNm = (String)vtColumn.get(0);
                        txtPosition = (Integer)vtColumn.get(1);
                        txtLength = (Integer)vtColumn.get(2);

                        columnVal = (String)rowData.get(columnNm);

                        if (columnVal == null) {
                            txtLineBytes = new byte[1];
                            txtLineBytes[0] = 32;
                        } else {
                            txtLineBytes = columnVal.getBytes(Consts.KR_CHARSET);
                        }
                        if (txtLineBytes.length > txtLength) {
                            sbWriteBuffer.append(new String(txtLineBytes, 0, txtLength, Consts.KR_CHARSET));
                        } else {
                            byte[] newTxtLineBytes = new byte[txtLength];
                            System.arraycopy(txtLineBytes, 0, newTxtLineBytes, 0, txtLineBytes.length);
                            for (int i = txtLineBytes.length; i < txtLength; i++) {
                                newTxtLineBytes[i] = 32;
                            }
                            sbWriteBuffer.append(new String(newTxtLineBytes, 0, txtLength, Consts.KR_CHARSET));
                        }
                    }
                    txtFileWriter.write(sbWriteBuffer.toString());
                    txtFileWriter.write(Consts.CRLF);
                }
            }

            if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                FileInputStream txtFileInput = null;
                InputStreamReader txtFileInputReader = null;
                BufferedReader txtFileReader = null;
                StringBuffer txtBuffer = new StringBuffer();
                try {
                    txtFileInput = new FileInputStream(ediSendFileFullName);
                    txtFileInputReader = new InputStreamReader(txtFileInput, txtCharset);
                    txtFileReader = new BufferedReader(txtFileInputReader);

                    String txtLine = null;
                    while ((txtLine = txtFileReader.readLine()) != null) {
                        txtBuffer.append(txtLine).append(Consts.CRLF);
                    }
                } catch (Exception e) {
                    Util.writeErrorMessage(e);
                } finally {
                    Util.closeObject(txtFileReader);
                    Util.closeObject(txtFileInputReader);
                    Util.closeObject(txtFileInput);
                }
                resultMap.put("O_DOCUMENT", txtBuffer.toString());
            }

            resultMap.put(PK_SEND_FILE_FULL_NM, ediSendFileFullName);
            resultMap.put(PK_BACKUP_FILE_FULL_NM, ediSendFileBackupFullName);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            Util.setOutMessage(resultMap, Util.getErrorMessage(e));
        } finally {
            Util.closeObject(txtFileWriter);
            Util.closeObject(txtFileOutputWriter);
            Util.closeObject(txtFileOutput);
        }
        return resultMap;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Map<String, Object> sendXML(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        final String PK_SEND_FILE_FULL_NM = "O_SEND_FILE_FULL_NM";
        final String PK_BACKUP_FILE_FULL_NM = "O_BACKUP_FILE_FULL_NM";
        final String PK_DOCUMENT = "O_DOCUMENT";
        final String PK_WEBSERVICE_URL = "O_WEBSERVICE_URL";
        final String PK_WEBSERVICE_METHOD = "O_WEBSERVICE_METHOD";

        // edi dir로 파일 생성
        FileOutputStream xmlFileOutput = null;
        OutputStreamWriter xmlFileOutputWriter = null;
        BufferedWriter xmlFileWriter = null;
        try {
            // 송신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.035", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 내역이 등록되어 있지 않습니다."));
            }

            // 송신정의 상세내역 쿼리 파라메터 값 읽기
            String sendDate = (String)params.get("P_SEND_DATE");
            String sendNo = (String)params.get("P_SEND_NO");
            String prefixFileNm = (String)params.get("P_PREFIX_FILE_NM");
            String fileDiv = (String)params.get("P_FILE_DIV");
            Map<String, Object> xmlResultInfo = (Map<String, Object>)params.get("P_XML_RESULT_INFO");
            String queryId = (String)params.get(Consts.PK_QUERY_ID); // 파일 생성 쿼리 파라메터 값 읽기
            String userId = (String)params.get(Consts.PK_USER_ID);
            String webServiceUrl = Util.nullToDefault(params.get("P_WEBSERVICE_URL"), "");
            String webServiceMethod = Util.nullToDefault(params.get("P_WEBSERVICE_METHOD"), "");
            String ediFileRoot = getSendFileRootPath();
            String ediSendFullPath = Util.getPathName(ediFileRoot, ediDiv);

            // 서버 파일명 지정
            String ediSendDatetime = Util.getNowDate("yyyyMMddHHmmss");
            String ediSendFileName = getSendFileName(prefixFileNm, userId, ediSendDatetime, buCd, ediDiv, defineNo, sendDate, sendNo, "xml");
            String ediSendFileFullName = ediSendFullPath + ediSendFileName;
            String ediSendFileBackupPath = getBackupFilePath(ediSendFullPath, ediSendDatetime, ediDiv);
            String ediSendFileBackupFullName = ediSendFileBackupPath + ediSendFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediSendFullPath, ediSendFileBackupPath);

            // 송신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            String xmlTagRoot = (String)defineInfo.get("XML_TAG_ROOT");
            String xmlTagBunch = (String)defineInfo.get("XML_TAG_BUNCH");
            String xmlTagSubBunch = (String)defineInfo.get("XML_TAG_SUB_BUNCH");

            String xmlTagResult = (String)xmlResultInfo.get("P_TAG_RESULT");
            if (Util.isNotNull(xmlTagResult)) {
                String messageCd = (String)xmlResultInfo.get("P_RESULT_CD_SUCCESS");
                xmlTagResult = xmlTagResult.replace("#RESULT_CD#", messageCd).replace("#RESULT_MSG#", Consts.OK);
            }

            if (Util.isNull(xmlTagRoot)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.122", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\nXML 루트태그가 정의되지 않았습니다.", new String[] {buCd, ediDiv, defineNo}));
            }
            if (Util.isNull(xmlTagBunch) && Util.isNull(xmlTagSubBunch)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.123", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\nXML 단위태그가 정의되지 않았습니다.", new String[] {buCd, ediDiv, defineNo}));
            }
            boolean writeDetailToRoot = false;
            if (Util.isNotNull(xmlTagSubBunch)) {
                if (xmlTagBunch.indexOf("#DETAIL_DATA#") == -1) {
                    if (xmlTagRoot.indexOf("#DETAIL_DATA#") != -1) {
                        writeDetailToRoot = true;
                    } else {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.124", "[사업부,송신구분,송신정의번호: " //
                            + buCd + "," + ediDiv + "," + defineNo //
                            + "]\nXML 단위 태그에 #DETAIL_DATA#에 대한 정의가 되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
                    }
                }
            } else {
                if (xmlTagRoot.indexOf("#MASTER_DATA#") == -1) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.125", "[사업부,송신구분,송신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\nXML 루트 태그에 #MASTER_DATA#에 대한 정의가 되어 있지 않습니다.", new String[] {buCd, ediDiv, defineNo}));
                }
            }

            // 기본 Tag에 SQL 호출 값 변경
            // SQL#[SQL문]# -> SQL문 실행 후 결과 입력
            xmlTagRoot = replaceSQLText(xmlTagRoot);
            xmlTagBunch = replaceSQLText(xmlTagBunch);
            xmlTagSubBunch = replaceSQLText(xmlTagSubBunch);

            String columnNm = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCount = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            for (int i = 0; i < columnCount; i++) {
                defineInfo = lstDefineInfo.get(i);
                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");

                    if (Util.isNotNull(columnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add(columnNm);
                        columns.add(vtColumn);
                    }
                } catch (Exception e) {
                }
            }
            columnCount = columns.size();
            if (columnCount == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.040", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 컬럼 중 처리 가능한 컬럼이 없습니다."));
            }

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> list = getDataList(queryId, params);
            if (list == null || list.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.119", "[사업부,송신구분,송신정의번호,송신일자,송신번호: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + sendDate + "," + sendNo //
                    + "]\n송신할 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo, sendDate, sendNo}));
            }

            xmlFileOutput = new FileOutputStream(ediSendFileFullName);
            xmlFileOutputWriter = new OutputStreamWriter(xmlFileOutput);
            xmlFileWriter = new BufferedWriter(xmlFileOutputWriter);

            int listCnt = list.size();
            params.put("O_PROCESS_CNT", listCnt);
            Map<String, Object> rowData;

            String xmlCurrTagRoot = xmlTagRoot;
            String xmlCurrTagBunch = xmlTagBunch;
            String xmlCurrTagSubBunch = xmlTagSubBunch;
            ArrayList<String> xmlCurrTagBunchList = new ArrayList<String>();
            StringBuffer sbWriteBuffer = new StringBuffer();
            int bunchCount;

            // 마스터 형태로 구성된 데이터 처리
            if (xmlTagSubBunch == null) {
                for (int row = 0; row < listCnt; row++) {
                    rowData = list.get(row);

                    xmlCurrTagBunch = xmlTagBunch;
                    for (int col = 0; col < columnCount; col++) {
                        vtColumn = columns.get(col);

                        columnNm = (String)vtColumn.get(0);
                        columnVal = (String)rowData.get(columnNm);
                        if (columnVal == null) {
                            columnVal = "";
                        }
                        columnNm = "#" + columnNm + "#";
                        xmlCurrTagBunch = xmlCurrTagBunch.replace(columnNm, columnVal);
                        xmlCurrTagRoot = xmlCurrTagRoot.replace(columnNm, columnVal);

                        if (!"".equals(columnVal)) {
                            webServiceUrl = webServiceUrl.replace(columnNm, columnVal);
                            webServiceMethod = webServiceMethod.replace(columnNm, columnVal);
                        }
                    }
                    xmlCurrTagBunchList.add(xmlCurrTagBunch);
                }

                sbWriteBuffer.setLength(0);
                bunchCount = xmlCurrTagBunchList.size();
                if (bunchCount > 0) {
                    for (int i = 0; i < bunchCount; i++) {
                        sbWriteBuffer.append(xmlCurrTagBunchList.get(i)).append(Consts.CRLF);
                    }
                    xmlCurrTagBunchList.clear();
                    xmlCurrTagRoot = xmlCurrTagRoot.replace("#MASTER_DATA#", sbWriteBuffer.toString());
                }
                if (Util.isNotNull(xmlTagResult)) {
                    xmlCurrTagRoot = xmlCurrTagRoot.replace("#RESULT_DATA#", xmlTagResult);
                }
                sbWriteBuffer.setLength(0);
            }
            // 마스터/디테일 형태로 구성된 데이터 처리
            else {
                ArrayList<String> xmlCurrTagSubBunchList = new ArrayList<String>();
                // 마스터, 디테일이 별도로 루트에 포함되어 있는 경우
                if (writeDetailToRoot) {

                    for (int row = 0; row < listCnt; row++) {
                        rowData = list.get(row);

                        boolean mdTypeM = "M".equals(rowData.get("MD_TYPE"));
                        // 마스터 데이터일 경우 마스터 입력 태그 기본값으로 초기화, 전표별 첫 데이터
                        if (mdTypeM) {
                            xmlCurrTagBunch = xmlTagBunch;
                        }

                        // 디테일 입력 태그 기본값으로 초기화
                        xmlCurrTagSubBunch = xmlTagSubBunch;
                        for (int col = 0; col < columnCount; col++) {
                            vtColumn = columns.get(col);

                            columnNm = (String)vtColumn.get(0);
                            columnVal = (String)rowData.get(columnNm);
                            if (columnVal == null) {
                                columnVal = "";
                            }
                            columnNm = "#" + columnNm + "#";
                            xmlCurrTagBunch = xmlCurrTagBunch.replace(columnNm, columnVal);
                            xmlCurrTagSubBunch = xmlCurrTagSubBunch.replace(columnNm, columnVal);
                            xmlCurrTagRoot = xmlCurrTagRoot.replace(columnNm, columnVal);

                            if (!"".equals(columnVal)) {
                                webServiceUrl = webServiceUrl.replace(columnNm, columnVal);
                                webServiceMethod = webServiceMethod.replace(columnNm, columnVal);
                            }
                        }
                        if (mdTypeM) {
                            xmlCurrTagBunchList.add(xmlCurrTagBunch);
                        }
                        xmlCurrTagSubBunchList.add(xmlCurrTagSubBunch);
                    }

                    // 마스터 변경
                    sbWriteBuffer.setLength(0);
                    bunchCount = xmlCurrTagBunchList.size();
                    if (bunchCount > 0) {
                        for (int i = 0; i < bunchCount; i++) {
                            sbWriteBuffer.append(xmlCurrTagBunchList.get(i)).append(Consts.CRLF);
                        }
                        xmlCurrTagBunchList.clear();
                        xmlCurrTagRoot = xmlCurrTagRoot.replace("#MASTER_DATA#", sbWriteBuffer.toString());
                    }

                    // 디테일 변경
                    sbWriteBuffer.setLength(0);
                    bunchCount = xmlCurrTagSubBunchList.size();
                    if (bunchCount > 0) {
                        for (int i = 0; i < bunchCount; i++) {
                            sbWriteBuffer.append(xmlCurrTagSubBunchList.get(i)).append(Consts.CRLF);
                        }
                        xmlCurrTagSubBunchList.clear();
                        xmlCurrTagRoot = xmlCurrTagRoot.replace("#DETAIL_DATA#", sbWriteBuffer.toString());
                    }
                    if (Util.isNotNull(xmlTagResult)) {
                        xmlCurrTagRoot = xmlCurrTagRoot.replace("#RESULT_DATA#", xmlTagResult);
                    }
                    sbWriteBuffer.setLength(0);
                }
                // 마스터 하위에 디테일이 포함되어 있는 경우
                else {
                    for (int row = 0; row < listCnt; row++) {
                        rowData = list.get(row);

                        if ("M".equals(rowData.get("MD_TYPE"))) {
                            // 이전 데이터 처리
                            bunchCount = xmlCurrTagSubBunchList.size();
                            if (bunchCount > 0) {
                                for (int i = 0; i < bunchCount; i++) {
                                    sbWriteBuffer.append(xmlCurrTagSubBunchList.get(i)).append(Consts.CRLF);
                                }
                                xmlCurrTagSubBunchList.clear();
                                xmlCurrTagBunch = xmlCurrTagBunch.replace("#DETAIL_DATA#", sbWriteBuffer.toString());
                                sbWriteBuffer.setLength(0);

                                xmlCurrTagBunchList.add(xmlCurrTagBunch);
                            }

                            xmlCurrTagBunch = xmlTagBunch;
                        }

                        xmlCurrTagSubBunch = xmlTagSubBunch;
                        for (int col = 0; col < columnCount; col++) {
                            vtColumn = columns.get(col);

                            columnNm = (String)vtColumn.get(0);
                            columnVal = (String)rowData.get(columnNm);
                            if (columnVal == null) {
                                columnVal = "";
                            }
                            columnNm = "#" + columnNm + "#";
                            xmlCurrTagBunch = xmlCurrTagBunch.replace(columnNm, columnVal);
                            xmlCurrTagSubBunch = xmlCurrTagSubBunch.replace(columnNm, columnVal);
                            xmlCurrTagRoot = xmlCurrTagRoot.replace(columnNm, columnVal);

                            if (!"".equals(columnVal)) {
                                webServiceUrl = webServiceUrl.replace(columnNm, columnVal);
                                webServiceMethod = webServiceMethod.replace(columnNm, columnVal);
                            }
                        }
                        xmlCurrTagSubBunchList.add(xmlCurrTagSubBunch);
                    }

                    // 이전 데이터 처리
                    sbWriteBuffer.setLength(0);
                    bunchCount = xmlCurrTagSubBunchList.size();
                    if (bunchCount > 0) {
                        for (int i = 0; i < bunchCount; i++) {
                            sbWriteBuffer.append(xmlCurrTagSubBunchList.get(i)).append(Consts.CRLF);
                        }
                        xmlCurrTagSubBunchList.clear();
                        xmlCurrTagBunch = xmlCurrTagBunch.replace("#DETAIL_DATA#", sbWriteBuffer.toString());
                        xmlCurrTagBunchList.add(xmlCurrTagBunch);
                    }

                    sbWriteBuffer.setLength(0);
                    bunchCount = xmlCurrTagBunchList.size();
                    if (bunchCount > 0) {
                        for (int i = 0; i < bunchCount; i++) {
                            sbWriteBuffer.append(xmlCurrTagBunchList.get(i)).append(Consts.CRLF);
                        }
                        xmlCurrTagBunchList.clear();
                        xmlCurrTagRoot = xmlCurrTagRoot.replace("#MASTER_DATA#", sbWriteBuffer.toString());
                    }
                    if (Util.isNotNull(xmlTagResult)) {
                        xmlCurrTagRoot = xmlCurrTagRoot.replace("#RESULT_DATA#", xmlTagResult);
                    }
                    sbWriteBuffer.setLength(0);
                }
            }
            xmlFileWriter.write(xmlCurrTagRoot);

            resultMap.put(PK_SEND_FILE_FULL_NM, ediSendFileFullName);
            resultMap.put(PK_BACKUP_FILE_FULL_NM, ediSendFileBackupFullName);
            resultMap.put(PK_WEBSERVICE_URL, webServiceUrl);
            resultMap.put(PK_WEBSERVICE_METHOD, webServiceMethod);

            if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                resultMap.put(PK_DOCUMENT, xmlCurrTagRoot);
            }

            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            Util.setOutMessage(resultMap, Util.getErrorMessage(e));
        } finally {
            Util.closeObject(xmlFileWriter);
            Util.closeObject(xmlFileOutputWriter);
            Util.closeObject(xmlFileOutput);
        }
        return resultMap;
    }

    @SuppressWarnings("unchecked")
    @Override
    public Map<String, Object> sendJson(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        final String PK_SEND_FILE_FULL_NM = "O_SEND_FILE_FULL_NM";
        final String PK_BACKUP_FILE_FULL_NM = "O_BACKUP_FILE_FULL_NM";
        final String PK_DOCUMENT = "O_DOCUMENT";
        final String PK_WEBSERVICE_URL = "O_WEBSERVICE_URL";
        final String PK_WEBSERVICE_METHOD = "O_WEBSERVICE_METHOD";

        // edi dir로 파일 생성
        FileOutputStream jsonFileOutput = null;
        OutputStreamWriter jsonFileOutputWriter = null;
        BufferedWriter jsonFileWriter = null;
        ObjectMapper objMapper = new ObjectMapper();
        try {
            // 송신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.035", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 내역이 등록되어 있지 않습니다."));
            }

            // 나머지 파라메터 값 읽기
            String sendDate = (String)params.get("P_SEND_DATE");
            String sendNo = (String)params.get("P_SEND_NO");
            String prefixFileNm = (String)params.get("P_PREFIX_FILE_NM");
            String fileDiv = (String)params.get("P_FILE_DIV");
            Map<String, Object> jsonResultInfo = (Map<String, Object>)params.get("P_JSON_RESULT_INFO");
            String queryId = (String)params.get(Consts.PK_QUERY_ID); // 파일 생성 쿼리 파라메터 값 읽기
            String userId = (String)params.get(Consts.PK_USER_ID);
            String webServiceUrl = Util.nullToDefault(params.get("P_WEBSERVICE_URL"), "");
            String webServiceMethod = Util.nullToDefault(params.get("P_WEBSERVICE_METHOD"), "");
            String ediFileRoot = getSendFileRootPath();
            String ediSendFullPath = Util.getPathName(ediFileRoot, ediDiv);

            // 서버 파일명 지정
            String ediSendDatetime = Util.getNowDate("yyyyMMddHHmmss");
            String ediSendFileName = getSendFileName(prefixFileNm, userId, ediSendDatetime, buCd, ediDiv, defineNo, sendDate, sendNo, "json");
            String ediSendFileFullName = ediSendFullPath + ediSendFileName;
            String ediSendFileBackupPath = getBackupFilePath(ediSendFullPath, ediSendDatetime, ediDiv);
            String ediSendFileBackupFullName = ediSendFileBackupPath + ediSendFileName;

            // upload dir이 존재하지 않으면 생성
            Util.createDir(ediSendFullPath, ediSendFileBackupPath);

            // 송신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);
            String jsonTagRoot = (String)defineInfo.get("JSON_TAG_ROOT");
            String jsonTagBunch = (String)defineInfo.get("JSON_TAG_BUNCH");
            String jsonTagSubBunch = (String)defineInfo.get("JSON_TAG_SUB_BUNCH");

            if (Util.isNull(jsonTagRoot)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.036", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\nJSON 루트태그가 정의되지 않았습니다."));
            }
            if (Util.isNull(jsonTagBunch) && Util.isNull(jsonTagSubBunch)) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.037", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\nJSON 단위태그가 정의되지 않았습니다."));
            }
            boolean writeDetailToRoot = false;
            if (Util.isNotNull(jsonTagSubBunch)) {
                if (jsonTagBunch.indexOf("#DETAIL_DATA#") == -1) {
                    if (jsonTagRoot.indexOf("#DETAIL_DATA#") != -1) {
                        writeDetailToRoot = true;
                    } else {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.038", "[사업부,송신구분,송신정의번호: " //
                            + buCd + "," + ediDiv + "," + defineNo //
                            + "]\nJSON 단위 태그에 #DETAIL_DATA#에 대한 정의가 되어 있지 않습니다."));
                    }
                }
            } else {
                if (jsonTagRoot.indexOf("#MASTER_DATA#") == -1) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.039", "[사업부,송신구분,송신정의번호: " //
                        + buCd + "," + ediDiv + "," + defineNo //
                        + "]\nJSON 루트 태그에 #MASTER_DATA#에 대한 정의가 되어 있지 않습니다."));
                }
            }

            String jsonTagResult = (String)jsonResultInfo.get("P_TAG_RESULT");
            if (Util.isNotNull(jsonTagResult)) {
                String messageCd = (String)jsonResultInfo.get("P_RESULT_CD_SUCCESS");
                // 숫자 타입
                if ("NUMBER".equals(jsonResultInfo.get("P_RESULT_CD_DATA_TYPE"))) {
                    jsonTagResult = jsonTagResult.replace("#RESULT_CD#", messageCd);
                }
                // 문자 타입
                else {
                    jsonTagResult = jsonTagResult.replace("#RESULT_CD#", "\"" + messageCd + "\"");
                }
                jsonTagResult = jsonTagResult.replace("#RESULT_MSG#", "\"" + Consts.OK + "\"");
            }

            String columnNm = null;
            String dataType = null;
            Object columnVal = null;
            String writeColumnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCount = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            for (int i = 0; i < columnCount; i++) {
                defineInfo = lstDefineInfo.get(i);
                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    dataType = (String)defineInfo.get("DATA_TYPE");

                    if (Util.isNotNull(columnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add(columnNm);
                        vtColumn.add(dataType);
                        columns.add(vtColumn);
                    }
                } catch (Exception e) {
                }
            }
            columnCount = columns.size();
            if (columnCount == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.040", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 컬럼 중 처리 가능한 컬럼이 없습니다."));
            }

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> list = getDataList(queryId, params);
            if (list == null || list.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.119", "[사업부,송신구분,송신정의번호,송신일자,송신번호: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + sendDate + "," + sendNo //
                    + "]\n송신할 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo, sendDate, sendNo}));
            }

            // 기본 Tag에 SQL 호출 값 변경
            // SQL#[SQL문]# -> SQL문 실행 후 결과 입력
            jsonTagRoot = replaceSQLText(jsonTagRoot);
            jsonTagBunch = replaceSQLText(jsonTagBunch);
            jsonTagSubBunch = replaceSQLText(jsonTagSubBunch);

            jsonFileOutput = new FileOutputStream(ediSendFileFullName);
            jsonFileOutputWriter = new OutputStreamWriter(jsonFileOutput);
            jsonFileWriter = new BufferedWriter(jsonFileOutputWriter);

            int listCnt = list.size();
            params.put("O_PROCESS_CNT", listCnt);
            Map<String, Object> rowData;

            String jsonCurrTagRoot = jsonTagRoot;
            String jsonCurrTagBunch = jsonTagBunch;
            String jsonCurrTagSubBunch = jsonTagSubBunch;
            ArrayList<String> jsonCurrTagBunchList = new ArrayList<String>();
            StringBuffer sbWriteBuffer = new StringBuffer();
            int bunchCount;
            boolean encode = Consts.YES.equals(jsonResultInfo.get("P_MESSAGE_ENCODE_YN"));

            // 마스터 형태로 구성된 데이터 처리
            if (Util.isNull(jsonTagSubBunch)) {
                for (int row = 0; row < listCnt; row++) {
                    rowData = list.get(row);

                    jsonCurrTagBunch = jsonTagBunch;
                    for (int col = 0; col < columnCount; col++) {
                        vtColumn = columns.get(col);

                        columnNm = (String)vtColumn.get(0);
                        dataType = (String)vtColumn.get(1);
                        columnVal = rowData.get(columnNm);
                        if (columnVal == null) {
                            writeColumnVal = "null";
                        } else {
                            try {
                                // 숫자
                                if ("3".equals(dataType) && columnVal instanceof String) {
                                    // 소수점이 있을 경우 Double
                                    if (Util.contains((String)columnVal, ".")) {
                                        writeColumnVal = objMapper.writeValueAsString(Double.parseDouble((String)columnVal));
                                    }
                                    // 정수일 경우 Integer
                                    else {
                                        writeColumnVal = objMapper.writeValueAsString(Integer.parseInt((String)columnVal));
                                    }
                                } else {
                                    // 문자열, 날짜, 기타
                                    if (columnVal instanceof String) {
                                        writeColumnVal = objMapper.writeValueAsString(urlEncodeMessage(encode, (String)columnVal));
                                    } else {
                                        writeColumnVal = objMapper.writeValueAsString(columnVal);
                                    }
                                }
                            } catch (Exception e) {
                                if (columnVal instanceof String) {
                                    writeColumnVal = objMapper.writeValueAsString(urlEncodeMessage(encode, (String)columnVal));
                                } else {
                                    writeColumnVal = objMapper.writeValueAsString(columnVal);
                                }
                            }
                        }
                        columnNm = "#" + columnNm + "#";
                        jsonCurrTagBunch = jsonCurrTagBunch.replace(columnNm, writeColumnVal);
                        jsonCurrTagRoot = jsonCurrTagRoot.replace(columnNm, writeColumnVal);

                        if (columnVal != null) {
                            webServiceUrl = webServiceUrl.replace(columnNm, (String)columnVal);
                            webServiceMethod = webServiceMethod.replace(columnNm, (String)columnVal);
                        }
                    }
                    jsonCurrTagBunchList.add(jsonCurrTagBunch);
                }

                sbWriteBuffer.setLength(0);
                bunchCount = jsonCurrTagBunchList.size();
                if (bunchCount > 0) {
                    sbWriteBuffer.append(jsonCurrTagBunchList.get(0));
                    for (int i = 1; i < bunchCount; i++) {
                        sbWriteBuffer.append(",").append(Consts.CRLF).append(jsonCurrTagBunchList.get(i));
                    }
                    jsonCurrTagBunchList.clear();
                    jsonCurrTagRoot = jsonCurrTagRoot.replace("#MASTER_DATA#", sbWriteBuffer.toString());
                    sbWriteBuffer.setLength(0);
                }
                if (Util.isNotNull(jsonTagResult)) {
                    jsonCurrTagRoot = jsonCurrTagRoot.replace("#RESULT_DATA#", jsonTagResult + ",");
                }
            }
            // 마스터/디테일 형태로 구성된 데이터 처리
            else {
                ArrayList<String> jsonCurrTagSubBunchList = new ArrayList<String>();
                // 마스터, 디테일이 별도로 루트에 포함되어 있는 경우
                if (writeDetailToRoot) {
                    for (int row = 0; row < listCnt; row++) {
                        rowData = list.get(row);

                        boolean mdTypeM = "M".equals(rowData.get("MD_TYPE"));
                        // 마스터 데이터일 경우 마스터 입력 태그 기본값으로 초기화, 전표별 첫 데이터
                        if (mdTypeM) {
                            jsonCurrTagBunch = jsonTagBunch;
                        }
                        // 디테일 입력 태그 기본값으로 초기화
                        jsonCurrTagSubBunch = jsonTagSubBunch;
                        // 데이터 변경 처리
                        for (int col = 0; col < columnCount; col++) {
                            vtColumn = columns.get(col);

                            columnNm = (String)vtColumn.get(0);
                            dataType = (String)vtColumn.get(1);
                            columnVal = rowData.get(columnNm);
                            if (columnVal == null) {
                                writeColumnVal = "null";
                            } else {
                                try {
                                    // 숫자
                                    if ("3".equals(dataType) && columnVal instanceof String) {
                                        // 소수점이 있을 경우 Double
                                        if (Util.contains((String)columnVal, ".")) {
                                            writeColumnVal = objMapper.writeValueAsString(Double.parseDouble((String)columnVal));
                                        }
                                        // 정수일 경우 Integer
                                        else {
                                            writeColumnVal = objMapper.writeValueAsString(Integer.parseInt((String)columnVal));
                                        }
                                    } else {
                                        // 문자열, 날짜, 기타
                                        if (columnVal instanceof String) {
                                            writeColumnVal = objMapper.writeValueAsString(urlEncodeMessage(encode, (String)columnVal));
                                        } else {
                                            writeColumnVal = objMapper.writeValueAsString(columnVal);
                                        }
                                    }
                                } catch (Exception e) {
                                    if (columnVal instanceof String) {
                                        writeColumnVal = objMapper.writeValueAsString(urlEncodeMessage(encode, (String)columnVal));
                                    } else {
                                        writeColumnVal = objMapper.writeValueAsString(columnVal);
                                    }
                                }
                            }
                            columnNm = "#" + columnNm + "#";
                            jsonCurrTagBunch = jsonCurrTagBunch.replace(columnNm, writeColumnVal);
                            jsonCurrTagSubBunch = jsonCurrTagSubBunch.replace(columnNm, writeColumnVal);
                            jsonCurrTagRoot = jsonCurrTagRoot.replace(columnNm, writeColumnVal);

                            if (columnVal != null) {
                                webServiceUrl = webServiceUrl.replace(columnNm, (String)columnVal);
                                webServiceMethod = webServiceMethod.replace(columnNm, (String)columnVal);
                            }
                        }
                        if (mdTypeM) {
                            jsonCurrTagBunchList.add(jsonCurrTagBunch);
                        }
                        jsonCurrTagSubBunchList.add(jsonCurrTagSubBunch);
                    }

                    // 마스터 변경
                    sbWriteBuffer.setLength(0);
                    bunchCount = jsonCurrTagBunchList.size();
                    if (bunchCount > 0) {
                        sbWriteBuffer.append(jsonCurrTagBunchList.get(0));
                        for (int i = 1; i < bunchCount; i++) {
                            sbWriteBuffer.append(",").append(Consts.CRLF).append(jsonCurrTagBunchList.get(i));
                        }
                        jsonCurrTagBunchList.clear();
                        jsonCurrTagRoot = jsonCurrTagRoot.replace("#MASTER_DATA#", sbWriteBuffer.toString());
                    }
                    // 디테일 변경
                    sbWriteBuffer.setLength(0);
                    bunchCount = jsonCurrTagSubBunchList.size();
                    if (bunchCount > 0) {
                        sbWriteBuffer.append(jsonCurrTagSubBunchList.get(0));
                        for (int i = 1; i < bunchCount; i++) {
                            sbWriteBuffer.append(",").append(Consts.CRLF).append(jsonCurrTagSubBunchList.get(i));
                        }
                        jsonCurrTagSubBunchList.clear();
                        jsonCurrTagRoot = jsonCurrTagRoot.replace("#DETAIL_DATA#", sbWriteBuffer.toString());
                    }
                    if (Util.isNotNull(jsonTagResult)) {
                        jsonCurrTagRoot = jsonCurrTagRoot.replace("#RESULT_DATA#", jsonTagResult + ",");
                    }
                    sbWriteBuffer.setLength(0);
                }
                // 마스터 하위에 디테일이 포함되어 있는 경우
                else {
                    for (int row = 0; row < listCnt; row++) {
                        rowData = list.get(row);

                        if ("M".equals(rowData.get("MD_TYPE"))) {
                            // 이전 데이터 처리
                            sbWriteBuffer.setLength(0);
                            bunchCount = jsonCurrTagSubBunchList.size();
                            if (bunchCount > 0) {
                                sbWriteBuffer.append(jsonCurrTagSubBunchList.get(0));
                                for (int i = 1; i < bunchCount; i++) {
                                    sbWriteBuffer.append(",").append(Consts.CRLF).append(jsonCurrTagSubBunchList.get(i));
                                }
                                jsonCurrTagSubBunchList.clear();
                                jsonCurrTagBunch = jsonCurrTagBunch.replace("#DETAIL_DATA#", sbWriteBuffer.toString());
                                sbWriteBuffer.setLength(0);

                                jsonCurrTagBunchList.add(jsonCurrTagBunch);
                            }

                            jsonCurrTagBunch = jsonTagBunch;
                        }

                        jsonCurrTagSubBunch = jsonTagSubBunch;
                        for (int col = 0; col < columnCount; col++) {
                            vtColumn = columns.get(col);

                            columnNm = (String)vtColumn.get(0);
                            dataType = (String)vtColumn.get(1);
                            columnVal = rowData.get(columnNm);
                            if (columnVal == null) {
                                writeColumnVal = "null";
                            } else {
                                try {
                                    // 숫자
                                    if ("3".equals(dataType) && columnVal instanceof String) {
                                        // 소수점이 있을 경우 Double
                                        if (Util.contains((String)columnVal, ".")) {
                                            writeColumnVal = objMapper.writeValueAsString(Double.parseDouble((String)columnVal));
                                        }
                                        // 정수일 경우 Integer
                                        else {
                                            writeColumnVal = objMapper.writeValueAsString(Integer.parseInt((String)columnVal));
                                        }
                                    } else {
                                        // 문자열, 날짜, 기타
                                        if (columnVal instanceof String) {
                                            writeColumnVal = objMapper.writeValueAsString(urlEncodeMessage(encode, (String)columnVal));
                                        } else {
                                            writeColumnVal = objMapper.writeValueAsString(columnVal);
                                        }
                                    }
                                } catch (Exception e) {
                                    if (columnVal instanceof String) {
                                        writeColumnVal = objMapper.writeValueAsString(urlEncodeMessage(encode, (String)columnVal));
                                    } else {
                                        writeColumnVal = objMapper.writeValueAsString(columnVal);
                                    }
                                }
                            }
                            columnNm = "#" + columnNm + "#";
                            jsonCurrTagBunch = jsonCurrTagBunch.replace(columnNm, writeColumnVal);
                            jsonCurrTagSubBunch = jsonCurrTagSubBunch.replace(columnNm, writeColumnVal);
                            jsonCurrTagRoot = jsonCurrTagRoot.replace(columnNm, writeColumnVal);

                            if (columnVal != null) {
                                webServiceUrl = webServiceUrl.replace(columnNm, (String)columnVal);
                                webServiceMethod = webServiceMethod.replace(columnNm, (String)columnVal);
                            }
                        }
                        jsonCurrTagSubBunchList.add(jsonCurrTagSubBunch);
                    }

                    // 이전 데이터 처리
                    sbWriteBuffer.setLength(0);
                    bunchCount = jsonCurrTagSubBunchList.size();
                    if (bunchCount > 0) {
                        sbWriteBuffer.append(jsonCurrTagSubBunchList.get(0));
                        for (int i = 1; i < bunchCount; i++) {
                            sbWriteBuffer.append(",").append(Consts.CRLF).append(jsonCurrTagSubBunchList.get(i));
                        }
                        jsonCurrTagSubBunchList.clear();
                        jsonCurrTagBunch = jsonCurrTagBunch.replace("#DETAIL_DATA#", sbWriteBuffer.toString());
                        jsonCurrTagBunchList.add(jsonCurrTagBunch);
                    }

                    sbWriteBuffer.setLength(0);
                    bunchCount = jsonCurrTagBunchList.size();
                    if (bunchCount > 0) {
                        sbWriteBuffer.append(jsonCurrTagBunchList.get(0));
                        for (int i = 1; i < bunchCount; i++) {
                            sbWriteBuffer.append(",").append(Consts.CRLF).append(jsonCurrTagBunchList.get(i));
                        }
                        jsonCurrTagBunchList.clear();
                        jsonCurrTagRoot = jsonCurrTagRoot.replace("#MASTER_DATA#", sbWriteBuffer.toString());
                    }
                    if (Util.isNotNull(jsonTagResult)) {
                        jsonCurrTagRoot = jsonCurrTagRoot.replace("#RESULT_DATA#", jsonTagResult + ",");
                    }
                    sbWriteBuffer.setLength(0);
                }
            }
            jsonFileWriter.write(jsonCurrTagRoot);

            resultMap.put(PK_SEND_FILE_FULL_NM, ediSendFileFullName);
            resultMap.put(PK_BACKUP_FILE_FULL_NM, ediSendFileBackupFullName);
            resultMap.put(PK_WEBSERVICE_URL, webServiceUrl);
            resultMap.put(PK_WEBSERVICE_METHOD, webServiceMethod);

            if (Consts.FILE_DIV_DOC.equals(fileDiv)) {
                resultMap.put(PK_DOCUMENT, jsonCurrTagRoot);
            }

            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            Util.setOutMessage(resultMap, Util.getErrorMessage(e));
        } finally {
            Util.closeObject(jsonFileWriter);
            Util.closeObject(jsonFileOutputWriter);
            Util.closeObject(jsonFileOutput);
        }
        return resultMap;
    }

    @Override
    public Map<String, Object> sendSAPFunction(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();

        try {
            // 파일 생성 쿼리 파라메터 값 읽기
            String queryId = (String)params.get(Consts.PK_QUERY_ID);

            // 송신정의 상세내역 쿼리 파라메터 값 읽기
            String buCd = (String)params.get("P_BU_CD");
            String ediDiv = (String)params.get("P_EDI_DIV");
            String defineNo = (String)params.get("P_DEFINE_NO");
            String sendDate = (String)params.get("P_SEND_DATE");
            String sendNo = (String)params.get("P_SEND_NO");

            // com.sap.conn.jco.JCoFunction sapFunction = (com.sap.conn.jco.JCoFunction)params.get("P_SAP_FUNCTION");
            com.sap.conn.jco.JCoTable sapTable = (com.sap.conn.jco.JCoTable)params.get("P_SAP_TABLE");

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> lstDefineInfo = getDefineInfo(params);
            if (lstDefineInfo == null || lstDefineInfo.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.035", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 내역이 등록되어 있지 않습니다."));
            }

            // 송신정의에서 기본 정보 읽기
            Map<String, Object> defineInfo = lstDefineInfo.get(0);

            // 나머지 파라메터 값 읽기
            // String userId = (String)params.get(Consts.PK_USER_ID);

            String columnNm = null;
            String linkColumnNm = null;
            String dataType = null;
            String columnVal = null;

            // 실제 정의한 컬럼만 추출
            Vector<Object> vtColumn;
            int columnCnt = lstDefineInfo.size();
            ArrayList<Vector<Object>> columns = new ArrayList<Vector<Object>>();

            for (int i = 0; i < columnCnt; i++) {
                defineInfo = lstDefineInfo.get(i);

                try {
                    columnNm = (String)defineInfo.get("COLUMN_NM");
                    linkColumnNm = (String)defineInfo.get("LINK_COLUMN_NM");
                    dataType = (String)defineInfo.get("DATA_TYPE");

                    if (Util.isNotNull(columnNm) && Util.isNotNull(linkColumnNm)) {
                        vtColumn = new Vector<Object>();
                        vtColumn.add(columnNm);
                        vtColumn.add(linkColumnNm);
                        if (Util.isNull(dataType)) {
                            dataType = DT_STRING;
                        }
                        vtColumn.add(dataType);
                        columns.add(vtColumn);
                    }
                } catch (Exception e) {
                }
            }
            columnCnt = columns.size();
            if (columnCnt == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.040", "[사업부,송신구분,송신정의번호: " //
                    + buCd + "," + ediDiv + "," + defineNo //
                    + "]\n송신정의 컬럼 중 처리 가능한 컬럼이 없습니다."));
            }

            // 송신정의 상세내역 데이터 쿼리
            List<Map<String, Object>> list = getDataList(queryId, params);
            if (list == null || list.size() == 0) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.119", "[사업부,송신구분,송신정의번호,송신일자,송신번호: " //
                    + buCd + "," + ediDiv + "," + defineNo + "," + sendDate + "," + sendNo //
                    + "]\n송신할 데이터가 존재하지 않습니다.", new String[] {buCd, ediDiv, defineNo, sendDate, sendNo}));
            }

            int listCnt = list.size();
            params.put("O_PROCESS_CNT", listCnt);
            Map<String, Object> rowData;
            for (int row = 0; row < listCnt; row++) {
                rowData = list.get(row);

                sapTable.appendRow();
                for (int i = 0; i < columnCnt; i++) {
                    vtColumn = columns.get(i);

                    columnNm = (String)vtColumn.get(0);
                    linkColumnNm = (String)vtColumn.get(1);
                    columnVal = (String)rowData.get(columnNm);

                    try {
                        // 현재 문자열로 데이터를 기록, 필요시 데이터 타입별로 처리
                        sapTable.setValue(linkColumnNm, columnVal);
                        // // 날짜
                        // if (DT_DATE.equals(dataType)) {
                        // sapTable.setValue(linkColumnNm, columnVal);
                        // }
                        // // 숫자
                        // else if (DT_NUMBER.equals(dataType)) {
                        // sapTable.setValue(linkColumnNm, columnVal);
                        // }
                        // // 문자
                        // else {
                        // sapTable.setValue(linkColumnNm, columnVal);
                        // }
                    } catch (Exception e) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.126", "[사업부,송신구분,송신정의번호,송신일자,송신번호,컬럼명: " //
                            + buCd + "," + ediDiv + "," + defineNo + "," + sendDate + "," + sendNo + "," + columnNm //
                            + "]\n컬럼 데이터 기록 중 오류가 발생했습니다.", new String[] {buCd, ediDiv, defineNo, sendDate, sendNo, columnNm}), e);
                    }
                }
            }

            Util.setOutMessage(params, Consts.OK);
            Util.setOutMessage(resultMap, Consts.OK);
        } catch (Exception e) {
            String errMessage = Util.getErrorMessage(e);
            Util.setOutMessage(params, errMessage);
            Util.setOutMessage(resultMap, errMessage);
        } finally {
        }
        return resultMap;
    }

    @SuppressWarnings("rawtypes")
    @Override
    public Map<String, Object> ftpDownload(String remoteDiv, String remoteIP, String remotePort, String remotePassiveYN, String remoteCharset,
        int remoteConnTimeout, int remoteReadTimeout, String remoteUserId, String remoteUserPwd, String remoteAuthKey, String remoteDir,
        String prefixFileNm, String ediDir) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();
        Util.setOutMessage(resultMap, Consts.OK);

        // remoteDiv >> 10 - FTP, 11 - SFTP
        // FTP
        if ("10".equals(remoteDiv)) {
            FTPClient ftpClient = null;
            try {
                ftpClient = new FTPClient();
                ftpClient.setControlEncoding(Util.nullToDefault(remoteCharset, Consts.CHARSET));
                ftpClient.setConnectTimeout(remoteConnTimeout * 1000);

                ftpClient.connect(remoteIP, Integer.parseInt(remotePort));
                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.127", "FTP 서버에 접속할 수 없습니다. 원격 접속정보를 확인하십시오."));
                }

                ftpClient.setSoTimeout(remoteReadTimeout * 1000);
                ftpClient.login(remoteUserId, remoteUserPwd);
                if (!ftpClient.changeWorkingDirectory(remoteDir)) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.128", "[" + remoteDir + "]원격 파일경로가 FTP서버에 존재하지 않습니다.", new String[] {remoteDir}));
                }
                ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
                if (Consts.YES.equals(remotePassiveYN)) {
                    ftpClient.enterLocalPassiveMode();
                }

                String[] ftpEDIFiles = ftpClient.listNames();
                int ftpEDIFileCount = 0;
                if (ftpEDIFiles != null) {
                    ftpEDIFileCount = ftpEDIFiles.length;
                }
                if (ftpEDIFileCount == 0) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.129", "[" + remoteDir + "]FTP서버에 수신할 파일이 존재하지 않습니다.", new String[] {remoteDir}));
                }
                String ftpFileName = null;
                File fileDownload = null;
                FileOutputStream fosDownload = null;
                for (int i = 0; i < ftpEDIFileCount; i++) {
                    try {
                        ftpFileName = ftpEDIFiles[i];
                        if (prefixFileNm != null) {
                            if (!ftpFileName.startsWith(prefixFileNm)) {
                                continue;
                            }
                        }
                        fileDownload = new File(ediDir + ftpFileName);
                        fosDownload = new FileOutputStream(fileDownload);

                        logger.info("EDCommonDAOImpl[ftpDownload] File download : " + ftpFileName + " >> " + fileDownload.getName());
                        if (ftpClient.retrieveFile(ftpFileName, fosDownload)) {
                            if (!ftpClient.deleteFile(ftpFileName)) {
                                logger.error("EDCommonDAOImpl[ftpDownload] Download Error : " + ftpFileName);
                                fileDownload.delete();
                            }
                        } else {
                            logger.error("EDCommonDAOImpl[ftpDownload] Download Error : " + ftpFileName);
                        }
                    } catch (Exception e) {
                        Util.writeErrorMessage("EDCommonDAOImpl[ftpDownload] Error", e);
                    } finally {
                        Util.closeObject(fosDownload);
                    }
                }
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                if (ftpClient != null && ftpClient.isConnected()) {
                    try {
                        ftpClient.logout();
                        ftpClient.disconnect();
                    } catch (Exception e) {
                    }
                }
            }
        }
        // SFTP
        else {

            Session sftpSession = null;
            Channel sftpChannel = null;
            ChannelSftp sftpClient = null;

            JSch jsch = new JSch();
            try {
                sftpSession = jsch.getSession(remoteUserId, remoteIP, Integer.parseInt(remotePort));
                if (Util.isNull(remoteAuthKey)) {
                    sftpSession.setPassword(remoteUserPwd);
                } else {
                    String remoteAuthKeyAbsolutePath = remoteAuthKey;
                    if (!Util.isAbsolutePath(remoteAuthKey)) {
                        remoteAuthKeyAbsolutePath = Util.getFileName("/nexos/config/security", remoteAuthKey);
                    }
                    jsch.addIdentity(remoteAuthKey, Util.toByteArray(remoteAuthKeyAbsolutePath), null, remoteUserPwd.getBytes(Consts.CHARSET));
                }

                java.util.Properties config = new java.util.Properties();
                config.put("StrictHostKeyChecking", "no");
                sftpSession.setConfig(config);
                sftpSession.connect(remoteConnTimeout * 1000);
                sftpSession.setTimeout(remoteReadTimeout * 1000);

                sftpChannel = sftpSession.openChannel("sftp");
                sftpChannel.connect();

                sftpClient = (ChannelSftp)sftpChannel;

                try {
                    sftpClient.cd(remoteDir);
                } catch (Exception e) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.128", "[" + remoteDir + "]원격 파일경로가 FTP서버에 존재하지 않습니다.", new String[] {remoteDir}));
                }

                Vector ftpEDIFiles = sftpClient.ls("*");
                int ftpEDIFileCount = ftpEDIFiles.size();
                if (ftpEDIFileCount == 0) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.129", "[" + remoteDir + "]FTP서버에 수신할 파일이 존재하지 않습니다.", new String[] {remoteDir}));
                }

                String ftpFileName = null;
                File fileDownload = null;
                InputStream isFtpFile = null;
                FileOutputStream fosDownload = null;
                for (int i = 0; i < ftpEDIFileCount; i++) {
                    ChannelSftp.LsEntry ftpEDIFile = (ChannelSftp.LsEntry)ftpEDIFiles.get(i);
                    if (ftpEDIFile.getAttrs().isDir()) {
                        continue;
                    }
                    ftpFileName = ftpEDIFile.getFilename();
                    if (prefixFileNm != null) {
                        if (!ftpFileName.startsWith(prefixFileNm)) {
                            continue;
                        }
                    }

                    fileDownload = new File(ediDir + ftpFileName);
                    logger.info("EDCommonDAOImpl[ftpDownload] File download : " + ftpFileName + " >> " + fileDownload.getName());

                    try {
                        isFtpFile = sftpClient.get(ftpFileName);

                        fosDownload = new FileOutputStream(fileDownload);
                        int readLen;
                        byte[] readBytes = new byte[8192];
                        while ((readLen = isFtpFile.read(readBytes)) != -1) {
                            fosDownload.write(readBytes, 0, readLen);
                        }
                        fosDownload.flush();
                        try {
                            sftpClient.rm(ftpFileName);
                        } catch (Exception e) {
                            Util.writeErrorMessage("EDCommonDAOImpl[ftpDownload] Delete file Error : " + ftpFileName, e);
                            fileDownload.delete();
                        } finally {
                            Util.closeObject(isFtpFile);
                            Util.closeObject(fosDownload);
                        }
                    } catch (Exception e) {
                        Util.writeErrorMessage("EDCommonDAOImpl[ftpDownload] Download Error : " + ftpFileName, e);
                        continue;
                    } finally {
                        Util.closeObject(isFtpFile);
                        Util.closeObject(fosDownload);
                    }
                }
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                if (sftpClient != null && sftpClient.isConnected()) {
                    try {
                        sftpClient.quit();
                    } catch (Exception e) {
                    }
                }
                if (sftpChannel != null && sftpChannel.isConnected()) {
                    try {
                        sftpChannel.disconnect();
                    } catch (Exception e) {
                    }
                }
                if (sftpSession != null && sftpSession.isConnected()) {
                    try {
                        sftpSession.disconnect();
                    } catch (Exception e) {
                    }
                }
            }
        }

        return resultMap;
    }

    @Override
    public Map<String, Object> ftpUpload(String remoteDiv, String remoteIP, String remotePort, String remotePassiveYN, String remoteCharset,
        int remoteConnTimeout, int remoteReadTimeout, String remoteUserId, String remoteUserPwd, String remoteAuthKey, String remoteDir,
        String ediFileName, String backupDir) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();
        Util.setOutMessage(resultMap, Consts.OK);

        // remoteDiv >> 10 - FTP, 11 - SFTP
        // FTP
        if ("10".equals(remoteDiv)) {
            FTPClient ftpClient = null;
            try {
                ftpClient = new FTPClient();
                ftpClient.setControlEncoding(Util.nullToDefault(remoteCharset, Consts.CHARSET));
                ftpClient.setConnectTimeout(remoteConnTimeout * 1000);

                ftpClient.connect(remoteIP, Integer.parseInt(remotePort));
                if (!FTPReply.isPositiveCompletion(ftpClient.getReplyCode())) {
                    throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.127", "FTP 서버에 접속할 수 없습니다. 원격 접속정보를 확인하십시오."));
                }
                ftpClient.setSoTimeout(remoteReadTimeout * 1000);
                ftpClient.login(remoteUserId, remoteUserPwd);
                if (!ftpClient.changeWorkingDirectory(remoteDir)) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.128", "[" + remoteDir + "]원격 파일경로가 FTP서버에 존재하지 않습니다.", new String[] {remoteDir}));
                }
                ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
                if (Consts.YES.equals(remotePassiveYN)) {
                    ftpClient.enterLocalPassiveMode();
                }

                // FTP로 파일 업로드
                File fileUpload = new File(ediFileName);
                String ftpFileName = FilenameUtils.getName(ediFileName);
                FileInputStream fisUpload = new FileInputStream(fileUpload);
                try {
                    if (!ftpClient.storeFile(ftpFileName, fisUpload)) {
                        throw new RuntimeException(
                            String.format("FILE: %s, FTP: %d, %s", ftpFileName, ftpClient.getReplyCode(), ftpClient.getReplyString()));
                    }
                } catch (Exception e) {
                    Util.setOutMessage(resultMap, Util.getErrorMessage(e));
                } finally {
                    Util.closeObject(fisUpload);
                }

                Util.renameFile(fileUpload, new File(backupDir + ftpFileName + (Consts.OK.equals(Util.getOutMessage(resultMap)) ? "" : ".error")));
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                if (ftpClient != null && ftpClient.isConnected()) {
                    try {
                        ftpClient.logout();
                        ftpClient.disconnect();
                    } catch (Exception e) {
                    }
                }
            }
        }
        // SFTP
        else {

            Session sftpSession = null;
            Channel sftpChannel = null;
            ChannelSftp sftpClient = null;

            JSch jsch = new JSch();
            try {
                sftpSession = jsch.getSession(remoteUserId, remoteIP, Integer.parseInt(remotePort));
                if (Util.isNull(remoteAuthKey)) {
                    sftpSession.setPassword(remoteUserPwd);
                } else {
                    String remoteAuthKeyAbsolutePath = remoteAuthKey;
                    if (!Util.isAbsolutePath(remoteAuthKey)) {
                        remoteAuthKeyAbsolutePath = Util.getFileName("/nexos/config/security", remoteAuthKey);
                    }
                    jsch.addIdentity(remoteAuthKey, Util.toByteArray(remoteAuthKeyAbsolutePath), null, remoteUserPwd.getBytes(Consts.CHARSET));
                }

                java.util.Properties config = new java.util.Properties();
                config.put("StrictHostKeyChecking", "no");
                sftpSession.setConfig(config);
                sftpSession.connect(remoteConnTimeout * 1000);
                sftpSession.setTimeout(remoteReadTimeout * 1000);

                sftpChannel = sftpSession.openChannel("sftp");
                sftpChannel.connect();

                sftpClient = (ChannelSftp)sftpChannel;

                try {
                    sftpClient.cd(remoteDir);
                } catch (Exception e) {
                    throw new RuntimeException(
                        NexosMessage.getDisplayMsg("JAVA.ED.128", "[" + remoteDir + "]원격 파일경로가 FTP서버에 존재하지 않습니다.", new String[] {remoteDir}));
                }

                File fileUpload = new File(ediFileName);
                String ftpFileName = FilenameUtils.getName(ediFileName);
                FileInputStream fisUpload = new FileInputStream(fileUpload);
                try {
                    sftpClient.put(fisUpload, ftpFileName);
                } catch (Exception e) {
                    Util.setOutMessage(resultMap, Util.getErrorMessage("[" + ftpFileName + "]", e));
                } finally {
                    Util.closeObject(fisUpload);
                }

                Util.renameFile(fileUpload, new File(backupDir + ftpFileName + (Consts.OK.equals(Util.getOutMessage(resultMap)) ? "" : ".error")));
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                if (sftpClient != null && sftpClient.isConnected()) {
                    try {
                        sftpClient.quit();
                    } catch (Exception e) {
                    }
                }
                if (sftpChannel != null && sftpChannel.isConnected()) {
                    try {
                        sftpChannel.disconnect();
                    } catch (Exception e) {
                    }
                }
                if (sftpSession != null && sftpSession.isConnected()) {
                    try {
                        sftpSession.disconnect();
                    } catch (Exception e) {
                    }
                }
            }
        }

        return resultMap;
    }

    /**
     * 수신 웹서비스 호출
     *
     * @param params
     * @return
     * @throws Exception
     */
    @SuppressWarnings({"rawtypes", "unchecked"})
    @Override
    public Map<String, Object> recvWebService(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();
        Util.setOutMessage(resultMap, Consts.OK);

        String userId = (String)params.get("P_USER_ID");
        String dataDiv = (String)params.get("P_DATA_DIV");
        String webServiceDiv = Util.nullToDefault(params.get("P_WEBSERVICE_DIV"), "");
        String webServiceUrl = (String)params.get("P_WEBSERVICE_URL");
        String webServiceHeaderVal = (String)params.get("P_WEBSERVICE_HEADER_VAL");
        String webServiceMethod = (String)params.get("P_WEBSERVICE_METHOD");
        String webServiceNSPrefix = (String)params.get("P_WEBSERVICE_NS_PREFIX");
        String webServiceNSUri = (String)params.get("P_WEBSERVICE_NS_URI");
        String webServiceParamNm = (String)params.get("P_WEBSERVICE_PARAM_NM");
        String webServiceParamVal = (String)params.get("P_WEBSERVICE_PARAM_VAL");
        String webServiceTagResult = (String)params.get("P_WEBSERVICE_TAG_RESULT");
        String webServiceAuthDiv = (String)params.get("P_WEBSERVICE_AUTH_DIV");
        String webServiceAuthUrl = (String)params.get("P_WEBSERVICE_AUTH_URL");
        String webServiceAuthType = (String)params.get("P_WEBSERVICE_AUTH_TYPE");
        String webServiceClientId = (String)params.get("P_WEBSERVICE_AUTH_CID");
        String webServiceClientSecret = (String)params.get("P_WEBSERVICE_AUTH_CSECRET");
        int remoteConnTimeout = Util.toInt(params.get("P_REMOTE_CONN_TIMEOUT"), 60);
        int remoteReadTimeout = Util.toInt(params.get("P_REMOTE_READ_TIMEOUT"), 300);
        String remoteUserId = (String)params.get("P_REMOTE_USER_ID");
        String remoteUserPwd = (String)params.get("P_REMOTE_USER_PWD");
        // String sendDocument = (String)params.get("P_DOCUMENT");
        Map<String, Object> resultInfo = (Map<String, Object>)(Consts.DATA_DIV_XML.equals(dataDiv) //
            ? params.get("P_XML_RESULT_INFO") //
            : params.get("P_JSON_RESULT_INFO"));
        boolean isHttps = Util.isHttps(webServiceAuthUrl);

        // 헤더값 파싱
        Map<String, Object> headerParams = Util.toKeyValues(webServiceHeaderVal);

        if (Util.isNotNull(webServiceParamVal)) {
            // [USER_ID] -> 사용자ID 입력
            if (webServiceParamVal.indexOf("[USER_ID]") > 0) {
                webServiceParamVal = webServiceParamVal.replaceAll("\\[USER_ID\\]", userId);
            }
            // [SYSDATE] -> 처리일시 입력
            if (webServiceParamVal.indexOf("[SYSDATE]") > 0) {
                webServiceParamVal = webServiceParamVal.replaceAll("\\[SYSDATE\\]", getEDIDatetime());
            }
            // SQL#[SQL문]# -> SQL문 실행 후 결과 입력
            webServiceParamVal = replaceSQLText(webServiceParamVal);
        }

        // RESTful
        if (webServiceDiv.startsWith("1")) {

            // 웹서비스 호출 전 인증
            String authorization = null;
            if (Util.isNotNull(webServiceAuthDiv)) {
                // OAuth 인증
                if ("2".equals(webServiceAuthDiv)) {
                    RestTemplate request = null;
                    try {
                        request = Util.getRestTemplate(remoteConnTimeout, remoteReadTimeout, isHttps);
                    } catch (Exception e) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.130", "http(s) 접속을 위한 객체(Request)를 생성하지 못했습니다."), e);
                    }

                    MultiValueMap<String, String> urlVariables = new LinkedMultiValueMap<String, String>();
                    // Client credentials
                    if (AuthorizationGrantType.CLIENT_CREDENTIALS.getValue().equals(webServiceAuthType)) {
                        urlVariables.add(OAuth2ParameterNames.CLIENT_ID, webServiceClientId);
                        urlVariables.add(OAuth2ParameterNames.CLIENT_SECRET, webServiceClientSecret);
                    }
                    // password
                    else if (AuthorizationGrantType.PASSWORD.getValue().equals(webServiceAuthType)) {
                        urlVariables.add(OAuth2ParameterNames.CLIENT_ID, webServiceClientId);
                        urlVariables.add(OAuth2ParameterNames.CLIENT_SECRET, webServiceClientSecret);
                        urlVariables.add(OAuth2ParameterNames.USERNAME, remoteUserId);
                        urlVariables.add(OAuth2ParameterNames.PASSWORD, remoteUserPwd);
                    }
                    //
                    else {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.131", "[" + webServiceAuthType + "]처리할 수 없는 인증 승인유형입니다.",
                            new String[] {webServiceAuthType}));
                    }
                    urlVariables.add(OAuth2ParameterNames.GRANT_TYPE, webServiceAuthType);

                    HttpHeaders headers = new HttpHeaders();
                    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
                    if (Util.isNotNull(authorization)) {
                        headers.add(AuthenticationUtil.HTTP_AUTHENTICATION_HEADER_KEY, authorization);
                        authorization = null;
                    }

                    HttpEntity entity = new HttpEntity(urlVariables, headers);
                    try {
                        ResponseEntity<String> response = request.postForEntity(webServiceAuthUrl, entity, String.class);
                        String responseBody = Util.nullToDefault(response.getBody(), "");

                        Map<String, Object> authMap = new ObjectMapper().readValue(responseBody, new MapTypeReference<String, Object>());
                        String accessToken = (String)authMap.get(OAuth2ParameterNames.ACCESS_TOKEN);
                        authorization = TokenType.BEARER.getValue() + " " + accessToken;
                    } catch (Exception e) {
                        // HttpServerErrorException, HttpClientErrorException
                        if (e instanceof HttpStatusCodeException) {
                            HttpStatusCodeException ex = (HttpStatusCodeException)e;
                            String responseBody = new String(ex.getResponseBodyAsByteArray(), Consts.CHARSET);
                            if (responseBody.startsWith("{") && responseBody.endsWith("}")) {
                                Map<String, Object> authMap = new ObjectMapper().readValue(responseBody, new MapTypeReference<String, Object>());
                                if (authMap.containsKey(OAuth2ParameterNames.ERROR)) {
                                    throw new RuntimeException("[" + (String)authMap.get(OAuth2ParameterNames.ERROR) + "]" //
                                        + (String)authMap.get(OAuth2ParameterNames.ERROR_DESCRIPTION));
                                } else if (authMap.containsKey("message")) {
                                    throw new RuntimeException((String)authMap.get("message"));
                                } else {
                                    throw new RuntimeException("[" + ex.getStatusCode() + "]" + responseBody);
                                }
                            } else {
                                responseBody = Util.nullToDefault(ex.getStatusText(), responseBody);
                                if (Util.isNull(responseBody)) {
                                    responseBody = ex.getResponseHeaders().getFirst(HttpHeaders.WWW_AUTHENTICATE);
                                    if (Util.isNotNull(responseBody)) {
                                        Matcher matcher = Pattern.compile(OAuth2ParameterNames.ERROR_DESCRIPTION + "=\\\"(.*?)\\\"")
                                            .matcher(responseBody);
                                        if (matcher.find()) {
                                            responseBody = matcher.group(1);
                                        }
                                    }
                                }
                                throw new RuntimeException("[" + ex.getStatusCode() + "]" + responseBody);
                            }
                        } else {
                            throw e;
                        }
                    }
                } else {
                    authorization = AuthenticationUtil.createBasicHttpAuthorization(remoteUserId, remoteUserPwd);
                }
            }

            // 웹서비스구분 - 10 : RESTful[GET], 11 : RESTful[POST]
            RestTemplate restTemplate = null;
            try {
                restTemplate = Util.getRestTemplate(remoteConnTimeout, remoteReadTimeout, isHttps);
            } catch (Exception e) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.130", "http(s) 접속을 위한 객체(Request)를 생성하지 못했습니다."), e);
            }
            try {
                String requestUrl = webServiceUrl;
                if (Util.isNotNull(webServiceMethod)) {
                    if (requestUrl.endsWith("/")) {
                        requestUrl += webServiceMethod;
                    } else {
                        requestUrl += "/" + webServiceMethod;
                    }
                }

                HttpHeaders headers = new HttpHeaders();
                if (Util.isNotNull(authorization)) {
                    headers.set(AuthenticationUtil.HTTP_AUTHENTICATION_HEADER_KEY, authorization);
                }

                // 헤더 정보 세팅
                if (Util.isNotNull(headerParams)) {
                    for (Map.Entry<String, Object> header : headerParams.entrySet()) {
                        headers.add(header.getKey(), header.getValue().toString());
                    }
                }

                ResponseEntity<String> response = null;
                // GET
                if ("10".equals(webServiceDiv)) {
                    HashMap<String, String> urlVariables = new HashMap<String, String>();
                    urlVariables.put(webServiceParamNm, webServiceParamVal);

                    requestUrl += "?" + webServiceParamNm + "={" + webServiceParamNm + "}";
                    // response = restTemplate.getForEntity(requestUrl, String.class, urlVariables);

                    HttpEntity<String> entity = new HttpEntity<String>(headers);
                    response = restTemplate.exchange(requestUrl, HttpMethod.GET, entity, String.class, urlVariables);
                }
                // POST
                else {
                    if (headers.getContentType() == null) {
                        headers.setContentType(MediaType.MULTIPART_FORM_DATA);
                    }

                    if (Consts.DATA_DIV_XML.equals(dataDiv)) {
                        // UTF-8로 변환
                        restTemplate.getMessageConverters().add(0, new StringHttpMessageConverter(Charset.forName(Consts.CHARSET)));
                    }

                    HttpEntity entity = null;
                    // 파라메터명이 없으면 RequestBody에 추가
                    if (Util.isNull(webServiceParamNm)) {
                        entity = new HttpEntity(webServiceParamVal, headers);
                    } else {
                        MultiValueMap<String, String> callParams = new LinkedMultiValueMap<String, String>();
                        callParams.add(webServiceParamNm, webServiceParamVal);

                        entity = new HttpEntity(callParams, headers);
                    }

                    response = restTemplate.postForEntity(requestUrl, entity, String.class);
                }

                setRecvWebServiceResultMessage(response, resultInfo, resultMap);
            } catch (Exception e) {
                // HttpServerErrorException, HttpClientErrorException
                if (e instanceof HttpStatusCodeException) {
                    HttpStatusCodeException ex = (HttpStatusCodeException)e;
                    ResponseEntity<String> response = new ResponseEntity<String>(new String(ex.getResponseBodyAsByteArray(), Consts.CHARSET),
                        ex.getResponseHeaders(), ex.getStatusCode());
                    setRecvWebServiceResultMessage(response, resultInfo, resultMap);
                } else {
                    Util.setOutMessage(resultMap, Util.getErrorMessage(e));
                }
            }
        }
        // SOAP
        else if (webServiceDiv.startsWith("2")) {

            // TODO: 테스트 안됨
            SOAPConnection soapConnection = null;
            try {
                MessageFactory messageFactory = MessageFactory.newInstance();
                // TransformerFactory transformerFactory = TransformerFactory.newInstance();
                SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();

                SOAPMessage soapRequest = messageFactory.createMessage();
                soapRequest.setProperty(SOAPMessage.CHARACTER_SET_ENCODING, Consts.CHARSET);

                SOAPPart soapPart = soapRequest.getSOAPPart();
                SOAPEnvelope soapEnvelope = soapPart.getEnvelope();

                // Namespace -> xmlns:ns1="http://endpoint.sample.com/"
                // Method -> <ns1:getMsg>
                // 데이터 -> <arg0>Send message</arg0>
                soapEnvelope.addNamespaceDeclaration(webServiceNSPrefix, webServiceNSUri);
                SOAPBody soapBody = soapEnvelope.getBody();
                SOAPElement methodElement = soapBody.addChildElement(webServiceMethod, webServiceNSPrefix);
                // 파라메터 입력
                if (Util.isNull(webServiceParamNm)) {
                    methodElement.setTextContent(webServiceParamVal);
                } else {
                    SOAPElement soapElement = methodElement.addChildElement(webServiceParamNm);
                    soapElement.setTextContent(webServiceParamVal);
                }

                // 헤더 정보 세팅
                MimeHeaders mimeHeaders = soapRequest.getMimeHeaders();
                if (Util.isNotNull(headerParams)) {
                    for (Map.Entry<String, Object> header : headerParams.entrySet()) {
                        mimeHeaders.addHeader(header.getKey(), header.getValue().toString());
                    }
                }

                if ("1".equals(webServiceAuthType)) {
                    mimeHeaders.addHeader(HttpHeaders.AUTHORIZATION, AuthenticationUtil.createBasicHttpAuthorization(remoteUserId, remoteUserPwd));
                }

                // 기본 헤더 정보가 없을 시 추가 세팅
                if (mimeHeaders.getHeader(HttpHeaders.CONTENT_TYPE) == null) {
                    mimeHeaders.addHeader(HttpHeaders.CONTENT_TYPE, "application/soap+xml; charset=" + Consts.CHARSET);
                }
                if (mimeHeaders.getHeader(HttpHeaders.CONNECTION) == null) {
                    // mimeHeaders.addHeader(HttpHeaders.CONNECTION, "Keep-Alive");
                    mimeHeaders.addHeader(HttpHeaders.CONNECTION, "close");
                }
                soapRequest.saveChanges();

                // Connection 생성
                soapConnection = soapConnectionFactory.createConnection();
                // Request 메시지 로그 기록
                // if (logger.isInfoEnabled()) {
                // ByteArrayOutputStream baos = null;
                // try {
                // baos = new ByteArrayOutputStream();
                // soapRequest.writeTo(baos);
                // logger.debug("SOAP Request" + Consts.CRLF + baos.toString());
                // } catch (Exception e) {
                // } finally {
                // if (baos != null) {
                // try {
                // baos.close();
                // } catch (IOException ioe) {
                // }
                // }
                // }
                // }
                // 호출
                // SOAPMessage soapResponse = soapConnection.call(soapRequest, webServiceUrl);
                // Timeout 세팅을 위해 호출 방법 변경
                URL endpoint = new URL(null, webServiceUrl, new NexosURLStreamHandler(remoteConnTimeout, remoteReadTimeout));
                SOAPMessage soapResponse = soapConnection.call(soapRequest, endpoint);
                // Response 메시지 로그 기록
                // if (logger.isInfoEnabled()) {
                // ByteArrayOutputStream baos = null;
                // try {
                // baos = new ByteArrayOutputStream();
                // soapResponse.writeTo(baos);
                // logger.debug("SOAP Response" + Consts.CRLF + baos.toString());
                // } catch (Exception e) {
                // } finally {
                // if (baos != null) {
                // try {
                // baos.close();
                // } catch (IOException ioe) {
                // }
                // }
                // }
                // }
                // 결과 파싱
                setRecvWebServiceResultMessage(soapResponse, messageFactory, webServiceTagResult, resultInfo, resultMap);
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                if (soapConnection != null) {
                    try {
                        soapConnection.close();
                    } catch (SOAPException e) {
                    }
                }
            }
        }
        // 기타
        else {
            Util.setOutMessage(resultMap, NexosMessage.getDisplayMsg("JAVA.ED.132", "처리할 수 없는 웹서비스구분입니다."));
        }

        return resultMap;
    }

    /**
     * 송신 웹서비스 호출
     *
     * @param params
     * @return
     * @throws Exception
     */
    @SuppressWarnings({"unchecked", "rawtypes"})
    @Override
    public Map<String, Object> sendWebService(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = new HashMap<String, Object>();
        Util.setOutMessage(resultMap, Consts.OK);

        String dataDiv = (String)params.get("P_DATA_DIV");
        String webServiceDiv = (String)params.get("P_WEBSERVICE_DIV");
        String webServiceUrl = (String)params.get("P_WEBSERVICE_URL");
        String webServiceHeaderVal = (String)params.get("P_WEBSERVICE_HEADER_VAL");
        String webServiceMethod = (String)params.get("P_WEBSERVICE_METHOD");
        String webServiceNSPrefix = (String)params.get("P_WEBSERVICE_NS_PREFIX");
        String webServiceNSUri = (String)params.get("P_WEBSERVICE_NS_URI");
        String webServiceParamNm = (String)params.get("P_WEBSERVICE_PARAM_NM");
        // String webServiceParamVal = (String)params.get("P_WEBSERVICE_PARAM_VAL");
        String webServiceTagResult = (String)params.get("P_WEBSERVICE_TAG_RESULT");
        String webServiceAuthDiv = (String)params.get("P_WEBSERVICE_AUTH_DIV");
        String webServiceAuthUrl = (String)params.get("P_WEBSERVICE_AUTH_URL");
        String webServiceAuthType = (String)params.get("P_WEBSERVICE_AUTH_TYPE");
        String webServiceClientId = (String)params.get("P_WEBSERVICE_AUTH_CID");
        String webServiceClientSecret = (String)params.get("P_WEBSERVICE_AUTH_CSECRET");
        int remoteConnTimeout = Util.toInt(params.get("P_REMOTE_CONN_TIMEOUT"), 60);
        int remoteReadTimeout = Util.toInt(params.get("P_REMOTE_READ_TIMEOUT"), 300);
        String remoteUserId = (String)params.get("P_REMOTE_USER_ID");
        String remoteUserPwd = (String)params.get("P_REMOTE_USER_PWD");
        String sendDocument = (String)params.get("P_DOCUMENT");
        Map<String, Object> resultInfo = (Map<String, Object>)Util.iif(Consts.DATA_DIV_XML.equals(dataDiv), params.get("P_XML_RESULT_INFO"),
            params.get("P_JSON_RESULT_INFO"));

        RestTemplate request = null;
        // 헤더값 파싱
        Map<String, Object> headerParams = Util.toKeyValues(webServiceHeaderVal);
        // 웹서비스구분 - 10 : RESTful[GET], 11 : RESTful[POST], 12 : RESTful[PUT]
        if (Util.startsWith(webServiceDiv, "1")) {

            // 웹서비스 호출 전 인증
            String authorization = null;
            if (Util.isNotNull(webServiceAuthDiv)) {
                // OAuth 인증
                if (Util.equals(webServiceAuthDiv, "2")) {
                    try {
                        request = Util.getRestTemplate(remoteConnTimeout, remoteReadTimeout, Util.isHttps(webServiceAuthUrl));
                    } catch (Exception e) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.130", "http(s) 접속을 위한 객체(Request)를 생성하지 못했습니다."), e);
                    }

                    MultiValueMap<String, String> urlVariables = new LinkedMultiValueMap<String, String>();
                    // Client credentials
                    if (AuthorizationGrantType.CLIENT_CREDENTIALS.getValue().equals(webServiceAuthType)) {
                        urlVariables.add(OAuth2ParameterNames.CLIENT_ID, webServiceClientId);
                        urlVariables.add(OAuth2ParameterNames.CLIENT_SECRET, webServiceClientSecret);
                    }
                    // password
                    else if (AuthorizationGrantType.PASSWORD.getValue().equals(webServiceAuthType)) {
                        urlVariables.add(OAuth2ParameterNames.CLIENT_ID, webServiceClientId);
                        urlVariables.add(OAuth2ParameterNames.CLIENT_SECRET, webServiceClientSecret);
                        urlVariables.add(OAuth2ParameterNames.USERNAME, remoteUserId);
                        urlVariables.add(OAuth2ParameterNames.PASSWORD, remoteUserPwd);
                    }
                    //
                    else {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.131", "[" + webServiceAuthType + "]처리할 수 없는 인증 승인유형입니다.",
                            new String[] {webServiceAuthType}));
                    }
                    urlVariables.add("grant_type", webServiceAuthType);

                    HttpHeaders requestHeader = new HttpHeaders();
                    requestHeader.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
                    if (Util.isNotNull(authorization)) {
                        requestHeader.add(AuthenticationUtil.HTTP_AUTHENTICATION_HEADER_KEY, authorization);
                        authorization = null;
                    }

                    HttpEntity requestEntity = new HttpEntity(urlVariables, requestHeader);
                    try {
                        ResponseEntity<String> response = request.postForEntity(webServiceAuthUrl, requestEntity, String.class);
                        String responseBody = Util.nullToDefault(response.getBody(), "");

                        Map<String, Object> authMap = new ObjectMapper().readValue(responseBody, new MapTypeReference<String, Object>());
                        String accessToken = (String)authMap.get(OAuth2ParameterNames.ACCESS_TOKEN);
                        authorization = TokenType.BEARER.getValue() + " " + accessToken;
                    } catch (Exception e) {
                        // HttpServerErrorException, HttpClientErrorException
                        if (e instanceof HttpStatusCodeException) {
                            HttpStatusCodeException ex = (HttpStatusCodeException)e;
                            String responseBody = new String(ex.getResponseBodyAsByteArray(), Consts.CHARSET);
                            if (responseBody.startsWith("{") && responseBody.endsWith("}")) {
                                Map<String, Object> authMap = new ObjectMapper().readValue(responseBody, new MapTypeReference<String, Object>());
                                if (authMap.containsKey(OAuth2ParameterNames.ERROR)) {
                                    throw new RuntimeException("[" + (String)authMap.get(OAuth2ParameterNames.ERROR) + "]" //
                                        + (String)authMap.get(OAuth2ParameterNames.ERROR_DESCRIPTION));
                                } else if (authMap.containsKey("message")) {
                                    throw new RuntimeException((String)authMap.get("message"));
                                } else {
                                    throw new RuntimeException("[" + ex.getStatusCode() + "]" + responseBody);
                                }
                            } else {
                                responseBody = Util.nullToDefault(ex.getStatusText(), responseBody);
                                if (Util.isNull(responseBody)) {
                                    responseBody = ex.getResponseHeaders().getFirst(HttpHeaders.WWW_AUTHENTICATE);
                                    if (Util.isNotNull(responseBody)) {
                                        Matcher matcher = Pattern.compile(OAuth2ParameterNames.ERROR_DESCRIPTION + "=\\\"(.*?)\\\"")
                                            .matcher(responseBody);
                                        if (matcher.find()) {
                                            responseBody = matcher.group(1);
                                        }
                                    }
                                }
                                throw new RuntimeException("[" + ex.getStatusCode() + "]" + responseBody);
                            }
                        } else {
                            throw e;
                        }
                    }
                }
                // CJ택배 인증
                else if (Util.equals(webServiceAuthDiv, "3")) {
                    // { "DATA":{"CUST_ID":"계약된 고객ID를 넣어 주세요"}, "BIZ_REG_NUM":"사업자 사업자 번호 넣어 주세요" }
                    String payload = Util.concat("{ \"DATA\": {\"CUST_ID\": \"", remoteUserId, "\"}, \"BIZ_REG_NUM\":\"", remoteUserPwd, "\" }");
                    try {
                        request = Util.getRestTemplate(remoteConnTimeout, remoteReadTimeout, Util.isHttps(webServiceAuthUrl));
                    } catch (Exception e) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.130", "http(s) 접속을 위한 객체(Request)를 생성하지 못했습니다."), e);
                    }

                    // Http 헤더 정보 세팅
                    HttpHeaders requestHeader = new HttpHeaders();
                    if (Util.isNotNull(headerParams)) {
                        for (Map.Entry<String, Object> header : headerParams.entrySet()) {
                            requestHeader.add(header.getKey(), header.getValue().toString());
                        }
                    }
                    if (Util.isNull(requestHeader.getContentType())) {
                        requestHeader.setContentType(MediaType.APPLICATION_JSON);
                    }

                    // Http Entity 세팅
                    HttpEntity<String> requestEntity = new HttpEntity<String>(payload, requestHeader);
                    // Http call
                    ResponseEntity<String> responseEntity = request.postForEntity(webServiceAuthUrl, requestEntity, String.class);
                    String responseBody = Util.nullToEmpty(responseEntity.getBody());
                    Map<String, Object> authMap = Util.toMap(responseBody);
                    String oMsg = Util.getOutMessage(authMap);
                    if (!Consts.OK.equals(oMsg)) {
                        throw new RuntimeException(oMsg);
                    }
                    if (authMap.isEmpty()) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "CJ택배 송신처리를 위한 인증토큰을 받지 못했습니다."));
                    }
                    String resultCd = Util.nullToEmpty(authMap.get("RESULT_CD"));
                    String resultMsg = Util.nullToEmpty(authMap.get("RESULT_DETAIL"));
                    if (!Consts.EDI_RESULT_CD_SUCCESS.equals(resultCd)) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "CJ택배 인증토큰 수신 오류\n" + resultMsg));
                    }

                    Map<String, Object> authDataMap = (Map<String, Object>)authMap.get("DATA");
                    if (Util.isNull(authDataMap)) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "CJ택배 송신처리를 위한 인증토큰을 받지 못했습니다."));
                    }

                    authorization = Util.nullToEmpty(authDataMap.get("TOKEN_NUM"));
                    if (Util.isNull(authorization)) {
                        throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.XXX", "CJ택배 송신처리를 위한 인증토큰 정보가 존재하지 않습니다."));
                    }
                }
                // Basic 인증
                else {
                    authorization = AuthenticationUtil.createBasicHttpAuthorization(remoteUserId, remoteUserPwd);
                }
            }

            try {
                request = Util.getRestTemplate(remoteConnTimeout, remoteReadTimeout, Util.isHttps(webServiceUrl));
            } catch (Exception e) {
                throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.130", "http(s) 접속을 위한 객체(Request)를 생성하지 못했습니다."), e);
            }

            try {
                String requestUrl = webServiceUrl;
                if (Util.isNotNull(webServiceMethod)) {
                    if (requestUrl.endsWith("/")) {
                        requestUrl += webServiceMethod;
                    } else {
                        requestUrl += "/" + webServiceMethod;
                    }
                }

                HttpHeaders requestHeader = new HttpHeaders();
                if (Util.isNotNull(authorization)) {
                    requestHeader.set(AuthenticationUtil.HTTP_AUTHENTICATION_HEADER_KEY, authorization);
                }

                // 헤더 정보 세팅
                if (Util.isNotNull(headerParams)) {
                    for (Map.Entry<String, Object> header : headerParams.entrySet()) {
                        requestHeader.add(header.getKey(), header.getValue().toString());
                    }
                }

                ResponseEntity<String> responseEntity = null;
                // 10 - GET
                if ("10".equals(webServiceDiv)) {
                    Map<String, String> urlVariables = new HashMap<String, String>();
                    urlVariables.put(webServiceParamNm, sendDocument);

                    requestUrl += "?" + webServiceParamNm + "={" + webServiceParamNm + "}";
                    // response = restTemplate.getForEntity(requestUrl, String.class, urlVariables);

                    HttpEntity<String> requestEntity = new HttpEntity<String>(requestHeader);
                    responseEntity = request.exchange(requestUrl, HttpMethod.GET, requestEntity, String.class, urlVariables);
                }
                // 12 - PUT
                else if ("12".equals(webServiceDiv)) {
                    // XML
                    if (Consts.DATA_DIV_XML.equals(dataDiv)) {
                        // UTF-8로 변환
                        request.getMessageConverters().add(0, new StringHttpMessageConverter(Charset.forName(Consts.CHARSET)));
                        if (requestHeader.getContentType() == null) {
                            requestHeader.setContentType(MediaType.APPLICATION_XML);
                        }
                    }
                    // JSON
                    else if (Consts.DATA_DIV_JSON.equals(dataDiv)) {
                        if (requestHeader.getContentType() == null) {
                            requestHeader.setContentType(MediaType.APPLICATION_JSON);
                        }
                    }
                    if (requestHeader.getContentType() == null) {
                        requestHeader.setContentType(MediaType.MULTIPART_FORM_DATA);
                    }

                    HttpEntity requestEntity = null;
                    // 파라메터명이 없으면 RequestBody에 추가
                    if (Util.isNull(webServiceParamNm)) {
                        requestEntity = new HttpEntity(sendDocument, requestHeader);
                        responseEntity = request.exchange(requestUrl, HttpMethod.PUT, requestEntity, String.class);
                    } else {
                        requestUrl += "?" + webServiceParamNm + "={" + webServiceParamNm + "}";
                        Map<String, String> urlVariables = new HashMap<String, String>();
                        urlVariables.put(webServiceParamNm, sendDocument);

                        requestEntity = new HttpEntity(requestHeader);
                        responseEntity = request.exchange(requestUrl, HttpMethod.PUT, requestEntity, String.class, urlVariables);
                    }
                }
                // 11 - POST
                else {
                    // XML
                    if (Consts.DATA_DIV_XML.equals(dataDiv)) {
                        // UTF-8로 변환
                        request.getMessageConverters().add(0, new StringHttpMessageConverter(Charset.forName(Consts.CHARSET)));
                        if (requestHeader.getContentType() == null) {
                            requestHeader.setContentType(MediaType.APPLICATION_XML);
                        }
                    }
                    // JSON
                    else if (Consts.DATA_DIV_JSON.equals(dataDiv)) {
                        if (requestHeader.getContentType() == null) {
                            requestHeader.setContentType(MediaType.APPLICATION_JSON);
                        }
                    }
                    if (requestHeader.getContentType() == null) {
                        requestHeader.setContentType(MediaType.MULTIPART_FORM_DATA);
                    }

                    HttpEntity requestEntity = null;
                    // 파라메터명이 없으면 RequestBody에 추가
                    if (Util.isNull(webServiceParamNm)) {
                        requestEntity = new HttpEntity(sendDocument, requestHeader);
                    } else {
                        MultiValueMap<String, String> callParams = new LinkedMultiValueMap<String, String>();
                        callParams.add(webServiceParamNm, sendDocument);

                        requestEntity = new HttpEntity(callParams, requestHeader);
                    }

                    responseEntity = request.postForEntity(requestUrl, requestEntity, String.class);
                }

                setSendWebServiceResultMessage(responseEntity, resultInfo, resultMap);
                // 송신 결과 기록
                String repDocument = (String)resultMap.get("O_REP_DOCUMENT");
                params.put("O_REP_DOCUMENT", repDocument);
                if (Util.isNotNull(repDocument)) {
                    try {
                        // 송신 원파일명에 _REP로 변경하여 기록
                        String repBackupFileFullName = (String)params.get("P_BACKUP_FILE_FULL_NM");
                        if (Util.isNotNull(repBackupFileFullName)) {
                            repBackupFileFullName = repBackupFileFullName.replace("_DOC.", "_REP.");
                            FileUtils.writeStringToFile(new File(repBackupFileFullName), repDocument, Consts.CHARSET);
                        }
                    } catch (Exception e) {
                    }
                }
            } catch (Exception e) {
                // HttpServerErrorException, HttpClientErrorException
                if (e instanceof HttpStatusCodeException) {
                    HttpStatusCodeException ex = (HttpStatusCodeException)e;
                    ResponseEntity<String> response = new ResponseEntity<String>(new String(ex.getResponseBodyAsByteArray(), Consts.CHARSET),
                        ex.getResponseHeaders(), ex.getStatusCode());
                    setSendWebServiceResultMessage(response, resultInfo, resultMap);
                } else {
                    Util.setOutMessage(resultMap, Util.getErrorMessage(e));
                }
            }
        }
        // SOAP
        else if (webServiceDiv.startsWith("2")) {

            SOAPConnection soapConnection = null;
            try {
                MessageFactory messageFactory = MessageFactory.newInstance();
                // TransformerFactory transformerFactory = TransformerFactory.newInstance();
                SOAPConnectionFactory soapConnectionFactory = SOAPConnectionFactory.newInstance();

                SOAPMessage soapRequest = messageFactory.createMessage();
                soapRequest.setProperty(SOAPMessage.CHARACTER_SET_ENCODING, Consts.CHARSET);

                SOAPPart soapPart = soapRequest.getSOAPPart();
                SOAPEnvelope soapEnvelope = soapPart.getEnvelope();

                // Namespace -> xmlns:ns1="http://endpoint.sample.com/"
                // Method -> <ns1:getMsg>
                // 데이터 -> <arg0>Send message</arg0>
                soapEnvelope.addNamespaceDeclaration(webServiceNSPrefix, webServiceNSUri);
                SOAPBody soapBody = soapEnvelope.getBody();
                SOAPElement methodElement = soapBody.addChildElement(webServiceMethod, webServiceNSPrefix);
                // 전송 데이터 입력
                if (Util.isNull(webServiceParamNm)) {
                    // 송신 데이터에 Element가 입력되어 있으면 Element 파싱 후 노드를 생성하여 송신
                    // sendDocument가 아래 형식으로 입력되어 있을 경우
                    // <web:param1>{"column1": "data1"}</web:param1>
                    // <web:param2>{"column1": "data1"}</web:param2>
                    // sendDocument에 Element가 없으면 그대로 송신
                    // {"column1": "data1"}
                    Pattern patternElement = Pattern.compile("<" + webServiceNSPrefix + ":(.*?)>(.*?)</" + webServiceNSPrefix + ":(.*?)>",
                        Pattern.DOTALL);
                    Matcher matcher = patternElement.matcher(sendDocument);
                    if (matcher.find()) {
                        do {
                            // logger.debug("Namespace Prefix : " + matcher.group(1) //
                            // + "\nElement Content : " + matcher.group(2));
                            String docWebServiceParamNm = matcher.group(1); // webServiceNSPrefix
                            String docWebServiceParamVal = matcher.group(2); // Data;
                            SOAPElement soapElement = methodElement.addChildElement(docWebServiceParamNm, webServiceNSPrefix);
                            soapElement.setTextContent(docWebServiceParamVal);
                        } while (matcher.find());
                    } else {
                        methodElement.setTextContent(sendDocument);
                    }
                } else {
                    SOAPElement soapElement = methodElement.addChildElement(webServiceParamNm, webServiceNSPrefix);
                    soapElement.setTextContent(sendDocument);
                }

                // 헤더 정보 세팅
                MimeHeaders mimeHeaders = soapRequest.getMimeHeaders();
                if (Util.isNotNull(headerParams)) {
                    for (Map.Entry<String, Object> header : headerParams.entrySet()) {
                        mimeHeaders.addHeader(header.getKey(), header.getValue().toString());
                    }
                }

                if ("1".equals(webServiceAuthType)) {
                    mimeHeaders.addHeader(HttpHeaders.AUTHORIZATION, AuthenticationUtil.createBasicHttpAuthorization(remoteUserId, remoteUserPwd));
                }

                // 기본 헤더 정보가 없을 시 추가 세팅
                if (mimeHeaders.getHeader(HttpHeaders.CONTENT_TYPE) == null) {
                    mimeHeaders.addHeader(HttpHeaders.CONTENT_TYPE, "application/soap+xml; charset=" + Consts.CHARSET);
                }
                if (mimeHeaders.getHeader(HttpHeaders.CONNECTION) == null) {
                    // mimeHeaders.addHeader(HttpHeaders.CONNECTION, "Keep-Alive");
                    mimeHeaders.addHeader(HttpHeaders.CONNECTION, "close");
                }
                soapRequest.saveChanges();

                // Connection 생성
                soapConnection = soapConnectionFactory.createConnection();
                // Request 메시지 로그 기록
                // if (logger.isInfoEnabled()) {
                // ByteArrayOutputStream baos = null;
                // try {
                // Iterator headers = mimeHeaders.getAllHeaders();
                // StringBuffer sbLog = new StringBuffer();
                // while (headers.hasNext()) {
                // MimeHeader header = (MimeHeader)headers.next();
                // sbLog.append(header.getName()).append("=").append(header.getValue()).append("\n");
                // }
                // logger.debug("SOAP Request Header" + Consts.CRLF + sbLog.toString());
                //
                // baos = new ByteArrayOutputStream();
                // soapRequest.writeTo(baos);
                // logger.debug("SOAP Request" + Consts.CRLF + baos.toString());
                // } catch (Exception e) {
                // } finally {
                // if (baos != null) {
                // try {
                // baos.close();
                // } catch (IOException ioe) {
                // }
                // }
                // }
                // }
                // 호출
                // SOAPMessage soapResponse = soapConnection.call(soapRequest, webServiceUrl);
                // Timeout 세팅을 위해 호출 방법 변경
                URL endpoint = new URL(null, webServiceUrl, new NexosURLStreamHandler(remoteConnTimeout, remoteReadTimeout));
                SOAPMessage soapResponse = soapConnection.call(soapRequest, endpoint);
                // Response 메시지 로그 기록
                // if (logger.isInfoEnabled()) {
                // ByteArrayOutputStream baos = null;
                // try {
                // baos = new ByteArrayOutputStream();
                // soapResponse.writeTo(baos);
                // logger.debug("SOAP Response" + Consts.CRLF + baos.toString());
                // } catch (Exception e) {
                // } finally {
                // if (baos != null) {
                // try {
                // baos.close();
                // } catch (IOException ioe) {
                // }
                // }
                // }
                // }
                // 결과 파싱
                setSendWebServiceResultMessage(soapResponse, messageFactory, webServiceTagResult, resultInfo, resultMap);
                params.put("O_REP_DOCUMENT", resultMap.get("O_REP_DOCUMENT"));
            } catch (Exception e) {
                Util.setOutMessage(resultMap, Util.getErrorMessage(e));
            } finally {
                if (soapConnection != null) {
                    try {
                        soapConnection.close();
                    } catch (SOAPException e) {
                    }
                }
            }
        }
        // 기타
        else {
            Util.setOutMessage(resultMap, NexosMessage.getDisplayMsg("JAVA.ED.132", "처리할 수 없는 웹서비스구분입니다."));
        }

        return resultMap;
    }

    @Override
    public String urlEncodeMessage(Map<String, Object> resultInfo, String message) {

        return urlEncodeMessage(Consts.YES.equals(resultInfo.get("P_MESSAGE_ENCODE_YN")), message);
    }

    @Override
    public String urlEncodeMessage(boolean encode, String message) {

        String result = Util.nullToEmpty(message);

        if (encode) {
            try {
                result = URLEncoder.encode(result, Consts.CHARSET);
            } catch (Exception e) {
            }
        }
        return result;
    }

    @Override
    public String urlDecodeMessage(Map<String, Object> resultInfo, String message) {

        return urlDecodeMessage(Consts.YES.equals(resultInfo.get("P_MESSAGE_DECODE_YN")), message);
    }

    @Override
    public String urlDecodeMessage(boolean decode, String message) {

        String result = Util.nullToEmpty(message);
        if (decode) {
            try {
                result = URLDecoder.decode(result, Consts.CHARSET);
            } catch (Exception e) {
            }
        }
        return result;
    }

    private void setRecvWebServiceResultMessage(ResponseEntity<String> response, Map<String, Object> resultInfo, Map<String, Object> resultMap) {

        String patternResultCd = (String)resultInfo.get("P_PATTERN_RESULT_CD");
        String patternResultMsg = (String)resultInfo.get("P_PATTERN_RESULT_MSG");
        String resultCdSuccess = (String)resultInfo.get("P_RESULT_CD_SUCCESS");

        Pattern patternCd = Pattern.compile(patternResultCd, Pattern.DOTALL);
        String responseBody = response.getBody();
        Matcher matcherCd = patternCd.matcher(responseBody);
        if (matcherCd.find()) {
            String errorCd = Util.nullToDefault(matcherCd.group(1), "").replaceAll("\\\"(.*?)\\\"", "$1"); // " 제거

            if (resultCdSuccess.equals(errorCd)) {
                resultMap.put("O_DOCUMENT", responseBody);
                Util.setOutMessage(resultMap, Consts.OK);
            } else {
                Pattern patternMsg = Pattern.compile(patternResultMsg, Pattern.DOTALL);
                Matcher matcherMsg = patternMsg.matcher(responseBody);
                if (matcherMsg.find()) {
                    String errorMessage = urlDecodeMessage(resultInfo, matcherMsg.group(1));
                    Util.setOutMessage(resultMap, NexosMessage.getDisplayMsg("JAVA.ED.133", "오류코드: " + errorCd + ", 오류내역: " + errorMessage,
                        new String[] {errorCd, errorMessage}));
                } else {
                    Util.setOutMessage(resultMap, urlDecodeMessage(resultInfo, responseBody));
                }
            }
        } else {
            if (HttpStatus.OK == response.getStatusCode()) {
                resultMap.put("O_DOCUMENT", urlDecodeMessage(resultInfo, responseBody));
            } else {
                if (Util.isNull(responseBody)) {
                    Util.setOutMessage(resultMap, "[" + response.getStatusCode().value() + "] - " + response.getStatusCode().getReasonPhrase());
                } else {
                    Util.setOutMessage(resultMap, urlDecodeMessage(resultInfo, responseBody));
                }
            }
        }
    }

    private void setSendWebServiceResultMessage(ResponseEntity<String> response, Map<String, Object> resultInfo, Map<String, Object> resultMap) {

        String patternResultCd = (String)resultInfo.get("P_PATTERN_RESULT_CD");
        String patternResultMsg = (String)resultInfo.get("P_PATTERN_RESULT_MSG");
        String resultCdSuccess = (String)resultInfo.get("P_RESULT_CD_SUCCESS");

        Pattern patternCd = Pattern.compile(patternResultCd, Pattern.DOTALL);
        String responseBody = Util.nullToEmpty(response.getBody()).replaceAll("(\r\n|\r|\n|\n\r)", ""); // 개행문자 제거
        resultMap.put("O_REP_DOCUMENT", responseBody);
        Matcher matcherCd = patternCd.matcher(responseBody);
        if (matcherCd.find()) {
            String errorCd = Util.nullToDefault(matcherCd.group(1), "").replaceAll("\\\"(.*?)\\\"", "$1"); // " 제거

            if (resultCdSuccess.equals(errorCd)) {
                Util.setOutMessage(resultMap, Consts.OK);
            } else {
                Pattern patternMsg = Pattern.compile(patternResultMsg, Pattern.DOTALL);
                Matcher matcherMsg = patternMsg.matcher(responseBody);
                String errorMessage = "";
                if (matcherMsg.find()) {
                    errorMessage = urlDecodeMessage(resultInfo, matcherMsg.group(1));
                    // 레벨 다운, 상세 메시지 추가 파싱
                    if (matcherMsg.find()) {
                        errorMessage += ", " + urlDecodeMessage(resultInfo, matcherMsg.group(1));
                    }
                    errorMessage = NexosMessage.getDisplayMsg("JAVA.ED.133", "오류코드: " + errorCd + ", 오류내역: " + errorMessage,
                        new String[] {errorCd, errorMessage});
                } else {
                    errorMessage = urlDecodeMessage(resultInfo, responseBody);
                }
                Util.setOutMessage(resultMap, errorMessage);
            }
        }
        // 결과 포맷으로 리턴되지 않았을 경우, Http status로 처리
        else {
            if (HttpStatus.OK == response.getStatusCode()) {
                Util.setOutMessage(resultMap, Consts.OK);
            } else {
                if (Util.isNull(responseBody)) {
                    Util.setOutMessage(resultMap, "[" + response.getStatusCode().value() + "] - " + response.getStatusCode().getReasonPhrase());
                } else {
                    // 정의된 오류가 아닐 경우 기본 처리
                    Matcher matcherMsg = Pattern.compile("\"error\":\\s{0,}\"(.*?)\"", Pattern.DOTALL).matcher(responseBody);
                    String errorMessage = "";
                    if (matcherMsg.find()) {
                        errorMessage = urlDecodeMessage(resultInfo, matcherMsg.group(1));
                    } else {
                        errorMessage = urlDecodeMessage(resultInfo, responseBody);
                    }
                    Util.setOutMessage(resultMap, errorMessage);
                }
            }
        }
    }

    private void setRecvWebServiceResultMessage(SOAPMessage soapResponse, MessageFactory messageFactory, String webServiceTagResult,
        Map<String, Object> resultInfo, Map<String, Object> resultMap) {

        String patternResultCd = (String)resultInfo.get("P_PATTERN_RESULT_CD");
        String patternResultMsg = (String)resultInfo.get("P_PATTERN_RESULT_MSG");
        String resultCdSuccess = (String)resultInfo.get("P_RESULT_CD_SUCCESS");

        Pattern patternCd = Pattern.compile(patternResultCd, Pattern.DOTALL);

        try {
            SOAPMessage resultMessage = soapResponse;
            // GZip 압출 체크, 변경
            MimeHeaders mimeHeaders = soapResponse.getMimeHeaders();
            String[] encodings = mimeHeaders.getHeader(HttpHeaders.CONTENT_ENCODING);
            if (encodings != null) {
                for (int i = 0; i < encodings.length; i++) {
                    if (encodings[i].toLowerCase().equals("gzip")) {
                        ByteArrayOutputStream byteArrayStream = null;
                        GZIPInputStream gzipStream = null;
                        try {
                            byteArrayStream = new ByteArrayOutputStream();
                            resultMessage.writeTo(byteArrayStream);
                            gzipStream = new GZIPInputStream(new ByteArrayInputStream(byteArrayStream.toByteArray()));
                            resultMessage = messageFactory.createMessage(mimeHeaders, gzipStream);
                        } finally {
                            Util.closeObject(byteArrayStream);
                            Util.closeObject(gzipStream);
                        }
                        break;
                    }
                }
            }

            // Body Parsing
            SOAPBody soapBody = resultMessage.getSOAPBody();
            if (soapBody.hasFault()) {
                SOAPFault fault = soapBody.getFault();
                throw new RuntimeException(String.format(NexosMessage.getDisplayMsg("JAVA.ED.134", "웹서비스 호출 오류\n오류코드: %s, 오류내역: %s"),
                    fault.getFaultCode(), fault.getFaultString()));
            } else {
                String responseBody = "";
                // 호출결과 태그가 있을 경우 호출 결과 태그를 먼저 검색
                if (Util.isNotNull(webServiceTagResult)) {
                    NodeList resultTagNodes = soapBody.getElementsByTagName(webServiceTagResult);
                    if (resultTagNodes != null && resultTagNodes.getLength() > 0) {
                        Node resultTagNode = resultTagNodes.item(0);
                        responseBody = resultTagNode.getTextContent();
                    }
                }
                // 호출결과 태그로 데이터를 검색하지 못하면 전체 데이터로 처리
                if (Util.isNull(responseBody)) {
                    ByteArrayOutputStream byteArrayStream = null;
                    try {
                        byteArrayStream = new ByteArrayOutputStream();
                        resultMessage.writeTo(byteArrayStream);
                        responseBody = new String(byteArrayStream.toByteArray(), Consts.CHARSET);
                    } finally {
                        Util.closeObject(byteArrayStream);
                    }
                }

                // 결과태그 검색 있으면 체크 후 입력
                Matcher matcherCd = patternCd.matcher(responseBody);
                if (matcherCd.find()) {
                    String errorCd = Util.nullToDefault(matcherCd.group(1), "").replaceAll("\\\"(.*?)\\\"", "$1"); // " 제거

                    if (resultCdSuccess.equals(errorCd)) {
                        resultMap.put("O_DOCUMENT", responseBody);
                        Util.setOutMessage(resultMap, Consts.OK);
                    } else {
                        Pattern patternMsg = Pattern.compile(patternResultMsg, Pattern.DOTALL);
                        Matcher matcherMsg = patternMsg.matcher(responseBody);
                        if (matcherMsg.find()) {
                            String errorMessage = urlDecodeMessage(resultInfo, matcherMsg.group(1));
                            Util.setOutMessage(resultMap, NexosMessage.getDisplayMsg("JAVA.ED.133", "오류코드: " + errorCd + ", 오류내역: " + errorMessage,
                                new String[] {errorCd, errorMessage}));
                        } else {
                            Util.setOutMessage(resultMap, urlDecodeMessage(resultInfo, responseBody));
                        }
                    }
                }
                // 결과태그가 없을 경우 전체 데이터 입력
                else {
                    resultMap.put("O_DOCUMENT", urlDecodeMessage(resultInfo, responseBody));
                }
            }
        } catch (Exception e) {
            Util.setOutMessage(resultMap, Util.getErrorMessage(e));
        }
    }

    private void setSendWebServiceResultMessage(SOAPMessage soapResponse, MessageFactory messageFactory, String webServiceTagResult,
        Map<String, Object> resultInfo, Map<String, Object> resultMap) {

        String patternResultCd = (String)resultInfo.get("P_PATTERN_RESULT_CD");
        String patternResultMsg = (String)resultInfo.get("P_PATTERN_RESULT_MSG");
        String resultCdSuccess = (String)resultInfo.get("P_RESULT_CD_SUCCESS");

        Pattern patternCd = Pattern.compile(patternResultCd, Pattern.DOTALL);
        try {
            SOAPMessage resultMessage = soapResponse;
            // GZip 압출 체크, 변경
            MimeHeaders mimeHeaders = soapResponse.getMimeHeaders();
            String[] encodings = mimeHeaders.getHeader(HttpHeaders.CONTENT_ENCODING);
            if (encodings != null) {
                for (int i = 0; i < encodings.length; i++) {
                    if (encodings[i].toLowerCase().equals("gzip")) {
                        ByteArrayOutputStream byteArrayStream = null;
                        GZIPInputStream gzipStream = null;
                        try {
                            byteArrayStream = new ByteArrayOutputStream();
                            resultMessage.writeTo(byteArrayStream);
                            gzipStream = new GZIPInputStream(new ByteArrayInputStream(byteArrayStream.toByteArray()));
                            resultMessage = messageFactory.createMessage(mimeHeaders, gzipStream);
                        } finally {
                            Util.closeObject(byteArrayStream);
                            Util.closeObject(gzipStream);
                        }
                        break;
                    }
                }
            }

            // Body Parsing
            SOAPBody soapBody = resultMessage.getSOAPBody();
            if (soapBody.hasFault()) {
                SOAPFault fault = soapBody.getFault();
                throw new RuntimeException(String.format(NexosMessage.getDisplayMsg("JAVA.ED.134", "웹서비스 호출 오류\n오류코드: %s, 오류내역: %s"),
                    fault.getFaultCode(), fault.getFaultString()));
            } else {
                String responseBody = "";
                // 호출결과 태그가 있을 경우 호출 결과 태그를 먼저 검색
                if (Util.isNotNull(webServiceTagResult)) {
                    NodeList resultTagNodes = soapBody.getElementsByTagName(webServiceTagResult);
                    if (resultTagNodes != null && resultTagNodes.getLength() > 0) {
                        Node resultTagNode = resultTagNodes.item(0);
                        responseBody = resultTagNode.getTextContent();
                    }
                }
                // 호출결과 태그로 데이터를 검색하지 못하면 전체 데이터로 처리
                if (Util.isNull(responseBody)) {
                    ByteArrayOutputStream byteArrayStream = null;
                    try {
                        byteArrayStream = new ByteArrayOutputStream();
                        resultMessage.writeTo(byteArrayStream);
                        responseBody = new String(byteArrayStream.toByteArray(), Consts.CHARSET);
                    } finally {
                        Util.closeObject(byteArrayStream);
                    }
                }

                // 결과태그 검색 있으면 체크 후 입력
                Matcher matcherCd = patternCd.matcher(responseBody);
                if (matcherCd.find()) {
                    String errorCd = Util.nullToDefault(matcherCd.group(1), "").replaceAll("\\\"(.*?)\\\"", "$1"); // " 제거

                    if (resultCdSuccess.equals(errorCd)) {
                        Util.setOutMessage(resultMap, Consts.OK);
                    } else {
                        Pattern patternMsg = Pattern.compile(patternResultMsg, Pattern.DOTALL);
                        Matcher matcherMsg = patternMsg.matcher(responseBody);
                        if (matcherMsg.find()) {
                            String errorMessage = urlDecodeMessage(resultInfo, matcherMsg.group(1));
                            Util.setOutMessage(resultMap, NexosMessage.getDisplayMsg("JAVA.ED.133", "오류코드: " + errorCd + ", 오류내역: " + errorMessage,
                                new String[] {errorCd, errorMessage}));
                        } else {
                            Util.setOutMessage(resultMap, urlDecodeMessage(resultInfo, responseBody));
                        }
                    }
                }
                // 결과태그가 없을 경우 전체 데이터로 체크
                else {
                    if (resultCdSuccess.equals(responseBody) || Consts.OK.equals(responseBody)) {
                        Util.setOutMessage(resultMap, Consts.OK);
                    } else {
                        Util.setOutMessage(resultMap, urlDecodeMessage(resultInfo, responseBody));
                    }
                }
            }
        } catch (Exception e) {
            Util.setOutMessage(resultMap, Util.getErrorMessage(e));
        }
    }

    @Override
    public Map<String, Object> sendDataProcessing(Map<String, Object> params) throws Exception {

        Map<String, Object> resultMap = null;

        String dataDiv = Util.nullToEmpty(params.get("P_DATA_DIV"));

        if (Util.isNull(params.get("P_SEND_DATE"))) {
            params.put("P_SEND_DATE", getEDIDate());
        }

        // DBLink
        if (Consts.DATA_DIV_DBLINK.equals(dataDiv)) {
            resultMap = sendDBLink(params);
        }
        // DBConnect
        else if (Consts.DATA_DIV_DBCONNECT.equals(dataDiv)) {
            resultMap = sendDBConnect(params);
        }
        // EXCEL
        else if (Consts.DATA_DIV_XLS.equals(dataDiv)) {
            resultMap = sendExcel(params);
        }
        // TEXT
        else if (Consts.DATA_DIV_TXT.equals(dataDiv)) {
            resultMap = sendText(params);
        }
        // XML
        else if (Consts.DATA_DIV_XML.equals(dataDiv)) {
            resultMap = sendXML(params);
        }
        // JSON
        else if (Consts.DATA_DIV_JSON.equals(dataDiv)) {
            resultMap = sendJson(params);
        }
        // SAP
        else if (Consts.DATA_DIV_SAP.equals(dataDiv)) {
            resultMap = sendSAPFunction(params);
        }
        // 기타 오류
        else {
            throw new RuntimeException(NexosMessage.getDisplayMsg("JAVA.ED.087", "[" + dataDiv + "]정의되지 않은 데이터 처리유형입니다.", new String[] {dataDiv}));
        }
        return resultMap;
    }

    @Override
    public String sendEmail(Map<String, Object> params) {

        String result = Consts.OK;

        // javax.mail.Transport transport = null;
        try {
            // 465(TLS)
            // mailServerProps.put("mail.smtp.host", "smtp.gmail.com");
            // mailServerProps.put("mail.smtp.port", "465");
            // mailServerProps.put("mail.smtp.auth", "true");
            // mailServerProps.put("mail.smtp.socketFactory.port", "465");
            // mailServerProps.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
            // 587(SSL0)
            // mailServerProps.put("mail.smtp.host", "smtp.gmail.com");
            // mailServerProps.put("mail.smtp.port", "587");
            // mailServerProps.put("mail.smtp.auth", "true");
            // mailServerProps.put("mail.smtp.starttls.enable", "true");

            // 메일 서버 속성 세팅
            Properties mailServerProps = new Properties();
            String mailServerParams = (String)params.get("P_MAIL_SERVER_PARAMS");
            if (mailServerParams != null) {
                String[] keyValues = mailServerParams.split(Consts.CR);
                for (String keyValue : keyValues) {
                    String[] keyValueArray = Util.toKeyValue(keyValue);
                    if (keyValueArray != null && keyValueArray.length > 1) {
                        mailServerProps.put(keyValueArray[0], keyValueArray[1]);
                    }
                }
            }

            // 인증 세팅, 인증 상세 정보는 mailServerProps에 세팅
            final String mailUserId = (String)params.get("P_MAIL_USER_ID");
            final String mailUserPwd = (String)params.get("P_MAIL_USER_PWD");
            javax.mail.Session mailSession = null;
            if (Boolean.TRUE.toString().equalsIgnoreCase((String)mailServerProps.get("mail.smtp.auth"))) {
                // mailSession = javax.mail.Session.getDefaultInstance(mailServerProps, new javax.mail.Authenticator() {
                // @Override
                // public javax.mail.PasswordAuthentication getPasswordAuthentication() {
                // return new javax.mail.PasswordAuthentication(mailUserId, mailUserPwd);
                // }
                // });
                mailSession = javax.mail.Session.getInstance(mailServerProps, new javax.mail.Authenticator() {
                    @Override
                    public javax.mail.PasswordAuthentication getPasswordAuthentication() {
                        return new javax.mail.PasswordAuthentication(mailUserId, mailUserPwd);
                    }
                });
            } else {
                // mailSession = javax.mail.Session.getDefaultInstance(mailServerProps, null);
                mailSession = javax.mail.Session.getInstance(mailServerProps, null);
            }

            javax.mail.internet.MimeMessage mailMessage = new javax.mail.internet.MimeMessage(mailSession);
            // 보내는 사람 세팅
            String from = (String)params.get("P_MAIL_FROM");
            if (Util.isNotNull(from)) {
                mailMessage.setFrom(new javax.mail.internet.InternetAddress(from));
            }
            // 받는 사람 세팅
            String recipients = (String)params.get("P_MAIL_TO");
            if (recipients != null) {
                String[] arrRecipients = recipients.split(Consts.CR);
                for (String recipient : arrRecipients) {
                    mailMessage.addRecipient(javax.mail.Message.RecipientType.TO, new javax.mail.internet.InternetAddress(recipient));
                }
            }
            // 참조 세팅
            recipients = (String)params.get("P_MAIL_CC");
            if (recipients != null) {
                String[] arrRecipients = recipients.split(Consts.CR);
                for (String recipient : arrRecipients) {
                    mailMessage.addRecipient(javax.mail.Message.RecipientType.CC, new javax.mail.internet.InternetAddress(recipient));
                }
            }
            // 숨은 참조 세팅
            recipients = (String)params.get("P_MAIL_BCC");
            if (recipients != null) {
                String[] arrRecipients = recipients.split(Consts.CR);
                for (String recipient : arrRecipients) {
                    mailMessage.addRecipient(javax.mail.Message.RecipientType.BCC, new javax.mail.internet.InternetAddress(recipient));
                }
            }

            // 메일 제목
            String mailTitle = (String)params.get("P_MAIL_TITLE");
            if (mailTitle != null) {
                mailMessage.setSubject(mailTitle);
            }
            mailMessage.setHeader("Content-Type", "text/plain; charset=utf-8");
            String messageHeaderParams = (String)params.get("P_MESSAGE_HEADER_PARAMS");
            if (messageHeaderParams != null) {
                String[] keyValues = messageHeaderParams.split(Consts.CR);
                for (String keyValue : keyValues) {
                    String[] keyValueArray = Util.toKeyValue(keyValue);
                    if (keyValueArray != null && keyValueArray.length > 1) {
                        mailMessage.setHeader(keyValueArray[0], keyValueArray[1]);
                    }
                }
            }

            // 메일 내용, 컨텐트 타입
            String mailContent = (String)params.get("P_MAIL_CONTENT");
            String mailContentType = (String)params.get("P_MAIL_CONTENT_TYPE");
            mailMessage.setContent(mailContent, Util.nullToDefault(mailContentType, "text/html; charset=utf-8"));

            javax.mail.Transport.send(mailMessage);
            // transport = mailSession.getTransport("smtp");
            // transport.connect(mailUserId, mailUserPwd);
            // transport.sendMessage(mailMessage, mailMessage.getAllRecipients());
        } catch (Exception e) {
            result = Util.getErrorMessage(e);
        } finally {
            // if (transport != null) {
            // try {
            // transport.close();
            // } catch (Exception se) {
            // }
            // }
        }

        return result;
    }

    @Override
    public String getRecvFileRootPath() {

        return NexosSupport.getWebFileRootPath("FILE.EDI.RECV");
    }

    @Override
    public String getSendFileRootPath() {

        return NexosSupport.getWebFileRootPath("FILE.EDI.SEND");
    }

    @Override
    public String getBackupFilePath(String path, String curDatetime, String ediDiv) {

        // 송수신구분별
        if ("2".equals(NexosSupport.getGlobalProperty("EDI.FILE.BACKUP_DIV", "1"))) {
            return Util.getPathName(path, Consts.BACKUP_DIR, curDatetime.substring(0, 8), ediDiv);
        }

        // 기본 위치
        return Util.getPathName(path, Consts.BACKUP_DIR, curDatetime.substring(0, 8));
    }

    @Override
    public void insertEMIFResult(Map<String, Object> params) throws DataAccessException {

        List<Map<String, Object>> dsMaster = Util.nullToEmpty(params, Consts.PK_DS_MASTER);
        String buCd = (String)params.get("P_BU_CD");
        String ediDiv = (String)params.get("P_EDI_DIV");
        String defineNo = (String)params.get("P_DEFINE_NO");
        String ediDate = (String)params.get("P_EDI_DATE");
        String ediNo = (String)params.get("P_EDI_NO");
        String userId = (String)params.get(Consts.PK_USER_ID);

        for (int rIndex = 0, rCount = dsMaster.size(); rIndex < rCount; rIndex++) {
            Map<String, Object> rowData = dsMaster.get(rIndex);

            rowData.put("P_BU_CD", buCd);
            rowData.put("P_EDI_DIV", ediDiv);
            rowData.put("P_DEFINE_NO", defineNo);
            rowData.put("P_EDI_DATE", ediDate);
            rowData.put("P_EDI_NO", ediNo);
            rowData.put(Consts.PK_USER_ID, userId);
            rowData.put(Consts.PK_REG_USER_ID, userId);
            rowData.put(Consts.PK_REG_DATETIME, Consts.DV_SYSDATE);

            insertSql(INSERT_ID_EMIFRESULT, rowData);
        }
    }

    /**
     * Json Tag 연결매핑 구조일 경우 master에 해당하는 detail인지 체크
     *
     * @param masterRowData
     * @param detailRowData
     * @param jsonTagLinkColumns
     * @return
     */
    private boolean isJsonLinkData(Map<String, Object> masterRowData, Map<String, Object> detailRowData, String[] jsonTagLinkColumns) {

        for (String linkColumn : jsonTagLinkColumns) {
            if (!Util.equals(masterRowData.get(linkColumn), detailRowData.get(linkColumn))) {
                return false;
            }
        }

        return true;
    }
}
